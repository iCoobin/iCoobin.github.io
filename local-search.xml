<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode 刷题插件，好用</title>
    <link href="/2023/03/22/LeetCode-%E5%88%B7%E9%A2%98%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%A5%BD%E7%94%A8/"/>
    <url>/2023/03/22/LeetCode-%E5%88%B7%E9%A2%98%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%A5%BD%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-刷题插件，好用"><a href="#LeetCode-刷题插件，好用" class="headerlink" title="LeetCode 刷题插件，好用"></a>LeetCode 刷题插件，好用</h2><h3 id="安装-LeetCode-插件"><a href="#安装-LeetCode-插件" class="headerlink" title="安装 LeetCode 插件"></a>安装 LeetCode 插件</h3><ul><li>点击插件模块</li><li>搜索 leetcode 插件</li><li>点击 install 安装 leetcode 插件</li><li>点击 leetcode 设置按钮，去设置</li></ul><p><img src="/posts_img/leetcode-plugin-1.jpg"></p><ul><li>选择中国区 leetcode-cn</li><li>选择常用编程语言</li></ul><p><img src="/posts_img/leetcode-plugin-2.jpg"></p><ul><li><code>command</code> + <code>shift</code> + <code>p</code> 快捷搜索指令</li><li>搜索 leetcode</li><li>选择 leetcode：sign in 回车</li><li>输入 leetcode 用户名或者邮箱</li><li>输入 leetcode 密码</li><li>登录完成</li><li>点击图标切换到 leetcode 模块</li></ul><p><img src="/posts_img/leetcode-plugin-3.jpg"></p><ul><li>下面就是效果啦，所有的题库都已分类好</li><li>使用起来非常方便，暴赞一下</li></ul><p><img src="/posts_img/leetcode-plugin.png"></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>VS Code Plugin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 语法画流程图</title>
    <link href="/2023/03/20/other/Markdown-%E8%AF%AD%E6%B3%95%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <url>/2023/03/20/other/Markdown-%E8%AF%AD%E6%B3%95%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="Markdown-语法画流程图"><a href="#Markdown-语法画流程图" class="headerlink" title="Markdown 语法画流程图"></a>Markdown 语法画流程图</h2><h3 id="添加支持"><a href="#添加支持" class="headerlink" title="添加支持"></a>添加支持</h3><div class="code-wrapper"><pre><code class="hljs sh">npm install --save hexo-filter-flowchart</code></pre></div><h3 id="一个简单的流程图"><a href="#一个简单的流程图" class="headerlink" title="一个简单的流程图"></a>一个简单的流程图</h3><ul><li>语法如下</li></ul><blockquote><p>```flow<br>st&#x3D;&gt;start: 开始<br>e&#x3D;&gt;end: 结束<br>op&#x3D;&gt;operation: 我的操作<br>cond&#x3D;&gt;condition: 确认？</p><p>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br>```</p></blockquote><ul><li>效果如下</li></ul><div id="flowchart-0" class="flow-chart"></div><h3 id="一个稍微复杂的流程"><a href="#一个稍微复杂的流程" class="headerlink" title="一个稍微复杂的流程"></a>一个稍微复杂的流程</h3><ul><li><p>语法如下</p><blockquote><p>```flow<br>st&#x3D;&gt;start: Start:&gt;<a href="http://www.google.com[blank]">http://www.google.com[blank]</a><br>e&#x3D;&gt;end:&gt;<a href="http://www.google.com/">http://www.google.com</a><br>op1&#x3D;&gt;operation: My Operation<br>sub1&#x3D;&gt;subroutine: My Subroutine<br>cond&#x3D;&gt;condition: Yes<br>or No?:&gt;<a href="http://www.google.com/">http://www.google.com</a><br>io&#x3D;&gt;inputoutput: catch something…</p><p>st-&gt;op1-&gt;cond<br>cond(yes)-&gt;io-&gt;e<br>cond(no)-&gt;sub1(right)-&gt;op1<br>```</p></blockquote></li><li><p>效果如下</p></li></ul><div id="flowchart-1" class="flow-chart"></div><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始e=>end: 结束op=>operation: 我的操作cond=>condition: 确认？st->op->condcond(yes)->econd(no)->op</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: Start:>http://www.google.com[blank]e=>end:>http://www.google.comop1=>operation: My Operationsub1=>subroutine: My Subroutinecond=>condition: Yesor No?:>http://www.google.comio=>inputoutput: catch something...st->op1->condcond(yes)->io->econd(no)->sub1(right)->op1</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://whb1990.github.io/posts/711ce00.html">Markdown语法画流程图</a><p><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 使用 RunLoop</title>
    <link href="/2023/03/18/ios/iOS-%E4%BD%BF%E7%94%A8-RunLoop/"/>
    <url>/2023/03/18/ios/iOS-%E4%BD%BF%E7%94%A8-RunLoop/</url>
    
    <content type="html"><![CDATA[<h2 id="iOS-使用-RunLoop"><a href="#iOS-使用-RunLoop" class="headerlink" title="iOS 使用 RunLoop"></a>iOS 使用 RunLoop</h2><p><img src="/index_imgs/runloop.png"></p><h3 id="RunLoop-创建并保活"><a href="#RunLoop-创建并保活" class="headerlink" title="RunLoop 创建并保活"></a>RunLoop 创建并保活</h3><p>RunLoop 与线程是一一对应关系，我们只能通过当前线程首次访问创建并获取当前线程的 RunLoop 对象。有 Foundation 中的 NSRunLoop 和 CoreFoudation 中的 CFRunLoopRef 两种获取方式。</p><h4 id="方式1：使用-initWithBlock-方式创建启动线程"><a href="#方式1：使用-initWithBlock-方式创建启动线程" class="headerlink" title="方式1：使用 initWithBlock: 方式创建启动线程"></a>方式1：使用 initWithBlock: 方式创建启动线程</h4><ul><li>1.1 只在 Block 中启动 RunLoop<ul><li>该方式 RunLoop 不会对当前 self 对象强引用</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.thread = [[MyThread alloc] initWithBlock:^&#123;<span class="hljs-built_in">NSRunLoop</span> *runloop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<span class="hljs-comment">// 线程保活，需要添加一个 Port </span>    [runloop addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init]                  forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];<span class="hljs-comment">// run 方法运行 runloop，并且 runloop 永远无法关闭</span>[runloop run];&#125;];[<span class="hljs-keyword">self</span>.thread start];<span class="hljs-comment">/// 这里的 self 可自由 dealloc</span></code></pre></div><ul><li>1.2 在 block 中调用 C  函数启动 RunLoop<ul><li>该方式 RunLoop 不会对当前 self 对象强引用</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-type">void</span> run(<span class="hljs-type">void</span>) &#123;<span class="hljs-built_in">NSRunLoop</span> *runloop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<span class="hljs-comment">// 线程保活，需要添加一个 Port </span>[runloop addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init]                  forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];<span class="hljs-comment">// run 方法运行 runloop，并且 runloop 永远无法关闭</span>[runloop run];&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.thread = [[MyThread alloc] initWithBlock:^&#123;<span class="hljs-comment">//调用 C 方法获取</span>run();&#125;];[<span class="hljs-keyword">self</span>.thread start];<span class="hljs-comment">/// 这种方式获取，runloop 对 self 也不会产生强引用，self 可自由 dealloc</span></code></pre></div><ul><li>1.3 调用 [self run] 的方式启动 RunLoop<ul><li>注意：该方式 RunLoop 启动的堆栈会对 self 强引用</li><li>不管 self 是 __weak 还是 strong 都会被 RunLoop 堆栈强引用</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)run &#123;        <span class="hljs-built_in">NSRunLoop</span> *runloop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];    <span class="hljs-comment">// 线程保活，需要添加一个 Port </span>    [runloop addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init]                  forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];<span class="hljs-comment">// run 方法运行 runloop，并且 runloop 永远无法关闭</span>    [runloop run];&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs objc">__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) _weakSlef = <span class="hljs-keyword">self</span>;<span class="hljs-keyword">self</span>.thread = [[MyThread alloc] initWithBlock:^&#123;<span class="hljs-comment">//给 self 发送消息</span>[_weakSlef run];&#125;];[<span class="hljs-keyword">self</span>.thread start];<span class="hljs-comment">/// 这种方式获取，runloop 堆栈会对 self 会产生强引用</span><span class="hljs-comment">/// self 不可自由 dealloc，只有当 runloop 销毁时，self 才能自由释放而不管 </span><span class="hljs-comment">/// 因为 OC 的消息转发实际上会转成 C 函数的调用</span><span class="hljs-comment">/// 第一个参数会默认传递 self 到 run 函数堆栈当中， [runloop run] 会时当前函数堆栈常驻，指导 RunLoop 销毁</span></code></pre></div><h4 id="方式2-使用-initWithTarget-selector-object-来启动线程"><a href="#方式2-使用-initWithTarget-selector-object-来启动线程" class="headerlink" title="方式2: 使用 initWithTarget:selector:object: 来启动线程"></a>方式2: 使用 initWithTarget:selector:object: 来启动线程</h4><ul><li>2.1 该方式和 1.3 一样，都使用了消息发送机制<ul><li>因此 self 的生命周期也被 RunLoop 绑定</li><li>只有当 RunLoop 释放后，self 才能自由释放</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)run &#123;        <span class="hljs-built_in">NSRunLoop</span> *runloop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];    <span class="hljs-comment">// 线程保活，需要添加一个 Port </span>    [runloop addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init]                  forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];<span class="hljs-comment">// run 方法运行 runloop，并且 runloop 永远无法关闭</span>    [runloop run];&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-keyword">self</span>.thread = [[MyThread alloc] initWithTarget:_weakSelf                                          selector:<span class="hljs-keyword">@selector</span>(run)                                            object:<span class="hljs-literal">nil</span>];[<span class="hljs-keyword">self</span>.thread start];&#125;];</code></pre></div><h4 id="方式3：使用-C-语法方式启动"><a href="#方式3：使用-C-语法方式启动" class="headerlink" title="方式3：使用 C 语法方式启动"></a>方式3：使用 C 语法方式启动</h4><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">// 创建上下文（要初始化一下结构体）</span><span class="hljs-built_in">CFRunLoopSourceContext</span> context = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">// 创建source</span><span class="hljs-built_in">CFRunLoopSourceRef</span> source = <span class="hljs-built_in">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="hljs-number">0</span>, &amp;context);<span class="hljs-comment">// 往Runloop中添加source</span><span class="hljs-built_in">CFRunLoopAddSource</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>(), source, kCFRunLoopDefaultMode);<span class="hljs-comment">// 销毁source</span><span class="hljs-built_in">CFRelease</span>(source);<span class="hljs-comment">// 启动</span><span class="hljs-comment">//CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, false);</span><span class="hljs-keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;    <span class="hljs-comment">// 第3个参数：returnAfterSourceHandled，设置为true，代表执行完source后就会退出当前loop</span>    <span class="hljs-built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="hljs-number">1.0e10</span>, <span class="hljs-literal">true</span>);&#125;</code></pre></div><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>创建并启动 RunLoop 需要考虑实际的使用场景</li><li>结合场景需要关心 RunLoop 的生命周期来进行代码设计</li><li>如果是跟随整个 App 生命周期则不用太关心 RunLoop 导致的内存引用问题</li><li>以上使用 [runloop run] 启动的 runloop 是无法手动停止的。</li><li>不注意使用则会导致内存泄漏以及 runloop 泄漏。</li></ul><h3 id="RunLoop-销毁"><a href="#RunLoop-销毁" class="headerlink" title="RunLoop 销毁"></a>RunLoop 销毁</h3><p>RunLoop 的销毁有两种方式，自动销毁和手动销毁。当 RunLoop 中没有添加事件源时，RunLoop 会自动销毁退出循环。当 RunLoop 中有时间源时，我们需要手动停止当前 RunLoop ，并且启动方式需要控制 RunLoop 的循环次数。因为 <code>[runllop run]</code> 启动的 RunLoop 无法手动关闭。</p><ul><li>使用 runMode:beforeDate: 的方式启动一次 RunLoop 循环<ul><li>该方式只会处理一次 RunLoop 循环，当事件都处理完后就会退出。</li><li>手动 while(isRun) 控制它继续循环或停止</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs objc">- (<span class="hljs-type">void</span>)run &#123;    <span class="hljs-built_in">NSRunLoop</span> *runloop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<span class="hljs-comment">// 线程保活，需要添加一个 Port </span>[runloop addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init] forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];<span class="hljs-comment">// 手动控制循环</span><span class="hljs-comment">// 这里需要注意 shouldKeepRunning 为 YES 时运行，这样 self 为 nil 时，runloop 能正确停止</span><span class="hljs-comment">// 如果使用 self.isStop ，则需要判断 while (self &amp;&amp; !self.isStop) 来避免 runloop 无法停止的情况</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">self</span>.shouldKeepRunning) &#123;[runloop runMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>  beforeDate:[<span class="hljs-built_in">NSDate</span> distantFuture]];&#125;<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot; ---- END -----&quot;</span>);&#125;<span class="hljs-comment">/// 调用该方法需要跳转的 runloop 线程才能调用</span>- (<span class="hljs-type">void</span>)stop &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.thread) <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 调用线程 stop</span>[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(stopThread)              onThread:<span class="hljs-keyword">self</span>.thread           withObject:<span class="hljs-literal">nil</span>        waitUntilDone:<span class="hljs-literal">YES</span>];&#125;- (<span class="hljs-type">void</span>)stopThread &#123;<span class="hljs-comment">/// 手动控制 RunLoop 标识为 NO</span><span class="hljs-keyword">self</span>.shouldKeepRunning = <span class="hljs-literal">NO</span>;<span class="hljs-comment">/// 结束当前正在执行的 RunLoop 循环</span><span class="hljs-built_in">NSRunLoop</span> *runloop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<span class="hljs-built_in">CFRunLoopStop</span>([runloop getCFRunLoop]);<span class="hljs-comment">// 清空线程，因为 runloop 结束后，线程已经没用了。</span><span class="hljs-keyword">self</span>.thread = <span class="hljs-literal">nil</span>;&#125;<span class="hljs-comment">/// 手动关闭</span>- (<span class="hljs-type">void</span>)didClickCloseRunLoop &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.thread) <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 转到 self.thread RunLoop 所在的线程调用 stopThread</span>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(stopThread)                 onThread:<span class="hljs-keyword">self</span>.thread               withObject:<span class="hljs-literal">nil</span>            waitUntilDone:<span class="hljs-literal">NO</span>];&#125;<span class="hljs-comment">/// self 释放时关闭</span><span class="hljs-comment">/// 注意 RunLoop 对 self 的生命周期持有关系</span><span class="hljs-comment">/// 只有 RunLoop 堆栈对 self 没有持有关系的情况下才能 dealloc 里销毁 RunLoop</span><span class="hljs-comment">/// 否则需要先在其他地方手动先关闭 RunLoop</span>- (<span class="hljs-type">void</span>)dealloc &#123;<span class="hljs-comment">// 转到 self.thread RunLoop 所在的线程调用 stopThread</span><span class="hljs-comment">//    [self performSelector:@selector(stopThread)</span><span class="hljs-comment">//                 onThread:self.thread</span><span class="hljs-comment">//               withObject:nil</span><span class="hljs-comment">//            waitUntilDone:YES];</span><span class="hljs-comment">//这里 waitUntilDone: 传 YES，表示等待线程执行完成，就不会有问题</span><span class="hljs-comment">//如果传 NO 则表示不等线程执行完成，在这里可能会导致 RunLoop 坏内存访问崩溃，因为 runloop 要用 self 发送 stop 消息，这里的 self 早以释放了</span><span class="hljs-comment">//最好将这句调用抽到一个单独的方法里，防止其他地方随意调用 stop。</span>[<span class="hljs-keyword">self</span> stop];&#125;</code></pre></div><h3 id="添加-Port-到-Source1"><a href="#添加-Port-到-Source1" class="headerlink" title="添加 Port 到 Source1"></a>添加 Port 到 Source1</h3><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-built_in">NSRunLoop</span> *runloop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<span class="hljs-comment">/// runloop 没启动前需要添加一个 Port ，让 RunLoop 保活</span>[runloop addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init]         forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];</code></pre></div><h3 id="添加-Observer-到-RunLoop"><a href="#添加-Observer-到-RunLoop" class="headerlink" title="添加 Observer 到 RunLoop"></a>添加 Observer 到 RunLoop</h3><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">/// 监听 RunLoop</span><span class="hljs-built_in">CFRunLoopObserverRef</span> observer = <span class="hljs-built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault,                                                                   kCFRunLoopAllActivities,                                                                   <span class="hljs-literal">YES</span>,                                                                   <span class="hljs-number">0</span>,                                                                   ^(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer,                                                                     <span class="hljs-built_in">CFRunLoopActivity</span> activity) &#123;    <span class="hljs-comment">// 处理 RunLoop 事件</span>    <span class="hljs-keyword">switch</span> (activity) &#123;        <span class="hljs-keyword">case</span> kCFRunLoopEntry:            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopEntry&quot;</span>);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> kCFRunLoopBeforeTimers:            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopBeforeTimers&quot;</span>);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> kCFRunLoopBeforeSources:            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopBeforeSources&quot;</span>);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> kCFRunLoopBeforeWaiting:            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> kCFRunLoopAfterWaiting:            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopAfterWaiting&quot;</span>);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> kCFRunLoopExit:            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopEntry&quot;</span>);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;    &#125;&#125;);<span class="hljs-built_in">CFRunLoopAddObserver</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);<span class="hljs-built_in">CFRelease</span>(observer);</code></pre></div><h3 id="添加-NSTimer-定时器"><a href="#添加-NSTimer-定时器" class="headerlink" title="添加 NSTimer 定时器"></a>添加 NSTimer 定时器</h3><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">/// 创建 Timer，并自动添加到当前 RunLoop 的 default mode 下</span>[<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> repeats:<span class="hljs-literal">YES</span> block:^(<span class="hljs-built_in">NSTimer</span> * _Nonnull timer) &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot; timer ！！！&quot;</span>);&#125;];</code></pre></div><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">/// 创建 timer，还没有加入到 runloop</span><span class="hljs-built_in">NSTimer</span> *timer = [<span class="hljs-built_in">NSTimer</span> timerWithTimeInterval:<span class="hljs-number">3</span>                                        repeats:<span class="hljs-literal">YES</span>                                          block:^(<span class="hljs-built_in">NSTimer</span> * _Nonnull timer) &#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot; timer ！！！&quot;</span>);&#125;];<span class="hljs-comment">/// 把 timer 加入到 runloop default mode 下</span>[runloop addTimer:timer forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];</code></pre></div><h3 id="添加-Block-任务到-RunLoop"><a href="#添加-Block-任务到-RunLoop" class="headerlink" title="添加 Block 任务到 RunLoop"></a>添加 Block 任务到 RunLoop</h3><ul><li>CFRunLoopPerformBlock<ul><li>不会触发 RunLoop 唤醒</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-built_in">CFRunLoopRef</span> runLoop = <span class="hljs-built_in">CFRunLoopGetCurrent</span>();<span class="hljs-comment">/// 往 RunLoop 中添加 Block，但不会立即执行</span><span class="hljs-comment">/// 也不会触发 RunLoop 唤醒，会在 RunLoop 运行时执行。</span><span class="hljs-built_in">CFRunLoopPerformBlock</span>(runLoop, kCFRunLoopDefaultMode, ^&#123;    <span class="hljs-comment">/// Block 执行代码</span>&#125;);</code></pre></div><ul><li>performBlock<ul><li>拿到并持有线程的 RunLoop</li><li>给 RunLoop 运行一个 performBlock 代码块</li><li>会触发 RunLoop 唤醒</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-comment">/// 给 RunLoop 一个 Block 执行</span>[<span class="hljs-keyword">self</span>.runloop performBlock:^&#123;    &#125;];<span class="hljs-comment">/// 给 RunLoop default mode 下一个 Block 执行</span>[<span class="hljs-keyword">self</span>.runloop performInModes:@[<span class="hljs-built_in">NSDefaultRunLoopMode</span>] block:^&#123;        &#125;];</code></pre></div><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.dev/opensource-apple/CF">想查看 RunLoop 源码点这里</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github 非常好用功能</title>
    <link href="/2023/03/17/other/Github-%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    <url>/2023/03/17/other/Github-%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="Github-非常好用功能"><a href="#Github-非常好用功能" class="headerlink" title="Github 非常好用功能"></a>Github 非常好用功能</h2><h3 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h3><ul><li>点击搜索框直接回车键</li><li>选择高级搜索</li><li>选择语言、star 等</li></ul><hr><h3 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h3><ul><li>按键 <code>T</code> 直接搜索文件</li></ul><hr><h3 id="查看修改记录"><a href="#查看修改记录" class="headerlink" title="查看修改记录"></a>查看修改记录</h3><ul><li>选择文件后</li><li>按键 <code>B</code> 直接查看修改记录</li></ul><hr><h3 id="直接使用-VS-Code-浏览和编辑项目"><a href="#直接使用-VS-Code-浏览和编辑项目" class="headerlink" title="直接使用 VS Code 浏览和编辑项目"></a>直接使用 VS Code 浏览和编辑项目</h3><ul><li>方法1：推荐<ul><li>按钮 <code>.</code> 直接使用 VS Code 网页端打开项目</li><li>可浏览和修改提交</li></ul></li><li>方法2：<ul><li>修改 github.com 为 github1s.com</li><li>只能浏览</li></ul></li></ul><hr><h3 id="快速调试"><a href="#快速调试" class="headerlink" title="快速调试"></a>快速调试</h3><ul><li>修改 github.com 为 githubbox.com</li><li>可直接在网址上运行调试</li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C 容易被忽略的内存对齐</title>
    <link href="/2023/03/02/ios/Objective-C-%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2023/03/02/ios/Objective-C-%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Objective-C-容易被忽略的内存对齐"><a href="#Objective-C-容易被忽略的内存对齐" class="headerlink" title="Objective-C 容易被忽略的内存对齐"></a>Objective-C 容易被忽略的内存对齐</h1><h2 id="什么是结构体内存对齐"><a href="#什么是结构体内存对齐" class="headerlink" title="什么是结构体内存对齐"></a>什么是结构体内存对齐</h2><p>结构体内存对齐是指编译器在给结构体分配内存时，为了提高内存访问效率，在结构体的成员变量之间加上一些空余的字节。这些空余的字节的大小取决于编译器的对齐方式和结构体成员变量的大小。</p><p>在默认情况下，编译器会按照结构体成员变量大小的最大值来进行对齐，即按照 8 字节对齐。因此，结构体中的 int 类型变量会被对齐到 4 字节的倍数上，double 类型变量会被对齐到 8 字节的倍数上。</p><h2 id="什么情况下会导致多申请内存"><a href="#什么情况下会导致多申请内存" class="headerlink" title="什么情况下会导致多申请内存"></a>什么情况下会导致多申请内存</h2><p>短类型与长类型间隔声明会导致多申请内存，我们来看下面相同成员属性的两个不同列子</p><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><ul><li>8个字节长类型 double 前面还有没对齐的4个字节的短类型（会导致4个字节空间浪费）</li></ul><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span> </span>&#123;    <span class="hljs-keyword">@public</span>    <span class="hljs-type">int</span> _age;    <span class="hljs-type">double</span> no;  <span class="hljs-comment">/// &lt;- 长类型夹在没对齐的短类型中间</span>    <span class="hljs-type">int</span> _a;    <span class="hljs-type">int</span> _b;    <span class="hljs-type">int</span> _c;&#125;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><span class="hljs-keyword">@end</span><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;    <span class="hljs-keyword">@autoreleasepool</span> &#123;        Person *p = [[Person alloc] init];        <span class="hljs-comment">/// 获得 obj 指针指向内存的大小</span>        <span class="hljs-comment">/// (__bridge const void *) (obj )</span>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;malloc size:%zd&quot;</span>, malloc_size((__bridge <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *)(p)));        <span class="hljs-comment">/// 获取 NSObject 累的实例对象的大小</span>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;use size:%zd&quot;</span>, class_getInstanceSize([Person <span class="hljs-keyword">class</span>]));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 终端打印</span>malloc size:48use size:40</code></pre></div><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span> </span>&#123;    <span class="hljs-keyword">@public</span>    <span class="hljs-type">int</span> _age;    <span class="hljs-type">int</span> _a;    <span class="hljs-type">double</span> no;  <span class="hljs-comment">/// &lt;- 长类型夹在中间，但前面内存已经对齐</span>    <span class="hljs-type">int</span> _b;    <span class="hljs-type">int</span> _c;&#125;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><span class="hljs-keyword">@end</span><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;    <span class="hljs-keyword">@autoreleasepool</span> &#123;        Person *p = [[Person alloc] init];        <span class="hljs-comment">/// 获得 obj 指针指向内存的大小</span>        <span class="hljs-comment">/// (__bridge const void *) (obj )</span>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;malloc size:%zd&quot;</span>, malloc_size((__bridge <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *)(p)));        <span class="hljs-comment">/// 获取 NSObject 累的实例对象的大小</span>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;use size:%zd&quot;</span>, class_getInstanceSize([Person <span class="hljs-keyword">class</span>]));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment">#终端打印</span>malloc size:32use size:32</code></pre></div><ul><li>例子1: persion 对象申请占用了48 字节的内存空间，结构体内存对齐实际使用了 40 字节。</li><li>例子2：person 对象申请占用了 32  字节的内存空间，实际使用 32 字节</li><li>上面的两个例子相同的对象属性，仅因为属性声明排序的不同，而多出浪费掉 16 字节的存储空间</li><li>可以看出系统并不会自动优化对象结构体内部属性在内存中的存储顺序，而是按代码声明的顺序存储，如果不注意内存对齐，中间就会有很多的内存空隙没有被使用到，从而导致内存浪费的情况</li></ul><h2 id="养成好开发习惯"><a href="#养成好开发习惯" class="headerlink" title="养成好开发习惯"></a>养成好开发习惯</h2><ul><li>基于对系统内存对齐的认识，我们应该养成好的开发习惯</li><li>可以养成习惯的将长类型的属性声明在前面，这样就可以很好的利用好结构体内存对齐特性，避免更多的内存浪费</li></ul><p>如下：</p><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span> </span>&#123;    <span class="hljs-keyword">@public</span>    <span class="hljs-type">double</span> no;  <span class="hljs-comment">/// &lt;- 长类型放前面</span>    <span class="hljs-type">int</span> _age;    <span class="hljs-type">int</span> _a;    <span class="hljs-type">int</span> _b;    <span class="hljs-type">int</span> _c;&#125;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><span class="hljs-keyword">@end</span><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;    <span class="hljs-keyword">@autoreleasepool</span> &#123;        Person *p = [[Person alloc] init];        <span class="hljs-comment">/// 获得 obj 指针指向内存的大小</span>        <span class="hljs-comment">/// (__bridge const void *) (obj )</span>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;malloc size:%zd&quot;</span>, malloc_size((__bridge <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *)(p)));        <span class="hljs-comment">/// 获取 NSObject 累的实例对象的大小</span>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;use size:%zd&quot;</span>, class_getInstanceSize([Person <span class="hljs-keyword">class</span>]));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment">#终端打印</span>malloc size:32use size:32</code></pre></div><h2 id="OC-代码转为-C-x2F-C-代码"><a href="#OC-代码转为-C-x2F-C-代码" class="headerlink" title="OC 代码转为 C&#x2F;C++ 代码"></a>OC 代码转为 C&#x2F;C++ 代码</h2><div class="code-wrapper"><pre><code class="hljs sh">clang -rewrite-objc main.m -o main.cpp</code></pre></div><p>可以看到 Person 对象的结构体如下:</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person_IMPL</span> &#123;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">NSObject_IMPL</span> NSObject_IVARS;<span class="hljs-type">double</span> no;<span class="hljs-type">int</span> _age;<span class="hljs-type">int</span> _a;<span class="hljs-type">int</span> _b;<span class="hljs-type">int</span> _c;&#125;;</code></pre></div><h2 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h2><ul><li>最坏的情况就是长短类型交替声明</li><li>如下：查看内存可见，本来只需要 4 字节的每个 Int 型都独享了 8 个字节</li></ul><div class="code-wrapper"><pre><code class="hljs objc"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span> </span>&#123;    <span class="hljs-keyword">@public</span>    <span class="hljs-type">int</span> _age;    <span class="hljs-type">double</span> no;  <span class="hljs-comment">/// &lt;- 长类型夹中间</span>    <span class="hljs-type">int</span> _a1;    <span class="hljs-type">double</span> no1;  <span class="hljs-comment">/// &lt;- 长类型夹中间</span>    <span class="hljs-type">int</span> _a2;    <span class="hljs-type">double</span> no2;  <span class="hljs-comment">/// &lt;- 长类型夹中间</span>    <span class="hljs-type">int</span> _a3;    <span class="hljs-type">double</span> no3;  <span class="hljs-comment">/// &lt;- 长类型夹中间</span>    <span class="hljs-type">int</span> _a4;    <span class="hljs-type">double</span> no4;  <span class="hljs-comment">/// &lt;- 长类型夹中间</span>    <span class="hljs-type">int</span> _a5;    <span class="hljs-type">double</span> no5;  <span class="hljs-comment">/// &lt;- 长类型夹中间</span>    <span class="hljs-type">int</span> _a6;&#125;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><span class="hljs-keyword">@end</span><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;    <span class="hljs-keyword">@autoreleasepool</span> &#123;        Person *p = [[Person alloc] init];        p-&gt;_age = <span class="hljs-number">1</span>; p-&gt;_a1 = <span class="hljs-number">1</span>; p-&gt;_a2 = <span class="hljs-number">1</span>; p-&gt;_a3 = <span class="hljs-number">1</span>; p-&gt;_a4 = <span class="hljs-number">1</span>; p-&gt;_a5 = <span class="hljs-number">1</span>; p-&gt;_a6 = <span class="hljs-number">1</span>;        p-&gt;no = <span class="hljs-number">2</span>; p-&gt;no1 = <span class="hljs-number">2</span>; p-&gt;no2 = <span class="hljs-number">2</span>; p-&gt;no3 = <span class="hljs-number">2</span>; p-&gt;no4 = <span class="hljs-number">2</span>; p-&gt;no5 = <span class="hljs-number">2</span>;        <span class="hljs-comment">/// 获得 obj 指针指向内存的大小</span>        <span class="hljs-comment">/// (__bridge const void *) (obj )</span>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;malloc size:%zd&quot;</span>, malloc_size((__bridge <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *)(p)));        <span class="hljs-comment">/// 获取 NSObject 累的实例对象的大小</span>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;use size:%zd&quot;</span>, class_getInstanceSize([Person <span class="hljs-keyword">class</span>]));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><ul><li>内存结构</li></ul><div class="code-wrapper"><pre><code class="hljs sh">(lldb) x/15xg 0x6000029040000x600002904000: 0x011d8001000082d1 0x00000000000000010x600002904010: 0x4000000000000000 0x00000000000000010x600002904020: 0x4000000000000000 0x00000000000000010x600002904030: 0x4000000000000000 0x00000000000000010x600002904040: 0x4000000000000000 0x00000000000000010x600002904050: 0x4000000000000000 0x00000000000000010x600002904060: 0x4000000000000000 0x00000000000000010x600002904070: 0x0000beaddc3d4070</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C weak 指针源码解析</title>
    <link href="/2023/03/01/ios/Objective-C-weak-%E6%8C%87%E9%92%88%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/03/01/ios/Objective-C-weak-%E6%8C%87%E9%92%88%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="weak-指针原理"><a href="#weak-指针原理" class="headerlink" title="weak 指针原理"></a>weak 指针原理</h1><h2 id="底层管理"><a href="#底层管理" class="headerlink" title="底层管理"></a>底层管理</h2><p>Objective-C 维护 weak 指针的哈希表的源码主要在objc-weak.mm文件中。这个文件包含了 runtime 中维护弱引用表的相关代码，比如weak指针的创建、释放、读取和写入等操作。其中，弱引用表是用一个哈希表来实现的，哈希表的每个桶都是一个指向对象的指针，当对象被释放时，哈希表会自动将这个指针设置为nil。</p><ul><li>这里注释已经说明是存放在全局的 weak 引用表中。</li><li><code>weak_entry_t \*weak_entries;</code> 每个对象的 weak 引用关系</li></ul><div class="code-wrapper"><pre><code class="hljs c">** * The global weak references table. Stores object ids as keys, * and <span class="hljs-type">weak_entry_t</span> structs as their values. */<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">weak_table_t</span> &#123;</span>    <span class="hljs-type">weak_entry_t</span> *weak_entries;    <span class="hljs-type">size_t</span>    num_entries;    <span class="hljs-type">uintptr_t</span> mask;    <span class="hljs-type">uintptr_t</span> max_hash_displacement;&#125;;</code></pre></div><ul><li><code>weak_referrer_t \*referrers;</code> 存储了指向该对象的所有指针的地址</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">weak_entry_t</span> &#123;</span>    DisguisedPtr&lt;objc_object&gt; referent;    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>            <span class="hljs-type">weak_referrer_t</span> *referrers;            <span class="hljs-type">uintptr_t</span>        out_of_line_ness : <span class="hljs-number">2</span>;            <span class="hljs-type">uintptr_t</span>        num_refs : PTR_MINUS_2;            <span class="hljs-type">uintptr_t</span>        mask;            <span class="hljs-type">uintptr_t</span>        max_hash_displacement;        &#125;;        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>            <span class="hljs-comment">// out_of_line_ness field is low bits of inline_referrers[1]</span>            <span class="hljs-type">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];        &#125;;    &#125;;    <span class="hljs-type">bool</span> <span class="hljs-title function_">out_of_line</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);    &#125;    <span class="hljs-type">weak_entry_t</span>&amp; operator=(<span class="hljs-type">const</span> <span class="hljs-type">weak_entry_t</span>&amp; other) &#123;        <span class="hljs-built_in">memcpy</span>(this, &amp;other, <span class="hljs-keyword">sizeof</span>(other));        <span class="hljs-keyword">return</span> *this;    &#125;    <span class="hljs-type">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)        : referent(newReferent)    &#123;        inline_referrers[<span class="hljs-number">0</span>] = newReferrer;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;            inline_referrers[i] = nil;        &#125;    &#125;&#125;;</code></pre></div><ul><li>用对象的地址 hash 值当 key：</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __LP64__</span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ptr_hash</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> key)</span>&#123;    key ^= key &gt;&gt; <span class="hljs-number">4</span>;<span class="hljs-comment">//右移动 4 位再亦或自己</span>    key *= <span class="hljs-number">0x8a970be7488fda55</span>;<span class="hljs-comment">//乘以一个常量</span>    key ^= __builtin_bswap64(key);<span class="hljs-comment">//字节序翻转再亦或自己</span>    <span class="hljs-keyword">return</span> (<span class="hljs-type">uint32_t</span>)key;<span class="hljs-comment">//得到一个用地址 hash 的 key</span>&#125;<span class="hljs-meta">#<span class="hljs-keyword">else</span></span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ptr_hash</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> key)</span>&#123;    key ^= key &gt;&gt; <span class="hljs-number">4</span>;    key *= <span class="hljs-number">0x5052acdb</span>;    key ^= __builtin_bswap32(key);    <span class="hljs-keyword">return</span> key;&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><ul><li>对象 dealloc 时会调用 weak_clear_no_lock 方法</li><li>从全局的 weak table 中以当前对象地址 hash 为 key 取出 entry。</li><li>再遍历 entry 中的 referrers 指向该对象的所有 weak 指针地址赋值为 nil</li><li>最后从全局哈希表中移除 entry。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/** </span><span class="hljs-comment"> * Called by dealloc; nils out all weak pointers that point to the </span><span class="hljs-comment"> * provided object so that they can no longer be used.</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * @param weak_table </span><span class="hljs-comment"> * @param referent The object being deallocated. </span><span class="hljs-comment"> */</span><span class="hljs-type">void</span> <span class="hljs-title function_">weak_clear_no_lock</span><span class="hljs-params">(<span class="hljs-type">weak_table_t</span> *weak_table, id referent_id)</span> &#123;    objc_object *referent = (objc_object *)referent_id;    <span class="hljs-type">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);    <span class="hljs-keyword">if</span> (entry == nil) &#123;        <span class="hljs-comment">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span>        <span class="hljs-comment">//printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// zero out references</span>    <span class="hljs-type">weak_referrer_t</span> *referrers;    <span class="hljs-type">size_t</span> count;        <span class="hljs-keyword">if</span> (entry-&gt;out_of_line()) &#123;        referrers = entry-&gt;referrers;        count = TABLE_SIZE(entry);    &#125;     <span class="hljs-keyword">else</span> &#123;        referrers = entry-&gt;inline_referrers;        count = WEAK_INLINE_COUNT;    &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;        objc_object **referrer = referrers[i];        <span class="hljs-keyword">if</span> (referrer) &#123;            <span class="hljs-keyword">if</span> (*referrer == referent) &#123;                *referrer = nil;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*referrer) &#123;                _objc_inform(<span class="hljs-string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span>                             <span class="hljs-string">&quot;This is probably incorrect use of &quot;</span>                             <span class="hljs-string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span>                             <span class="hljs-string">&quot;Break on objc_weak_error to debug.\n&quot;</span>,                              referrer, (<span class="hljs-type">void</span>*)*referrer, (<span class="hljs-type">void</span>*)referent);                objc_weak_error();            &#125;        &#125;    &#125;        weak_entry_remove(weak_table, entry);&#125;</code></pre></div><h2 id="objc-weak-中的-C-方法"><a href="#objc-weak-中的-C-方法" class="headerlink" title="objc-weak 中的 C 方法"></a>objc-weak 中的 C 方法</h2><ul><li><code>weak_register_no_lock(weak_table_t *weak_table, id referent,                     id *referrer, WeakRegisterDeallocatingOptions deallocatingOptions)</code> : 添加一个（对象，弱指针）对到弱表。</li><li><code>weak_unregister_no_lock(weak_table_t *weak_table, id referent, id *referrer)</code> 从弱表中删除一个（对象，弱指针）对。</li><li><code>weak_is_registered_no_lock(weak_table_t *weak_table, id referent)</code> 一个对象在某处释放被 weak 引用。</li><li><code>void weak_clear_no_lock(weak_table_t *weak_table, id referent)</code> 调用对象销毁。将所有剩余的弱指针设置为 nil。</li></ul><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><ul><li><a href="https://github1s.com/apple-oss-distributions/objc4/blob/HEAD/runtime/objc-weak.h">objc-weak.h</a></li><li><a href="https://github1s.com/apple-oss-distributions/objc4/blob/HEAD/runtime/objc-weak.mm">objc-weak.mm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>160. 相交链表</title>
    <link href="/2023/03/01/leetcode/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/03/01/leetcode/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h1><p> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p> 图示两个链表在节点 c1 开始相交：</p><p> 题目数据 保证 整个链式结构中不存在环。</p><p> 注意，函数返回结果后，链表必须 保持其原始结构 。</p><p> 自定义评测：</p><p> 评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><p> intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0<br> listA - 第一个链表<br> listB - 第二个链表<br> skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数<br> skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br> 评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p><p> 示例 1：<br> 输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br> 输出：Intersected at ‘8’<br> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br> — 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。  </p><p> 示例 2：<br> 输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br> 输出：Intersected at ‘2’<br> 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br> 从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。<br> 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p> 示例 3：<br> 输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br> 输出：null<br> 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br> 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br> 这两个链表不相交，因此返回 null 。  </p><p> 提示：</p><p> listA 中节点数目为 m<br> listB 中节点数目为 n<br> 1 &lt;&#x3D; m, n &lt;&#x3D; 3 * 104<br> 1 &lt;&#x3D; Node.val &lt;&#x3D; 105<br> 0 &lt;&#x3D; skipA &lt;&#x3D; m<br> 0 &lt;&#x3D; skipB &lt;&#x3D; n<br> 如果 listA 和 listB 没有交点，intersectVal 为 0<br> 如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA] &#x3D;&#x3D; listB[skipB]  </p><p> 进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？</p><p> 来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists">https://leetcode.cn/problems/intersection-of-two-linked-lists</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>解题代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> val: <span class="hljs-type">Int</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> next: <span class="hljs-type">ListNode</span>?    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">val</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.val <span class="hljs-operator">=</span> val        <span class="hljs-keyword">self</span>.next <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>    &#125;&#125;<span class="hljs-comment">/// 扩展支持 hashable，才能在字典或Set集合中当 key 使用</span><span class="hljs-keyword">extension</span> <span class="hljs-title class_">ListNode</span> : <span class="hljs-title class_">Hashable</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">==</span>(<span class="hljs-params">lhs</span>: <span class="hljs-type">ListNode</span>, <span class="hljs-params">rhs</span>: <span class="hljs-type">ListNode</span>) -&gt; <span class="hljs-type">Bool</span> &#123;        <span class="hljs-keyword">return</span> lhs <span class="hljs-operator">===</span> rhs    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">hash</span>(<span class="hljs-params">into</span> <span class="hljs-params">hasher</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Hasher</span>) &#123;        hasher.combine(<span class="hljs-type">ObjectIdentifier</span>(<span class="hljs-keyword">self</span>).hashValue)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;        <span class="hljs-comment">/// 解题思路</span>    <span class="hljs-comment">/// 把双链问题，以环的形式看待</span>    <span class="hljs-comment">/// A 链到末尾，则跳到 B 链head位置继续</span>    <span class="hljs-comment">/// B 链到末尾，则调到 A 链head位置继续</span>    <span class="hljs-comment">/// 直到 A === B，则说明AB相交的交点为 A or B</span>    <span class="hljs-comment">/// 如果没有交点，最终他们会相交与 nil 点 最终 A === B，A == nil， B === nil</span>    <span class="hljs-comment">/// - 时间复杂度 O(N+M)</span>    <span class="hljs-comment">/// - 空间复杂度 O(1)</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">headA</span>: <span class="hljs-type">ListNode</span>?, <span class="hljs-keyword">_</span> <span class="hljs-params">headB</span>: <span class="hljs-type">ListNode</span>?) -&gt; <span class="hljs-type">ListNode</span>? &#123;    <span class="hljs-keyword">if</span> headA <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">||</span> headB <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>        &#125;        <span class="hljs-keyword">var</span> prevA <span class="hljs-operator">=</span> headA        <span class="hljs-keyword">var</span> prevB <span class="hljs-operator">=</span> headB        <span class="hljs-keyword">while</span> prevA <span class="hljs-operator">!==</span> prevB &#123;            prevA <span class="hljs-operator">=</span> prevA <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">?</span> headB : prevA<span class="hljs-operator">?</span>.next            prevB <span class="hljs-operator">=</span> prevB <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">?</span> headA : prevB<span class="hljs-operator">?</span>.next        &#125;        <span class="hljs-keyword">return</span> prevA    &#125;            <span class="hljs-comment">/// 解题思路，hashMap 方法</span>    <span class="hljs-comment">/// 先遍历链表 A，将每个节点当key存储于map中</span>    <span class="hljs-comment">/// 再遍历链表 B，如果map中存在，则返回当前节点就是第一个公共节点</span>    <span class="hljs-comment">/// 不存在，则结尾返回 nil</span>    <span class="hljs-comment">/// - 时间复杂度为 O(n+m)</span>    <span class="hljs-comment">/// - 空间复杂度为 O(n)</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">headA</span>: <span class="hljs-type">ListNode</span>?, <span class="hljs-keyword">_</span> <span class="hljs-params">headB</span>: <span class="hljs-type">ListNode</span>?) -&gt; <span class="hljs-type">ListNode</span>? &#123;        <span class="hljs-keyword">var</span> map: [<span class="hljs-type">ListNode</span>:<span class="hljs-type">ListNode</span>?] <span class="hljs-operator">=</span> [:]        <span class="hljs-keyword">var</span> prevA <span class="hljs-operator">=</span> headA        <span class="hljs-keyword">var</span> prevB <span class="hljs-operator">=</span> headB        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> prev <span class="hljs-operator">=</span> prevA &#123;            map[prev] <span class="hljs-operator">=</span> prevA            prevA <span class="hljs-operator">=</span> prevA<span class="hljs-operator">?</span>.next        &#125;        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> prev <span class="hljs-operator">=</span> prevB &#123;            <span class="hljs-keyword">if</span> map[prev] <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;                <span class="hljs-keyword">return</span> prev            &#125;            prevB <span class="hljs-operator">=</span> prevB<span class="hljs-operator">?</span>.next        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;        <span class="hljs-comment">/// 解题思路: （性能比较慢）</span>    <span class="hljs-comment">/// 遍历其中一条链表，把每个节点存入 map 。（ Swift 的 Dict 要求 key 必须实现 Hashable 协议，因此换成了数组）</span>    <span class="hljs-comment">/// 再遍历另一条链表，每个节点比较 map 中是否存在</span>    <span class="hljs-comment">/// 存在则为第一个共同节点，否则没有共同节点</span>    <span class="hljs-comment">/// - 用数组时间复杂度就会高很多，时间复杂度为 O(n*m)</span>    <span class="hljs-comment">/// - 空间复杂度为 O(n)</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getIntersectionNode11</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">headA</span>: <span class="hljs-type">ListNode</span>?, <span class="hljs-keyword">_</span> <span class="hljs-params">headB</span>: <span class="hljs-type">ListNode</span>?) -&gt; <span class="hljs-type">ListNode</span>? &#123;                <span class="hljs-keyword">var</span> quequ :[<span class="hljs-type">ListNode</span>] <span class="hljs-operator">=</span> []        <span class="hljs-keyword">var</span> prevA <span class="hljs-operator">=</span> headA        <span class="hljs-keyword">while</span> prevA <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;            quequ.append(prevA<span class="hljs-operator">!</span>)            prevA <span class="hljs-operator">=</span> prevA<span class="hljs-operator">?</span>.next        &#125;        <span class="hljs-keyword">var</span> prevB <span class="hljs-operator">=</span> headB        <span class="hljs-keyword">while</span> prevB <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">if</span> quequ.contains(where: &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">===</span> prevB &#125;) &#123;                <span class="hljs-keyword">return</span> prevB            &#125;            prevB <span class="hljs-operator">=</span> prevB<span class="hljs-operator">?</span>.next        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>104. 二叉树的最大深度</title>
    <link href="/2023/03/01/leetcode/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/2023/03/01/leetcode/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h1><p>给定一个二叉树，找出其最大深度。</p><p> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p> 说明: 叶子节点是指没有子节点的节点。</p><p> 示例：<br> 给定二叉树 [3,9,20,null,null,15,7]，</p><div class="code-wrapper"><pre><code class="hljs">    3   / \  9  20    /  \   15   7</code></pre></div><p> 返回它的最大深度 3 。</p><p> 来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">https://leetcode.cn/problems/maximum-depth-of-binary-tree</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>解题代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Soluton</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> val: <span class="hljs-type">Int</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> left: <span class="hljs-type">TreeNode</span>?        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> right: <span class="hljs-type">TreeNode</span>?        <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>() &#123; <span class="hljs-keyword">self</span>.val <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-keyword">self</span>.left <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>; <span class="hljs-keyword">self</span>.right <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>; &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">val</span>: <span class="hljs-type">Int</span>) &#123; <span class="hljs-keyword">self</span>.val <span class="hljs-operator">=</span> val; <span class="hljs-keyword">self</span>.left <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>; <span class="hljs-keyword">self</span>.right <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>; &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">val</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">left</span>: <span class="hljs-type">TreeNode</span>?, <span class="hljs-keyword">_</span> <span class="hljs-params">right</span>: <span class="hljs-type">TreeNode</span>?) &#123;            <span class="hljs-keyword">self</span>.val <span class="hljs-operator">=</span> val            <span class="hljs-keyword">self</span>.left <span class="hljs-operator">=</span> left            <span class="hljs-keyword">self</span>.right <span class="hljs-operator">=</span> right        &#125;    &#125;        <span class="hljs-comment">/// 解题思路：广度优先搜索 BFS（Breadth First Search）</span>    <span class="hljs-comment">/// - 时间复杂度为 O(n)</span>    <span class="hljs-comment">/// - 空间复杂度为 O(w)，其中 W为二叉树的最大宽度，即某一层节点数的最大值</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">root</span>: <span class="hljs-type">TreeNode</span>?) -&gt; <span class="hljs-type">Int</span> &#123;        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> root <span class="hljs-operator">=</span> root <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;        <span class="hljs-keyword">var</span> queue <span class="hljs-operator">=</span> [root]        <span class="hljs-keyword">var</span> depth <span class="hljs-operator">=</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> <span class="hljs-operator">!</span>queue.isEmpty &#123;            depth <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>            <span class="hljs-keyword">let</span> size <span class="hljs-operator">=</span> queue.count            <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>size &#123;                <span class="hljs-keyword">let</span> node <span class="hljs-operator">=</span> queue.remove(at: <span class="hljs-number">0</span>)                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> left <span class="hljs-operator">=</span> node.left &#123;                    queue.append(left)                &#125;                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> right <span class="hljs-operator">=</span> node.right &#123;                    queue.append(right)                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> depth    &#125;        <span class="hljs-comment">/// 解题思路:   深度优先搜索 DFS (Depth First Search)</span>    <span class="hljs-comment">/// 使用递归求解，取左树和右数深度的最大值加上当前层 1</span>    <span class="hljs-comment">/// node 为空则 return 0</span>    <span class="hljs-comment">/// - 时间复杂度 O(n)，n为二叉树的节点数</span>    <span class="hljs-comment">/// - 空间复杂度 O(height), height 表示二叉树的高度，递归函数需要栈空间。</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">maxDepth2</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">root</span>: <span class="hljs-type">TreeNode</span>?) -&gt; <span class="hljs-type">Int</span> &#123;        <span class="hljs-keyword">if</span> root <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxDepth(root<span class="hljs-operator">?</span>.left), maxDepth(root<span class="hljs-operator">?</span>.right)) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>    &#125;        <span class="hljs-comment">/// 数组转树</span>    <span class="hljs-comment">/// 特点是，左节点永远指向 2*i + 1， 有节点指向 2*i+2</span>    <span class="hljs-comment">/// 遍历完数组就可以生成树</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createTreeWith</span>(<span class="hljs-params">array</span>: [<span class="hljs-type">Int</span>?]) -&gt; <span class="hljs-type">TreeNode</span>? &#123;        <span class="hljs-keyword">if</span> array.first <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>        &#125;        <span class="hljs-keyword">let</span> nodes <span class="hljs-operator">=</span> array.map &#123; n <span class="hljs-keyword">in</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> num <span class="hljs-operator">=</span> n &#123;                <span class="hljs-keyword">return</span> <span class="hljs-type">Optional</span>(<span class="hljs-type">TreeNode</span>(num))            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>            &#125;        &#125;                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>nodes.count &#123;            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> node <span class="hljs-operator">=</span> nodes[i] &#123;                <span class="hljs-keyword">let</span> leftIndex <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span>i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>                <span class="hljs-keyword">let</span> rightIndex <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span>i <span class="hljs-operator">+</span> <span class="hljs-number">2</span>                <span class="hljs-keyword">if</span> leftIndex <span class="hljs-operator">&lt;</span> nodes.count &#123;                    node.left <span class="hljs-operator">=</span> nodes[leftIndex]                &#125;                <span class="hljs-keyword">if</span> rightIndex <span class="hljs-operator">&lt;</span> nodes.count &#123;                    node.right <span class="hljs-operator">=</span> nodes[rightIndex]                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> nodes[<span class="hljs-number">0</span>]    &#125;&#125;</code></pre></div><p>测试用例：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnitTestting</span>: <span class="hljs-title class_">XCTestCase</span> &#123;<span class="hljs-comment">/// 104. 二叉树的最大深度</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">testSolution</span>() &#123;<span class="hljs-keyword">let</span> solution <span class="hljs-operator">=</span> <span class="hljs-type">Solution_104</span>()                <span class="hljs-keyword">do</span> &#123;            <span class="hljs-keyword">let</span> nums <span class="hljs-operator">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">nil</span>,<span class="hljs-literal">nil</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]            <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-number">3</span>            <span class="hljs-keyword">let</span> root <span class="hljs-operator">=</span> solution.createTreeWith(array: nums)            <span class="hljs-type">XCTAssert</span>(result <span class="hljs-operator">==</span> solution.maxDepth(root))        &#125;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>141. 环形链表</title>
    <link href="/2023/03/01/leetcode/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/03/01/leetcode/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p> 如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p> 示例 1：</p><p> 输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br> 输出：true<br> 解释：链表中有一个环，其尾部连接到第二个节点。<br> 示例 2：</p><p> 输入：head &#x3D; [1,2], pos &#x3D; 0<br> 输出：true<br> 解释：链表中有一个环，其尾部连接到第一个节点。<br> 示例 3：</p><p> 输入：head &#x3D; [1], pos &#x3D; -1<br> 输出：false<br> 解释：链表中没有环。  </p><p> 提示：</p><p> 链表中节点的数目范围是 [0, 104]<br> -105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br> pos 为 -1 或者链表中的一个 有效索引 。  </p><p> 进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p><p> 来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode.cn/problems/linked-list-cycle">https://leetcode.cn/problems/linked-list-cycle</a><br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> <div class="code-wrapper"><pre><code class="hljs swift"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> val: <span class="hljs-type">Int</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> next: <span class="hljs-type">ListNode</span>?        <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">val</span>: <span class="hljs-type">Int</span>) &#123;            <span class="hljs-keyword">self</span>.val <span class="hljs-operator">=</span> val            <span class="hljs-keyword">self</span>.next <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>        &#125;    &#125;        <span class="hljs-comment">/// 解题思路：快慢指针</span>    <span class="hljs-comment">/// 双指针相遇则说明有环</span>    <span class="hljs-comment">/// 时间复杂度 O(n)</span>    <span class="hljs-comment">/// 空间复杂度 O(1)</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">head</span>: <span class="hljs-type">ListNode</span>?) -&gt; <span class="hljs-type">Bool</span> &#123;        <span class="hljs-keyword">if</span> head <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        <span class="hljs-keyword">var</span> man <span class="hljs-operator">=</span> head        <span class="hljs-keyword">var</span> kuai <span class="hljs-operator">=</span> head<span class="hljs-operator">?</span>.next                <span class="hljs-keyword">while</span> man <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">&amp;&amp;</span> kuai <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">if</span> man <span class="hljs-operator">===</span> kuai &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>            &#125;            man <span class="hljs-operator">=</span> man<span class="hljs-operator">?</span>.next            kuai <span class="hljs-operator">=</span> kuai<span class="hljs-operator">?</span>.next<span class="hljs-operator">?</span>.next        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;            <span class="hljs-comment">/// 创建链表</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildListWith</span>(<span class="hljs-params">nums</span>: [<span class="hljs-type">Int</span>], <span class="hljs-params">pos</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">ListNode</span>? &#123;        <span class="hljs-keyword">if</span> nums.isEmpty &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>        &#125;        <span class="hljs-keyword">let</span> head: <span class="hljs-type">ListNode</span>? <span class="hljs-operator">=</span> <span class="hljs-type">ListNode</span>(<span class="hljs-number">0</span>)        <span class="hljs-keyword">var</span> prev: <span class="hljs-type">ListNode</span>? <span class="hljs-operator">=</span> head        <span class="hljs-keyword">var</span> posNode: <span class="hljs-type">ListNode</span>?        <span class="hljs-keyword">var</span> buildCount <span class="hljs-operator">=</span> <span class="hljs-number">0</span>                <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums &#123;            prev<span class="hljs-operator">?</span>.next <span class="hljs-operator">=</span> <span class="hljs-type">ListNode</span>(num)            <span class="hljs-keyword">if</span> buildCount <span class="hljs-operator">==</span> pos &#123;                posNode <span class="hljs-operator">=</span> prev<span class="hljs-operator">?</span>.next            &#125;            prev <span class="hljs-operator">=</span> prev<span class="hljs-operator">?</span>.next            buildCount <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>        &#125;        prev<span class="hljs-operator">?</span>.next <span class="hljs-operator">=</span> posNode        <span class="hljs-keyword">return</span> head<span class="hljs-operator">?</span>.next    &#125;&#125;</code></pre></div><p> 测试用例</p> <div class="code-wrapper"><pre><code class="hljs swift"> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleTestting</span>: <span class="hljs-title class_">XCTestCase</span> &#123;        <span class="hljs-comment">/// 141. 环形链表</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">testSolution_141</span>() &#123;        <span class="hljs-keyword">let</span> solution <span class="hljs-operator">=</span> <span class="hljs-type">Solution_141</span>()                <span class="hljs-keyword">do</span> &#123;            <span class="hljs-keyword">let</span> head <span class="hljs-operator">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-operator">-</span><span class="hljs-number">4</span>], pos <span class="hljs-operator">=</span> <span class="hljs-number">1</span>            <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>            <span class="hljs-keyword">let</span> res <span class="hljs-operator">=</span> solution.hasCycle(solution.buildListWith(nums: head, pos: pos))            <span class="hljs-type">XCTAssert</span>(result <span class="hljs-operator">==</span> res)        &#125;        <span class="hljs-comment">///...</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表 (Singly Linked List)</title>
    <link href="/2023/02/28/other/%E5%8D%95%E9%93%BE%E8%A1%A8-Singly-Linked-List/"/>
    <url>/2023/02/28/other/%E5%8D%95%E9%93%BE%E8%A1%A8-Singly-Linked-List/</url>
    
    <content type="html"><![CDATA[<h1 id="单链表-Singly-Linked-List"><a href="#单链表-Singly-Linked-List" class="headerlink" title="单链表 (Singly Linked List)"></a>单链表 (Singly Linked List)</h1><p>单链表（Singly Linked List），是数据结构中最基础的一种链表结构，它由一个节点和一个指向下一个节点的指针组成。每个节点都包含了数据和指向下一个节点的指针。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;    <span class="hljs-keyword">var</span> val: <span class="hljs-type">Int</span>    <span class="hljs-keyword">var</span> next: <span class="hljs-type">ListNode</span>?    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">val</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.val <span class="hljs-operator">=</span> val        <span class="hljs-keyword">self</span>.next <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>    &#125;&#125;</code></pre></div><h2 id="1-单链表排序"><a href="#1-单链表排序" class="headerlink" title="1. 单链表排序"></a>1. <strong>单链表排序</strong></h2><p>将该链表中的值按升序排列并返回排好序的链表。时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">sortList</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">head</span>: <span class="hljs-type">ListNode</span>?) -&gt; <span class="hljs-type">ListNode</span>? &#123;    <span class="hljs-comment">// 如果链表为空或只有一个节点，则已经排好序</span>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> head <span class="hljs-operator">=</span> head, head.next <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> head    &#125;    <span class="hljs-comment">// 使用快慢指针法将链表分为两个子链表</span>    <span class="hljs-keyword">var</span> slow <span class="hljs-operator">=</span> head    <span class="hljs-keyword">var</span> fast <span class="hljs-operator">=</span> head.next    <span class="hljs-keyword">while</span> fast <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">&amp;&amp;</span> fast<span class="hljs-operator">?</span>.next <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;        slow <span class="hljs-operator">=</span> slow.next<span class="hljs-operator">!</span>        fast <span class="hljs-operator">=</span> fast<span class="hljs-operator">?</span>.next<span class="hljs-operator">?</span>.next    &#125;    <span class="hljs-keyword">let</span> secondHalf <span class="hljs-operator">=</span> slow.next    slow.next <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>    <span class="hljs-comment">// 递归排序两个子链表</span>    <span class="hljs-keyword">let</span> left <span class="hljs-operator">=</span> sortList(head)    <span class="hljs-keyword">let</span> right <span class="hljs-operator">=</span> sortList(secondHalf)    <span class="hljs-comment">// 合并两个排好序的子链表</span>    <span class="hljs-keyword">return</span> merge(left, right)&#125;<span class="hljs-keyword">func</span> <span class="hljs-title function_">merge</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">l1</span>: <span class="hljs-type">ListNode</span>?, <span class="hljs-keyword">_</span> <span class="hljs-params">l2</span>: <span class="hljs-type">ListNode</span>?) -&gt; <span class="hljs-type">ListNode</span>? &#123;    <span class="hljs-keyword">if</span> l1 <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> l2    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2 <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> l1    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l1<span class="hljs-operator">!</span>.val <span class="hljs-operator">&lt;</span> l2<span class="hljs-operator">!</span>.val &#123;        l1<span class="hljs-operator">!</span>.next <span class="hljs-operator">=</span> merge(l1<span class="hljs-operator">!</span>.next, l2)        <span class="hljs-keyword">return</span> l1    &#125; <span class="hljs-keyword">else</span> &#123;        l2<span class="hljs-operator">!</span>.next <span class="hljs-operator">=</span> merge(l1, l2<span class="hljs-operator">!</span>.next)        <span class="hljs-keyword">return</span> l2    &#125;&#125;</code></pre></div><p>以上是一个使用归并排序的算法，时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p><h2 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2. 反转链表"></a>2. <strong>反转链表</strong></h2><p>将一个单链表反转，即头结点变成尾节点，尾节点变成头结点。可以使用迭代或递归的方法实现，时间复杂度均为O(n)。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">head</span>: <span class="hljs-type">ListNode</span>?) -&gt; <span class="hljs-type">ListNode</span>? &#123;    <span class="hljs-keyword">var</span> prev: <span class="hljs-type">ListNode</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>    <span class="hljs-keyword">var</span> curr <span class="hljs-operator">=</span> head    <span class="hljs-keyword">while</span> curr <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">let</span> next <span class="hljs-operator">=</span> curr<span class="hljs-operator">?</span>.next        curr<span class="hljs-operator">?</span>.next <span class="hljs-operator">=</span> prev        prev <span class="hljs-operator">=</span> curr        curr <span class="hljs-operator">=</span> next    &#125;    <span class="hljs-keyword">return</span> prev&#125;</code></pre></div><p>以上是一个使用迭代的实现方法。时间复杂度为O(n)，空间复杂度为O(1)。</p><h2 id="3-删除链表中的节点"><a href="#3-删除链表中的节点" class="headerlink" title="3. 删除链表中的节点"></a>3. <strong>删除链表中的节点</strong></h2><p>给定一个单链表中的某个节点（不是尾节点），删除该节点。可以通过将该节点的值更新为其下一个节点的值，然后删除其下一个节点来实现，时间复杂度为O(1)。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">node</span>: <span class="hljs-type">ListNode</span>?) &#123;    <span class="hljs-comment">// 将要删除的节点的值更新为其下一个节点的值</span>    <span class="hljs-comment">// 然后删除其下一个节点</span>    node<span class="hljs-operator">?</span>.val <span class="hljs-operator">=</span> node<span class="hljs-operator">?</span>.next<span class="hljs-operator">?</span>.val <span class="hljs-operator">??</span> <span class="hljs-number">0</span>    node<span class="hljs-operator">?</span>.next <span class="hljs-operator">=</span> node<span class="hljs-operator">?</span>.next<span class="hljs-operator">?</span>.next&#125;</code></pre></div><p>以上是一个使用Swift5实现的删除链表中的节点的函数。它的时间复杂度为O(1)。</p><h2 id="4-链表中环的检测"><a href="#4-链表中环的检测" class="headerlink" title="4. 链表中环的检测"></a>4. <strong>链表中环的检测</strong></h2><p>给定一个单链表，判断链表中是否有环。可以使用快慢指针法实现，时间复杂度为O(n)。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">head</span>: <span class="hljs-type">ListNode</span>?) -&gt; <span class="hljs-type">Bool</span> &#123;    <span class="hljs-keyword">var</span> slow <span class="hljs-operator">=</span> head    <span class="hljs-keyword">var</span> fast <span class="hljs-operator">=</span> head<span class="hljs-operator">?</span>.next    <span class="hljs-keyword">while</span> fast <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-operator">&amp;&amp;</span> fast<span class="hljs-operator">?</span>.next <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">if</span> slow <span class="hljs-operator">===</span> fast &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;        slow <span class="hljs-operator">=</span> slow<span class="hljs-operator">?</span>.next        fast <span class="hljs-operator">=</span> fast<span class="hljs-operator">?</span>.next<span class="hljs-operator">?</span>.next    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></div><p>以上是一个使用快慢指针法实现的链表中环的检测函数。时间复杂度为O(n)，空间复杂度为O(1)。</p><h2 id="5-合并两个有序链表"><a href="#5-合并两个有序链表" class="headerlink" title="5. 合并两个有序链表"></a>5. <strong>合并两个有序链表</strong></h2><p>给定两个有序的单链表，将它们合并为一个有序的单链表。可以使用迭代或递归的方法实现，时间复杂度均为O(n)。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">l1</span>: <span class="hljs-type">ListNode</span>?, <span class="hljs-keyword">_</span> <span class="hljs-params">l2</span>: <span class="hljs-type">ListNode</span>?) -&gt; <span class="hljs-type">ListNode</span>? &#123;    <span class="hljs-keyword">if</span> l1 <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> l2    &#125;    <span class="hljs-keyword">if</span> l2 <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> l1    &#125;    <span class="hljs-keyword">if</span> l1<span class="hljs-operator">!</span>.val <span class="hljs-operator">&lt;</span> l2<span class="hljs-operator">!</span>.val &#123;        l1<span class="hljs-operator">!</span>.next <span class="hljs-operator">=</span> mergeTwoLists(l1<span class="hljs-operator">!</span>.next, l2)        <span class="hljs-keyword">return</span> l1    &#125; <span class="hljs-keyword">else</span> &#123;        l2<span class="hljs-operator">!</span>.next <span class="hljs-operator">=</span> mergeTwoLists(l1, l2<span class="hljs-operator">!</span>.next)        <span class="hljs-keyword">return</span> l2    &#125;&#125;</code></pre></div><p>以上代码使用递归来实现合并两个有序链表的操作，时间复杂度为O(m+n)，其中m和n分别为两个链表的长度。空间复杂度为O(m+n)。</p><h2 id="6-删除链表的倒数第N个节点"><a href="#6-删除链表的倒数第N个节点" class="headerlink" title="6. 删除链表的倒数第N个节点"></a>6. <strong>删除链表的倒数第N个节点</strong></h2><p>给定一个单链表和一个整数n，删除该链表倒数第n个节点。可以使用快慢指针法实现，时间复杂度为O(n)。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">head</span>: <span class="hljs-type">ListNode</span>?, <span class="hljs-keyword">_</span> <span class="hljs-params">n</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">ListNode</span>? &#123;    <span class="hljs-keyword">var</span> dummy <span class="hljs-operator">=</span> <span class="hljs-type">ListNode</span>(<span class="hljs-number">0</span>)    dummy.next <span class="hljs-operator">=</span> head    <span class="hljs-keyword">var</span> slow: <span class="hljs-type">ListNode</span>? <span class="hljs-operator">=</span> dummy    <span class="hljs-keyword">var</span> fast: <span class="hljs-type">ListNode</span>? <span class="hljs-operator">=</span> dummy    <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>n &#123;        fast <span class="hljs-operator">=</span> fast<span class="hljs-operator">?</span>.next    &#125;    <span class="hljs-keyword">while</span> fast<span class="hljs-operator">?</span>.next <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;        slow <span class="hljs-operator">=</span> slow<span class="hljs-operator">?</span>.next        fast <span class="hljs-operator">=</span> fast<span class="hljs-operator">?</span>.next    &#125;    slow<span class="hljs-operator">?</span>.next <span class="hljs-operator">=</span> slow<span class="hljs-operator">?</span>.next<span class="hljs-operator">?</span>.next    <span class="hljs-keyword">return</span> dummy.next&#125;</code></pre></div><p>以上算法使用快慢指针法实现，时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Protobuf 高效的数据压缩编码方式</title>
    <link href="/2023/02/28/other/Protobuf-%E9%AB%98%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/02/28/other/Protobuf-%E9%AB%98%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Protobuf-高效的数据压缩编码方式"><a href="#Protobuf-高效的数据压缩编码方式" class="headerlink" title="Protobuf 高效的数据压缩编码方式"></a>Protobuf 高效的数据压缩编码方式</h1><ul><li><a href="https://halfrost.com/protobuf_encode/">原文地址</a></li></ul><h2 id="一-protocol-buffers-是什么？"><a href="#一-protocol-buffers-是什么？" class="headerlink" title="一. protocol buffers 是什么？"></a>一. protocol buffers 是什么？</h2><p>Protocol buffers 是一种语言中立，平台无关，可扩展的序列化数据的格式，可用于通信协议，数据存储等。</p><p>Protocol buffers 在序列化数据方面，它是灵活的，高效的。相比于 XML 来说，Protocol buffers 更加小巧，更加快速，更加简单。一旦定义了要处理的数据的数据结构之后，就可以利用 Protocol buffers 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</p><p><strong>Protocol buffers 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式</strong>。</p><h2 id="二-为什么要发明-protocol-buffers-？"><a href="#二-为什么要发明-protocol-buffers-？" class="headerlink" title="二. 为什么要发明 protocol buffers ？"></a>二. 为什么要发明 protocol buffers ？</h2><p>大家可能会觉得 Google 发明 protocol buffers 是为了解决序列化速度的，其实真实的原因并不是这样的。</p><p>protocol buffers 最先开始是 google 用来解决索引服务器 request&#x2F;response 协议的。没有 protocol buffers 之前，google 已经存在了一种 request&#x2F;response 格式，用于手动处理 request&#x2F;response 的编组和反编组。它也能支持多版本协议，不过代码比较丑陋：</p><p>C</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (version == <span class="hljs-number">3</span>) &#123;  ...&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (version &gt; <span class="hljs-number">4</span>) &#123;  <span class="hljs-keyword">if</span> (version == <span class="hljs-number">5</span>) &#123;    ...  &#125;  ...&#125;</code></pre></div><p>如果非常明确的格式化协议，会使新协议变得非常复杂。因为开发人员必须确保请求发起者与处理请求的实际服务器之间的所有服务器都能理解新协议，然后才能切换开关以开始使用新协议。</p><p>这也就是每个服务器开发人员都遇到过的低版本兼容、新旧协议兼容相关的问题。</p><p>protocol buffers 为了解决这些问题，于是就诞生了。protocol buffers 被寄予一下 2 个特点：</p><ul><li>可以很容易地引入新的字段，并且不需要检查数据的中间服务器可以简单地解析并传递数据，而无需了解所有字段。</li><li>数据格式更加具有自我描述性，可以用各种语言来处理(C++, Java 等各种语言)</li></ul><p>这个版本的 protocol buffers 仍需要自己手写解析的代码。</p><p>不过随着系统慢慢发展，演进，protocol buffers 目前具有了更多的特性：</p><ul><li>自动生成的序列化和反序列化代码避免了手动解析的需要。（官方提供自动生成代码工具，各个语言平台的基本都有）</li><li>除了用于 RPC（远程过程调用）请求之外，人们开始将 protocol buffers 用作持久存储数据的便捷自描述格式（例如，在Bigtable中）。</li><li>服务器的 RPC 接口可以先声明为协议的一部分，然后用 protocol compiler 生成基类，用户可以使用服务器接口的实际实现来覆盖它们。</li></ul><p>protocol buffers 现在是 Google 用于数据的通用语言。在撰写本文时，谷歌代码树中定义了 48162 种不同的消息类型，包括 12183 个 .proto 文件。它们既用于 RPC 系统，也用于在各种存储系统中持久存储数据。</p><p>小结：</p><p><strong>protocol buffers 诞生之初是为了解决服务器端新旧协议(高低版本)兼容性问题，名字也很体贴，“协议缓冲区”。只不过后期慢慢发展成用于传输数据</strong>。</p><blockquote><p>Protocol Buffers 命名由来：</p><p>Why the name “Protocol Buffers”? The name originates from the early days of the format, before we had the protocol buffer compiler to generate classes for us. At the time, there was a class called ProtocolBuffer which actually acted as a buffer for an individual method. Users would add tag&#x2F;value pairs to this buffer individually by calling methods like AddValue(tag, value). The raw bytes were stored in a buffer which could then be written out once the message had been constructed.</p><p>Since that time, the “buffers” part of the name has lost its meaning, but it is still the name we use. Today, people usually use the term “protocol message” to refer to a message in an abstract sense, “protocol buffer” to refer to a serialized copy of a message, and “protocol message object” to refer to an in-memory object representing the parsed message.</p><p>这个名字起源于 format 早期，在我们有 protocol buffer 编译器为我们生成类之前。当时，有一个名为 ProtocolBuffer 的类，它实际上充当了单个方法的缓冲区。用户可以通过调用像 AddValue(tag,value) 这样的方法分别将标签&#x2F;值对添加到此缓冲区。原始字节存储在一个缓冲区中，一旦构建消息就可以将其写出。</p><p>从那时起，名为“缓冲”的部分已经失去了意义，但它仍然是我们使用的名称。今天，人们通常使用术语“protocol message”来指代抽象意义上的消息，“protocol buffer”指的是消息的序列化副本，而“protocol message object”指的是代表内存中对象解析的消息。</p></blockquote><h2 id="三-proto3-定义-message"><a href="#三-proto3-定义-message" class="headerlink" title="三. proto3 定义 message"></a>三. proto3 定义 message</h2><p>目前 protocol buffers 最新版本是 proto3，与老的版本 proto2 还是有些区别的。这两个版本的 API 不完全兼容。</p><blockquote><p>proto2 和 proto3 的名字看起来有点扑朔迷离，那是因为当我们最初开源的 protocol buffers 时，它实际上是 Google 的第二个版本了，所以被称为 proto2，这也是我们的开源版本号从 v2 开始的原因。初始版名为 proto1，从 2001 年初开始在谷歌开发的。</p></blockquote><p>在 proto 中，所有结构化的数据都被称为 message。</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">helloworld</span>&#123;   <span class="hljs-keyword">required</span> <span class="hljs-type">int32</span>     id = <span class="hljs-number">1</span>;  <span class="hljs-comment">// ID</span>   <span class="hljs-keyword">required</span> <span class="hljs-type">string</span>    str = <span class="hljs-number">2</span>;  <span class="hljs-comment">// str</span>   <span class="hljs-keyword">optional</span> <span class="hljs-type">int32</span>     opt = <span class="hljs-number">3</span>;  <span class="hljs-comment">//optional field</span>&#125;</code></pre></div><p>上面这几行语句，定义了一个消息 helloworld，该消息有三个成员，类型为 int32 的 id，另一个为类型为 string 的成员 str。opt 是一个可选的成员，即消息中可以不包含该成员。</p><p>接下来说明一些 proto3 中需要注意的地方。</p><div class="code-wrapper"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;  <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;  <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;  <span class="hljs-type">int32</span> result_per_page = <span class="hljs-number">3</span>;&#125;</code></pre></div><p>如果开头第一行不声明 <code>syntax = &quot;proto3&quot;;</code>，则默认使用 proto2 进行解析。</p><h3 id="1-分配字段编号"><a href="#1-分配字段编号" class="headerlink" title="1. 分配字段编号"></a>1. 分配字段编号</h3><p>每个消息定义中的每个字段都有<strong>唯一的编号</strong>。这些字段编号用于标识消息二进制格式中的字段，并且在使用消息类型后不应更改。请注意，范围 1 到 15 中的字段编号需要一个字节进行编码，包括字段编号和字段类型（具体原因见 <a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/Protocol-buffers-encode.md#%E5%85%AD-protocol-buffer-%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86">Protocol Buffer 编码原理</a> 这一章节）。范围 16 至 2047 中的字段编号需要两个字节。所以你应该保留数字 1 到 15 作为非常频繁出现的消息元素。请记住为将来可能添加的频繁出现的元素留出一些空间。</p><p>可以指定的最小字段编号为1，最大字段编号为2^29^-1 或 536,870,911。也不能使用数字 19000 到 19999（FieldDescriptor :: kFirstReservedNumber 到 FieldDescriptor :: kLastReservedNumber），因为它们是为 Protocol Buffers实现保留的。</p><p>如果在 .proto 中使用这些保留数字中的一个，Protocol Buffers 编译的时候会报错。</p><p>同样，您不能使用任何以前 Protocol Buffers 保留的一些字段号码。保留字段是什么，下一节详细说明。</p><h3 id="2-保留字段"><a href="#2-保留字段" class="headerlink" title="2. 保留字段"></a>2. 保留字段</h3><p>如果您通过完全删除某个字段或将其注释掉来更新消息类型，那么未来的用户可以在对该类型进行自己的更新时重新使用该字段号。如果稍后加载到了的旧版本 <code>.proto</code> 文件，则会导致服务器出现严重问题，例如数据混乱，隐私错误等等。确保这种情况不会发生的一种方法是指定删除字段的字段编号（或名称，这也可能会导致 JSON 序列化问题）为 <code>reserved</code>。如果将来的任何用户试图使用这些字段标识符，Protocol Buffers 编译器将会报错。</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Foo</span> &#123;  reserved <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span> to <span class="hljs-number">11</span>;  reserved <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>;&#125;</code></pre></div><p><strong>注意，不能在同一个 <code>reserved</code> 语句中混合字段名称和字段编号</strong>。如有需要需要像上面这个例子这样写。</p><h3 id="3-默认字段规则"><a href="#3-默认字段规则" class="headerlink" title="3. 默认字段规则"></a>3. 默认字段规则</h3><ul><li>字段名不能重复，必须唯一。</li><li>repeated 字段：可以在一个 message 中重复任何数字多次(包括 0 )，不过这些重复值的顺序被保留。</li></ul><p>在 proto3 中，纯数字类型的 repeated 字段编码时候默认采用 packed 编码（具体原因见 <a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/Protocol-buffers-encode.md#%E5%85%AD-protocol-buffer-%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86">Protocol Buffer 编码原理</a> 这一章节）</p><h3 id="4-各个语言标量类型对应关系"><a href="#4-各个语言标量类型对应关系" class="headerlink" title="4. 各个语言标量类型对应关系"></a>4. 各个语言标量类型对应关系</h3><p>标注：</p><ul><li>[1] 在 Java 中，无符号的 32 位和 64 位整数使用对应带符号的表示方法，最高位存储符号位。</li><li>[2] 在所有情况下，给一个字段设置一个值的时候都会执行类型检查以确保其有效。</li><li>[3] 64 位或无符号 32 位整数在解码时始终表示为 long，但是如果在设置字段的时候设置了 int，则可以为 int。 在所有情况下，该值都必须符合设置时表示的类型。参见[2]。</li><li>[4] Python 字符串在解码时表示为 unicode，但如果给出了 ASCII 字符串，则可以为 str（此字符串可能会发生变化）。</li><li>[5] 在 64 位计算机上使用 Integer，在 32 位计算机上使用 string。</li></ul><h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5. 枚举"></a>5. 枚举</h3><p>在 message 中可以嵌入枚举类型。</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;  <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;  <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;  <span class="hljs-type">int32</span> result_per_page = <span class="hljs-number">3</span>;  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Corpus</span> &#123;    UNIVERSAL = <span class="hljs-number">0</span>;    WEB = <span class="hljs-number">1</span>;    IMAGES = <span class="hljs-number">2</span>;    LOCAL = <span class="hljs-number">3</span>;    NEWS = <span class="hljs-number">4</span>;    PRODUCTS = <span class="hljs-number">5</span>;    VIDEO = <span class="hljs-number">6</span>;  &#125;  Corpus corpus = <span class="hljs-number">4</span>;&#125;</code></pre></div><p>枚举类型需要注意的是，一定要有 0 值。</p><ul><li>枚举为 0 的是作为零值，当不赋值的时候，就会是零值。</li><li>为了和 proto2 兼容。在 proto2 中，零值必须是第一个值。</li></ul><p>另外在反序列化的过程中，无法被识别的枚举值，将会被保留在 messaage 中。因为消息反序列化时如何表示是依赖于语言的。在支持指定符号范围之外的值的开放枚举类型的语言中，例如 C++ 和 Go，未知的枚举值只是存储为其基础整数表示。在诸如 Java 之类的封闭枚举类型的语言中，枚举值会被用来标识未识别的值，并且特殊的访问器可以访问到底层整数。</p><p>在其他情况下，如果消息被序列化，则无法识别的值仍将与消息一起序列化。</p><h3 id="5-枚举中的保留值"><a href="#5-枚举中的保留值" class="headerlink" title="5. 枚举中的保留值"></a>5. 枚举中的保留值</h3><p>如果您通过完全删除枚举条目或将其注释掉来更新枚举类型，未来的用户可以在对该类型进行自己的更新时重新使用数值。如果稍后加载到了的旧版本 <code>.proto</code> 文件，则会导致服务器出现严重问题，例如数据混乱，隐私错误等等。确保这种情况不会发生的一种方法是指定已删除条目的数字值（或名称，这也可能会导致JSON序列化问题）为 <code>reserved</code>。如果将来的任何用户试图使用这些字段标识符，Protocol Buffers 编译器将会报错。您可以使用 <code>max</code> 关键字指定您的保留数值范围上升到最大可能值。</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">enum </span><span class="hljs-title class_">Foo</span> &#123;  reserved <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span> to <span class="hljs-number">11</span>, <span class="hljs-number">40</span> to max;  reserved <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;BAR&quot;</span>;&#125;</code></pre></div><p><strong>注意，不能在同一个 <code>reserved</code> 语句中混合字段名称和字段编号</strong>。如有需要需要像上面这个例子这样写。</p><h3 id="6-允许嵌套"><a href="#6-允许嵌套" class="headerlink" title="6. 允许嵌套"></a>6. 允许嵌套</h3><p>Protocol Buffers 定义 message 允许嵌套组合成更加复杂的消息。</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchResponse</span> &#123;  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;  <span class="hljs-type">string</span> url = <span class="hljs-number">1</span>;  <span class="hljs-type">string</span> title = <span class="hljs-number">2</span>;  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> snippets = <span class="hljs-number">3</span>;&#125;</code></pre></div><p>上面的例子中，SearchResponse 中嵌套使用了 Result 。</p><p>更多的例子：</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchResponse</span> &#123;  <span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;    <span class="hljs-type">string</span> url = <span class="hljs-number">1</span>;    <span class="hljs-type">string</span> title = <span class="hljs-number">2</span>;    <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> snippets = <span class="hljs-number">3</span>;  &#125;  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">SomeOtherMessage</span> &#123;  SearchResponse.Result result = <span class="hljs-number">1</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Outer</span> &#123;                  <span class="hljs-comment">// Level 0</span>  <span class="hljs-keyword">message </span><span class="hljs-title class_">MiddleAA</span> &#123;  <span class="hljs-comment">// Level 1</span>    <span class="hljs-keyword">message </span><span class="hljs-title class_">Inner</span> &#123;   <span class="hljs-comment">// Level 2</span>      <span class="hljs-type">int64</span> ival = <span class="hljs-number">1</span>;      <span class="hljs-type">bool</span>  booly = <span class="hljs-number">2</span>;    &#125;  &#125;  <span class="hljs-keyword">message </span><span class="hljs-title class_">MiddleBB</span> &#123;  <span class="hljs-comment">// Level 1</span>    <span class="hljs-keyword">message </span><span class="hljs-title class_">Inner</span> &#123;   <span class="hljs-comment">// Level 2</span>      <span class="hljs-type">int32</span> ival = <span class="hljs-number">1</span>;      <span class="hljs-type">bool</span>  booly = <span class="hljs-number">2</span>;    &#125;  &#125;&#125;</code></pre></div><h3 id="7-枚举不兼容性"><a href="#7-枚举不兼容性" class="headerlink" title="7. 枚举不兼容性"></a>7. 枚举不兼容性</h3><p>可以导入 proto2 消息类型并在 proto3 消息中使用它们，反之亦然。然而，proto2 枚举不能直接用在 proto3 语法中（但是如果导入的proto2消息使用它们，这是可以的）。</p><h3 id="8-更新-message"><a href="#8-更新-message" class="headerlink" title="8. 更新 message"></a>8. 更新 message</h3><p>如果后面发现之前定义 message 需要增加字段了，这个时候就体现出 Protocol Buffer 的优势了，不需要改动之前的代码。不过需要满足以下 10 条规则：</p><ol><li>不要改动原有字段的数据结构。</li><li>如果您添加新字段，则任何由代码使用“旧”消息格式序列化的消息仍然可以通过新生成的代码进行分析。您应该记住这些元素的默认值，以便新代码可以正确地与旧代码生成的消息进行交互。同样，由新代码创建的消息可以由旧代码解析：旧的二进制文件在解析时会简单地忽略新字段。（具体原因见 <a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/Protocol-buffers-encode.md#9-%E6%9C%AA%E7%9F%A5%E5%AD%97%E6%AE%B5">未知字段</a> 这一章节）</li><li>只要字段号在更新的消息类型中不再使用，字段可以被删除。您可能需要重命名该字段，可能会添加前缀“OBSOLETE_”，或者标记成保留字段号 <code>reserved</code>，以便将来的 <code>.proto</code> 用户不会意外重复使用该号码。</li><li>int32，uint32，int64，uint64 和 bool 全都兼容。这意味着您可以将字段从这些类型之一更改为另一个字段而不破坏向前或向后兼容性。如果一个数字从不适合相应类型的线路中解析出来，则会得到与在 C++ 中将该数字转换为该类型相同的效果（例如，如果将 64 位数字读为 int32，它将被截断为 32 位）。</li><li>sint32 和 sint64 相互兼容，但与其他整数类型不兼容。</li><li>只要字节是有效的UTF-8，string 和 bytes 是兼容的。</li><li>嵌入式 message 与 bytes 兼容，如果 bytes 包含 message 的 encoded version。</li><li>fixed32与sfixed32兼容，而fixed64与sfixed64兼容。</li><li>enum 就数组而言，是可以与 int32，uint32，int64 和 uint64 兼容（请注意，如果它们不适合，值将被截断）。但是请注意，当消息反序列化时，客户端代码可能会以不同的方式对待它们：例如，未识别的 proto3 枚举类型将保留在消息中，但消息反序列化时如何表示是与语言相关的。（这点和语言相关，上面提到过了）Int 域始终只保留它们的值。</li><li>将单个<strong>值</strong>更改为新的成员是安全和二进制兼容的。如果您确定一次没有代码设置多个<strong>字段</strong>，则将多个字段移至新的字段可能是安全的。将任何<strong>字段</strong>移到现有字段中都是不安全的。（注意字段和值的区别，字段是 field，值是 value）</li></ol><h3 id="9-未知字段"><a href="#9-未知字段" class="headerlink" title="9. 未知字段"></a>9. 未知字段</h3><p>未知数字段是 protocol buffers 序列化的数据，表示解析器无法识别的字段。例如，当一个旧的二进制文件解析由新的二进制文件发送的新数据的数据时，这些新的字段将成为旧的二进制文件中的未知字段。</p><p>Proto3 实现可以成功解析未知字段的消息，但是，实现可能会或可能不会支持保留这些未知字段。你不应该依赖保存或删除未知域。对于大多数 Google protocol buffers 实现，未知字段在 proto3 中无法通过相应的 proto 运行时访问，并且在反序列化时被丢弃和遗忘。这是与 proto2 的不同行为，其中未知字段总是与消息一起保存并序列化。</p><h3 id="10-Map-类型"><a href="#10-Map-类型" class="headerlink" title="10. Map 类型"></a>10. Map 类型</h3><p>repeated 类型可以用来表示数组，Map 类型则可以用来表示字典。</p><div class="code-wrapper"><pre><code class="hljs thrift"><span class="hljs-type">map</span>&lt;key_type, value_type&gt; map_field = N;<span class="hljs-type">map</span>&lt;<span class="hljs-type">string</span>, Project&gt; projects = <span class="hljs-number">3</span>;</code></pre></div><p><code>key_type</code> 可以是任何 int 或者 string 类型(任何的标量类型，具体可以见上面标量类型对应表格，但是要除去 float、double 和 bytes)</p><p><strong>枚举值也不能作为 key</strong>。</p><p><code>key_type</code> 可以是除去 map 以外的任何类型。</p><p>需要特别注意的是 ：</p><ul><li>map 是不能用 repeated 修饰的。</li><li>线性数组和 map 迭代顺序的是不确定的，所以你不能依靠你的 map 是在一个特定的顺序。</li><li>为 <code>.proto</code> 生成文本格式时，map 按 key 排序。数字的 key 按数字排序。</li><li>从数组中解析或合并时，如果有重复的 key，则使用所看到的最后一个 key（覆盖原则）。从文本格式解析映射时，如果有重复的 key，解析可能会失败。</li></ul><p>Protocol Buffer 虽然不支持 map 类型的数组，但是可以转换一下，用以下思路实现 maps 数组：</p><div class="code-wrapper"><pre><code class="hljs abnf">message MapFieldEntry &#123;  key_type key <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span>  value_type value <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span>&#125;repeated MapFieldEntry map_field <span class="hljs-operator">=</span> N<span class="hljs-comment">;</span></code></pre></div><p>上述写法和 map 数组是完全等价的，所以用 repeated 巧妙的实现了 maps 数组的需求。</p><h3 id="11-JSON-Mapping"><a href="#11-JSON-Mapping" class="headerlink" title="11. JSON Mapping"></a>11. JSON Mapping</h3><p>Proto3 支持 JSON 中的规范编码，使系统之间共享数据变得更加容易。编码在下表中按类型逐个描述。</p><p>如果 JSON 编码数据中缺少值或其值为空，则在解析为 protocol buffer 时，它将被解释为适当的默认值。如果一个字段在协议缓冲区中具有默认值，默认情况下它将在 JSON 编码数据中省略以节省空间。具体 Mapping 的实现可以提供选项决定是否在 JSON 编码的输出中发送具有默认值的字段。</p><p>proto3 的 JSON 实现中提供了以下 4 中 options:</p><ul><li>使用默认值发送字段：在默认情况下，默认值的字段在 proto3 JSON 输出中被忽略。一个实现可以提供一个选项来覆盖这个行为，并使用它们的默认值输出字段。</li><li>忽略未知字段：默认情况下，Proto3 JSON 解析器应拒绝未知字段，但可能提供一个选项来忽略解析中的未知字段。</li><li>使用 proto 字段名称而不是 lowerCamelCase 名称：默认情况下，proto3 JSON 的 printer 将字段名称转换为 lowerCamelCase 并将其用作 JSON 名称。实现可能会提供一个选项，将原始字段名称用作 JSON 名称。 Proto3 JSON 解析器需要接受转换后的 lowerCamelCase 名称和原始字段名称。</li><li>发送枚举形式的枚举值而不是字符串：在 JSON 输出中默认使用枚举值的名称。可以提供一个选项来使用枚举值的数值。</li></ul><h2 id="四-proto3-定义-Services"><a href="#四-proto3-定义-Services" class="headerlink" title="四. proto3 定义 Services"></a>四. proto3 定义 Services</h2><p>如果要使用 RPC（远程过程调用）系统的消息类型，可以在 <code>.proto</code> 文件中定义 RPC 服务接口，protocol buffer 编译器将使用所选语言生成服务接口代码和 stubs。所以，例如，如果你定义一个 RPC 服务，入参是 SearchRequest 返回值是 SearchResponse，你可以在你的 <code>.proto</code> 文件中定义它，如下所示：</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">SearchService</span> &#123;  <span class="hljs-function"><span class="hljs-keyword">rpc</span> Search (SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span>;&#125;</code></pre></div><p>与 protocol buffer 一起使用的最直接的 RPC 系统是 gRPC：在谷歌开发的语言和平台中立的开源 RPC 系统。gRPC 在 protocol buffer 中工作得非常好，并且允许你通过使用特殊的 protocol buffer 编译插件，直接从 <code>.proto</code> 文件中生成 RPC 相关的代码。</p><p>如果你不想使用 gRPC，也可以在你自己的 RPC 实现中使用 protocol buffers。您可以在 Proto2 语言指南中找到更多关于这些相关的信息。</p><p>还有一些正在进行的第三方项目为 Protocol Buffers 开发 RPC 实现。</p><h2 id="五-Protocol-Buffer-命名规范"><a href="#五-Protocol-Buffer-命名规范" class="headerlink" title="五. Protocol Buffer 命名规范"></a>五. Protocol Buffer 命名规范</h2><p>message 采用驼峰命名法。message 首字母大写开头。字段名采用下划线分隔法命名。</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SongServerRequest</span> &#123;  <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> song_name = <span class="hljs-number">1</span>;&#125;</code></pre></div><p>枚举类型采用驼峰命名法。枚举类型首字母大写开头。每个枚举值全部大写，并且采用下划线分隔法命名。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Foo</span> &#123;</span>  FIRST_VALUE = <span class="hljs-number">0</span>;  SECOND_VALUE = <span class="hljs-number">1</span>;&#125;</code></pre></div><p><strong>每个枚举值用分号结束，不是逗号</strong>。</p><p>服务名和方法名都采用驼峰命名法。并且首字母都大写开头。</p><div class="code-wrapper"><pre><code class="hljs c">service FooService &#123;  rpc <span class="hljs-title function_">GetSomething</span><span class="hljs-params">(FooRequest)</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(FooResponse)</span>;&#125;</code></pre></div><h2 id="六-Protocol-Buffer-编码原理"><a href="#六-Protocol-Buffer-编码原理" class="headerlink" title="六. Protocol Buffer 编码原理"></a>六. Protocol Buffer 编码原理</h2><p>在讨论 Protocol Buffer 编码原理之前，必须先谈谈 Varints 编码。</p><h3 id="Base-128-Varints-编码"><a href="#Base-128-Varints-编码" class="headerlink" title="Base 128 Varints 编码"></a>Base 128 Varints 编码</h3><p>Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。</p><p>Varint 中的每个字节（最后一个字节除外）都设置了最高有效位（msb），这一位表示还会有更多字节出现。每个字节的低 7 位用于以 7 位组的形式存储数字的二进制补码表示，最低有效组首位。</p><p>如果用不到 1 个字节，那么最高有效位设为 0 ，如下面这个例子，1 用一个字节就可以表示，所以 msb 为 0.</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">0000</span> <span class="hljs-number">0001</span></code></pre></div><p>如果需要多个字节表示，msb 就应该设置为 1 。例如 300，如果用 Varint 表示的话：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1010</span> <span class="hljs-number">1100</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span></code></pre></div><p>如果按照正常的二进制计算的话，这个表示的是 88068(65536 + 16384 + 4096 + 2048 + 4)。</p><p>那 Varint 是怎么编码的呢？</p><p>下面代码是 Varint int 32 的编码计算方法。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">char</span>* <span class="hljs-title function_">EncodeVarint32</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">uint32_t</span> v)</span> &#123;  <span class="hljs-comment">// Operate on characters as unsigneds</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* ptr = reinterpret_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(dst);  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">128</span>;  <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>)) &#123;    *(ptr++) = v;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>)) &#123;    *(ptr++) = v | B;    *(ptr++) = v&gt;&gt;<span class="hljs-number">7</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>)) &#123;    *(ptr++) = v | B;    *(ptr++) = (v&gt;&gt;<span class="hljs-number">7</span>) | B;    *(ptr++) = v&gt;&gt;<span class="hljs-number">14</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">28</span>)) &#123;    *(ptr++) = v | B;    *(ptr++) = (v&gt;&gt;<span class="hljs-number">7</span>) | B;    *(ptr++) = (v&gt;&gt;<span class="hljs-number">14</span>) | B;    *(ptr++) = v&gt;&gt;<span class="hljs-number">21</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    *(ptr++) = v | B;    *(ptr++) = (v&gt;&gt;<span class="hljs-number">7</span>) | B;    *(ptr++) = (v&gt;&gt;<span class="hljs-number">14</span>) | B;    *(ptr++) = (v&gt;&gt;<span class="hljs-number">21</span>) | B;    *(ptr++) = v&gt;&gt;<span class="hljs-number">28</span>;  &#125;  <span class="hljs-keyword">return</span> reinterpret_cast&lt;<span class="hljs-type">char</span>*&gt;(ptr);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">300</span> = <span class="hljs-number">100101100</span></code></pre></div><p>由于 300 超过了 7 位（Varint 一个字节只有 7 位能用来表示数字，最高位 msb 用来表示后面是否有更多字节），所以 300 需要用 2 个字节来表示。</p><p>Varint 的编码，以 300 举例：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>)) &#123;    *(ptr++) = v | B;    *(ptr++) = v&gt;&gt;<span class="hljs-number">7</span>;&#125;<span class="hljs-number">1.</span> <span class="hljs-number">100101100</span> | <span class="hljs-number">10000000</span> = <span class="hljs-number">1</span> <span class="hljs-number">1010</span> <span class="hljs-number">1100</span><span class="hljs-number">2.</span> <span class="hljs-number">110101100</span> 取出末尾 <span class="hljs-number">7</span> 位 = <span class="hljs-number">010</span> <span class="hljs-number">1100</span><span class="hljs-number">3.</span> <span class="hljs-number">100101100</span> &gt;&gt; <span class="hljs-number">7</span> = <span class="hljs-number">10</span> = <span class="hljs-number">0000</span> <span class="hljs-number">0010</span><span class="hljs-number">4.</span> <span class="hljs-number">1010</span> <span class="hljs-number">1100</span> <span class="hljs-number">0000</span> <span class="hljs-number">0010</span> (最终 Varint 结果)</code></pre></div><p>Varint 的解码算法应该是这样的：（实际就是编码的逆过程）</p><ol><li>如果是多个字节，先去掉每个字节的 msb（通过逻辑或运算），每个字节只留下 7 位。</li><li>逆序整个结果，最多是 5 个字节，排序是 1-2-3-4-5，逆序之后就是 5-4-3-2-1，字节内部的二进制位的顺序不变，变的是字节的相对位置。</li></ol><p>解码过程调用 GetVarint32Ptr 函数，如果是大于一个字节的情况，会调用 GetVarint32PtrFallback 来处理。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">GetVarint32Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p,</span><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* limit,</span><span class="hljs-params">                                  <span class="hljs-type">uint32_t</span>* value)</span> &#123;  <span class="hljs-keyword">if</span> (p &lt; limit) &#123;    <span class="hljs-type">uint32_t</span> result = *(reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(p));    <span class="hljs-keyword">if</span> ((result &amp; <span class="hljs-number">128</span>) == <span class="hljs-number">0</span>) &#123;      *value = result;      <span class="hljs-keyword">return</span> p + <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> GetVarint32PtrFallback(p, limit, value);&#125;<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">GetVarint32PtrFallback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p,</span><span class="hljs-params">                                   <span class="hljs-type">const</span> <span class="hljs-type">char</span>* limit,</span><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span>* value)</span> &#123;  <span class="hljs-type">uint32_t</span> result = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> shift = <span class="hljs-number">0</span>; shift &lt;= <span class="hljs-number">28</span> &amp;&amp; p &lt; limit; shift += <span class="hljs-number">7</span>) &#123;    <span class="hljs-type">uint32_t</span> byte = *(reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(p));    p++;    <span class="hljs-keyword">if</span> (byte &amp; <span class="hljs-number">128</span>) &#123;      <span class="hljs-comment">// More bytes are present</span>      result |= ((byte &amp; <span class="hljs-number">127</span>) &lt;&lt; shift);    &#125; <span class="hljs-keyword">else</span> &#123;      result |= (byte &lt;&lt; shift);      *value = result;      <span class="hljs-keyword">return</span> reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(p);    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;</code></pre></div><p>至此，Varint 处理过程读者应该都熟悉了。上面列举出了 Varint 32 的算法，64 位的同理，只不过不再用 10 个分支来写代码了，太丑了。（32位 是 5 个 字节，64位 是 10 个字节）</p><p>64 位 Varint 编码实现：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">char</span>* <span class="hljs-title function_">EncodeVarint64</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">uint64_t</span> v)</span> &#123;  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">128</span>;  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* ptr = reinterpret_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(dst);  <span class="hljs-keyword">while</span> (v &gt;= B) &#123;    *(ptr++) = (v &amp; (B<span class="hljs-number">-1</span>)) | B;    v &gt;&gt;= <span class="hljs-number">7</span>;  &#125;  *(ptr++) = static_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(v);  <span class="hljs-keyword">return</span> reinterpret_cast&lt;<span class="hljs-type">char</span>*&gt;(ptr);&#125;</code></pre></div><p>原理不变，只不过用循环来解决了。</p><p>64 位 Varint 解码实现：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">GetVarint64Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* limit, <span class="hljs-type">uint64_t</span>* value)</span> &#123;  <span class="hljs-type">uint64_t</span> result = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> shift = <span class="hljs-number">0</span>; shift &lt;= <span class="hljs-number">63</span> &amp;&amp; p &lt; limit; shift += <span class="hljs-number">7</span>) &#123;    <span class="hljs-type">uint64_t</span> byte = *(reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(p));    p++;    <span class="hljs-keyword">if</span> (byte &amp; <span class="hljs-number">128</span>) &#123;      <span class="hljs-comment">// More bytes are present</span>      result |= ((byte &amp; <span class="hljs-number">127</span>) &lt;&lt; shift);    &#125; <span class="hljs-keyword">else</span> &#123;      result |= (byte &lt;&lt; shift);      *value = result;      <span class="hljs-keyword">return</span> reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(p);    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;</code></pre></div><p>读到这里可能有读者会问了，Varint 不是为了紧凑 int 的么？那 300 本来可以用 2 个字节表示，现在还是 2 个字节了，哪里紧凑了，花费的空间没有变啊？！</p><p>Varint 确实是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。</p><p>300 如果用 int32 表示，需要 4 个字节，现在用 Varint 表示，只需要 2 个字节了。缩小了一半！</p><h3 id="1-Message-Structure-编码"><a href="#1-Message-Structure-编码" class="headerlink" title="1. Message Structure 编码"></a>1. Message Structure 编码</h3><p>protocol buffer 中 message 是一系列键值对。message 的二进制版本只是使用字段号(field’s number 和 wire_type)作为 key。每个字段的名称和声明类型只能在解码端通过引用消息类型的定义（即 <code>.proto</code> 文件）来确定。这一点也是人们常常说的 protocol buffer 比 JSON，XML 安全一点的原因，如果没有数据结构描述 <code>.proto</code> 文件，拿到数据以后是无法解释成正常的数据的。</p><p>由于采用了 tag-value 的形式，所以 option 的 field 如果有，就存在在这个 message buffer 中，如果没有，就不会在这里，这一点也算是压缩了 message 的大小了。</p><p>当消息编码时，键和值被连接成一个字节流。当消息被解码时，解析器需要能够跳过它无法识别的字段。这样，可以将新字段添加到消息中，而不会破坏不知道它们的旧程序。这就是所谓的 “向后”兼容性。</p><p>为此，线性的格式消息中每对的“key”实际上是两个值，其中一个是来自<code>.proto</code>文件的字段编号，加上提供正好足够的信息来查找下一个值的长度。在大多数语言实现中，这个 key 被称为 tag。</p><p><strong>注意上图中，3 和 4 已经被废弃了，所以 wire_type 取值目前只有 0、1、2、5</strong>。</p><p>key 的计算方法是 <code>(field_number &lt;&lt; 3) | wire_type</code>，换句话说，key 的最后 3 位表示的就是 <code>wire_type</code>。</p><p>举例，一般 message 的字段号都是 1 开始的，所以对应的 tag 可能是这样的：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">000</span> <span class="hljs-number">1000</span></code></pre></div><p>末尾 3 位表示的是 value 的类型，这里是 000，即 0 ，代表的是 varint 值。右移 3 位，即 0001，这代表的就是字段号(field number)。tag 的例子就举这么多，接下来举一个 value 的例子，还是用 varint 来举例：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">96</span> <span class="hljs-number">01</span> = <span class="hljs-number">1001</span> <span class="hljs-number">0110</span>  <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>       → <span class="hljs-number">000</span> <span class="hljs-number">0001</span>  ++  <span class="hljs-number">001</span> <span class="hljs-number">0110</span> (drop the msb and reverse the groups of <span class="hljs-number">7</span> bits)       → <span class="hljs-number">10010110</span>       → <span class="hljs-number">128</span> + <span class="hljs-number">16</span> + <span class="hljs-number">4</span> + <span class="hljs-number">2</span> = <span class="hljs-number">150</span></code></pre></div><p>可以 96 01 代表的数据就是 150 。</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Test1</span> &#123;  <span class="hljs-keyword">required</span> <span class="hljs-type">int32</span> a = <span class="hljs-number">1</span>;&#125;</code></pre></div><p>如果存在上面这样的一个 message 的结构，如果存入 150，在 Protocol Buffer 中显示的二进制应该为 08 96 01 。</p><p>额外说一句，type 需要注意的是 type &#x3D; 2 的情况，tag 里面除了包含 field number 和 wire_type ，还需要再包含一个 length，决定 value 从那一段取出来。（具体原因见 <a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/Protocol-buffers-encode.md#4-%E5%AD%97%E7%AC%A6%E4%B8%B2">Protocol Buffer 字符串</a> 这一章节）</p><h3 id="2-Signed-Integers-编码"><a href="#2-Signed-Integers-编码" class="headerlink" title="2. Signed Integers 编码"></a>2. Signed Integers 编码</h3><p>从上面的表格里面可以看到 wire_type &#x3D; 0 中包含了无符号的 varints，但是如果是一个无符号数呢？</p><p>一个负数一般会被表示为一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用 Varint 表示一个负数，那么一定需要 10 个 byte 长度。</p><blockquote><p>为何 32 位和 64 位的负数都需要 10 个 byte 长度呢？</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CodedOutputStream::WriteVarint32SignExtended</span><span class="hljs-params">(int32 value)</span> </span>&#123; <span class="hljs-built_in">WriteVarint64</span>(<span class="hljs-built_in">static_cast</span>&lt;uint64&gt;(value));&#125;</code></pre></div><p>因为源码里面是这么规定的。32 位的有符号数都会转换成 64 位无符号来处理。至于源码为什么要这么规定呢，猜想可能是怕 32 位的负数转换会有溢出的可能。(只是猜想)</p></blockquote><p>为此 Google Protocol Buffer 定义了 sint32 这种类型，采用 zigzag 编码。<strong>将所有整数映射成无符号整数，然后再采用 varint 编码方式编码</strong>，这样，绝对值小的整数，编码后也会有一个较小的 varint 编码值。</p><p>Zigzag 映射函数为：</p><div class="code-wrapper"><pre><code class="hljs c">Zigzag(n) = (n &lt;&lt; <span class="hljs-number">1</span>) ^ (n &gt;&gt; <span class="hljs-number">31</span>), n 为 sint32 时Zigzag(n) = (n &lt;&lt; <span class="hljs-number">1</span>) ^ (n &gt;&gt; <span class="hljs-number">63</span>), n 为 sint64 时</code></pre></div><p>按照这种方法，-1 将会被编码成 1，1 将会被编码成 2，-2 会被编码成 3，如下表所示：</p><p>需要注意的是，第二个转换 <code>（n &gt;&gt; 31）</code> 部分，是一个算术转换。所以，换句话说，移位的结果要么是一个全为0（如果n是正数），要么是全部1（如果n是负数）。</p><p>当 sint32 或 sint64 被解析时，它的值被解码回原始的带符号的版本。</p><h3 id="3-Non-varint-Numbers"><a href="#3-Non-varint-Numbers" class="headerlink" title="3. Non-varint Numbers"></a>3. Non-varint Numbers</h3><p>Non-varint 数字比较简单，double 、fixed64 的 wire_type 为 1，在解析时告诉解析器，该类型的数据需要一个 64 位大小的数据块即可。同理，float 和 fixed32 的 wire_type 为5，给其 32 位数据块即可。两种情况下，都是高位在后，低位在前。</p><p><strong>说 Protocol Buffer 压缩数据没有到极限，原因就在这里，因为并没有压缩 float、double 这些浮点类型</strong>。</p><h3 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h3><p>wire_type 类型为 2 的数据，是一种指定长度的编码方式：key + length + content，key 的编码方式是统一的，length 采用 varints 编码方式，content 就是由 length 指定长度的 Bytes。</p><p>举例，假设定义如下的 message 格式：</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Test2</span> &#123;  <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> b = <span class="hljs-number">2</span>;&#125;</code></pre></div><p>设置该值为”testing”，二进制格式查看：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">12</span> <span class="hljs-number">07</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span></code></pre></div><p>74 65 73 74 69 6e 67  是“testing”的 UTF8 代码。</p><p>此处，key 是16进制表示的，所以展开是：</p><p>12 -&gt; 0001 0010，后三位 010 为 wire type &#x3D; 2，0001 0010 右移三位为 0000 0010，即 tag &#x3D; 2。</p><p>length 此处为 7，后边跟着 7 个bytes，即我们的字符串”testing”。</p><p><strong>所以 wire_type 类型为 2 的数据，编码的时候会默认转换为 T-L-V (Tag - Length - Value)的形式</strong>。</p><h3 id="5-嵌入式-message"><a href="#5-嵌入式-message" class="headerlink" title="5. 嵌入式 message"></a>5. 嵌入式 message</h3><p>假设，定义如下嵌套消息：</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Test3</span> &#123;  <span class="hljs-keyword">optional</span> Test1 c = <span class="hljs-number">3</span>;&#125;</code></pre></div><p>设置字段为整数150，编码后的字节为：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">1</span>a <span class="hljs-number">03</span> <span class="hljs-number">08</span> <span class="hljs-number">96</span> <span class="hljs-number">01</span></code></pre></div><p>08 96 01 这三个代表的是 150，上面讲解过，这里就不再赘述了。</p><p>1a -&gt; 0001 1010，后三位 010 为 wire type &#x3D; 2，0001 1010 右移三位为 0000 0011，即 tag &#x3D; 3。</p><p>length 为 3，代表后面有 3 个字节，即 08 96 01 。</p><p>需要转变为 T - L - V 形式的还有 string, bytes, embedded messages, packed repeated fields （即 wire_type 为 2 的形式都会转变成 T - L - V 形式）</p><h3 id="6-Optional-和-Repeated-的编码"><a href="#6-Optional-和-Repeated-的编码" class="headerlink" title="6. Optional 和 Repeated 的编码"></a>6. Optional 和 Repeated 的编码</h3><p>在 proto2 中定义成 repeated 的字段，（没有加上 [packed&#x3D;true] option ），编码后的 message 有一个或者多个包含相同 tag 数字的 key-value 对。这些重复的 value 不需要连续的出现；他们可能与其他的字段间隔的出现。尽管他们是无序的，但是在解析时，他们是需要有序的。在 proto3 中 repeated 字段默认采用 packed 编码（具体原因见 <a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/Protocol-buffers-encode.md#7-packed-repeated-fields">Packed Repeated Fields</a> 这一章节）</p><p>对于 proto3 中的任何非重复字段或 proto2 中的可选字段，编码的 message 可能有也可能没有包含该字段号的键值对。</p><p>通常，编码后的 message，其 required 字段和 optional 字段最多只有一个实例。但是解析器却需要处理多对一的情况。对于数字类型和 string 类型，如果同一值出现多次，解析器接受最后一个它收到的值。对于内嵌字段，解析器合并(merge)它接收到的同一字段的多个实例。就如 MergeFrom 方法一样，所有单数的字段，后来的会替换先前的，所有单数的内嵌 message 都会被合并(merge)，所有的 repeated 字段，都会串联起来。这样的规则的结果是，<strong>解析两个串联的编码后的 message，与分别解析两个 message 然后 merge，结果是一样的</strong>。例如：</p><div class="code-wrapper"><pre><code class="hljs c">MyMessage message;message.ParseFromString(str1 + str2);</code></pre></div><p>等价于</p><div class="code-wrapper"><pre><code class="hljs c">MyMessage message, message2;message.ParseFromString(str1);message2.ParseFromString(str2);message.MergeFrom(message2);</code></pre></div><p>这种方法有时是非常有用的。比如，即使不知道 message 的类型，也能够将其合并。</p><h3 id="7-Packed-Repeated-Fields"><a href="#7-Packed-Repeated-Fields" class="headerlink" title="7. Packed Repeated Fields"></a>7. Packed Repeated Fields</h3><p>在 2.1.0 版本以后，protocol buffers 引入了该种类型，其与 repeated 字段一样，只是在末尾声明了 [packed&#x3D;true]。类似 repeated 字段却又不同。在 proto3 中 Repeated 字段默认就是以这种方式处理。对于 packed repeated 字段，如果 message 中没有赋值，则不会出现在编码后的数据中。否则的话，该字段所有的元素会被打包到单一一个 key-value 对中，且它的 wire_type&#x3D;2，长度确定。每个元素正常编码，只不过其前没有标签 tag。例如有如下 message 类型：</p><div class="code-wrapper"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Test4</span> &#123;  <span class="hljs-keyword">repeated</span> <span class="hljs-type">int32</span> d = <span class="hljs-number">4</span> [packed=<span class="hljs-literal">true</span>];&#125;</code></pre></div><p>构造一个 Test4 字段，并且设置 repeated 字段 d 3个值：3，270和86942，编码后：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-number">22</span> <span class="hljs-comment">// tag 0010 0010(field number 010 0 = 4, wire type 010 = 2)</span><span class="hljs-number">06</span> <span class="hljs-comment">// payload size (设置的length = 6 bytes)</span><span class="hljs-number">03</span> <span class="hljs-comment">// first element (varint 3)</span><span class="hljs-number">8</span>E <span class="hljs-number">02</span> <span class="hljs-comment">// second element (varint 270)</span><span class="hljs-number">9</span>E A7 <span class="hljs-number">05</span> <span class="hljs-comment">// third element (varint 86942)</span></code></pre></div><p><strong>形成了 Tag - Length - Value - Value - Value …… 对</strong>。</p><p>只有原始数字类型（使用varint，32位或64位）的重复字段才可以声明为“packed”。</p><p>有一点需要注意，对于 packed 的 repeated 字段，尽管通常没有理由将其编码为多个 key-value 对，编码器必须有接收多个 key-pair 对的准备。这种情况下，payload 必须是串联的，每个 pair 必须包含完整的元素。</p><p>Protocol Buffer 解析器必须能够解析被重新编译为 packed 的字段，就像它们未被 packed 一样，反之亦然。这允许以正向和反向兼容的方式将[packed &#x3D; true]添加到现有字段。</p><h3 id="8-Field-Order"><a href="#8-Field-Order" class="headerlink" title="8. Field Order"></a>8. Field Order</h3><p>编码&#x2F;解码与字段顺序无关，这一点由 key-value 机制保证。</p><p>如果消息具有未知字段，则当前的 Java 和 C++ 实现在按顺序排序的已知字段之后以任意顺序写入它们。当前的 Python 实现不会跟踪未知字段。</p><h2 id="七-protocol-buffers-的优缺点"><a href="#七-protocol-buffers-的优缺点" class="headerlink" title="七. protocol buffers 的优缺点"></a>七. protocol buffers 的优缺点</h2><p>protocol buffers 在序列化方面，与 XML 相比，有诸多优点：</p><ul><li>更加简单</li><li>数据体积小 3- 10 倍</li><li>更快的反序列化速度，提高 20 - 100 倍</li><li>可以自动化生成更易于编码方式使用的数据访问类</li></ul><p>举个例子：</p><p>如果要编码一个用户的名字和 email 信息，用 XML 的方式如下：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">person</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>John Doe<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>jdoe@example.com<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">person</span>&gt;</span></code></pre></div><p>相同需求，如果换成 protocol buffers 来实现，定义文件如下：</p><div class="code-wrapper"><pre><code class="hljs c"># Textual representation of a protocol buffer.# This is *not* the binary format used on the wire.person &#123;  name: <span class="hljs-string">&quot;John Doe&quot;</span>  email: <span class="hljs-string">&quot;jdoe@example.com&quot;</span>&#125;</code></pre></div><p>protocol buffers 通过编码以后，以二进制的方式进行数据传输，最多只需要 28 bytes 空间和 100-200 ns 的反序列化时间。但是 XML 则至少需要 69 bytes 空间（经过压缩以后，去掉所有空格）和 5000-10000 的反序列化时间。</p><p>上面说的是性能方面的优势。接下来说说编码方面的优势。</p><p>protocol buffers 自带代码生成工具，可以生成友好的数据访问存储接口。从而开发人员使用它来编码更加方便。例如上面的例子，如果用 C++ 的方式去读取用户的名字和 email，直接调用对应的 get 方法即可（所有属性的 get 和 set 方法的代码都自动生成好了，只需要调用即可）</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; person.name() &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;E-mail: &quot;</span> &lt;&lt; person.email() &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre></div><p>而 XML 读取数据会麻烦一些：</p><div class="code-wrapper"><pre><code class="hljs xml">cout &lt;&lt; &quot;Name: &quot;     &lt;&lt; person.getElementsByTagName(&quot;name&quot;)-&gt;item(0)-&gt;innerText()     &lt;&lt; endl;cout &lt;&lt; &quot;E-mail: &quot;     &lt;&lt; person.getElementsByTagName(&quot;email&quot;)-&gt;item(0)-&gt;innerText()     &lt;&lt; endl;</code></pre></div><p>Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。</p><p>使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。</p><p>protocol buffers 最后一个非常棒的特性是，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变(因为存储方式本来就是无序的，k-v 形式)。</p><p>当然 protocol buffers 也并不是完美的，在使用上存在一些局限性。</p><p>由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 <code>.proto</code> 定义，否则你没法直接读出 Protobuf 的任何内容。</p><h2 id="八-最后"><a href="#八-最后" class="headerlink" title="八. 最后"></a>八. 最后</h2><p>读完本篇 Protocol Buffer 编码原理以后，读者应该能明白以下几点：</p><ol><li>Protocol Buffer 利用 varint 原理压缩数据以后，二进制数据非常紧凑，option 也算是压缩体积的一个举措。所以 pb 体积更小，如果选用它作为网络数据传输，势必相同数据，消耗的网络流量更少。但是并没有压缩到极限，float、double 浮点型都没有压缩。</li><li>Protocol Buffer 比 JSON 和 XML 少了 {、}、: 这些符号，体积也减少一些。再加上 varint 压缩，gzip 压缩以后体积更小！</li><li>Protocol Buffer 是 Tag - Value (Tag - Length - Value)的编码方式的实现，减少了分隔符的使用，数据存储更加紧凑。</li><li>Protocol Buffer 另外一个核心价值在于提供了一套工具，一个编译工具，自动化生成 get&#x2F;set 代码。简化了多语言交互的复杂度，使得编码解码工作有了生产力。</li><li>Protocol Buffer 不是自我描述的，离开了数据描述 <code>.proto</code> 文件，就无法理解二进制数据流。这点即是优点，使数据具有一定的“加密性”，也是缺点，数据可读性极差。所以 Protocol Buffer 非常适合内部服务之间 RPC 调用和传递数据。</li><li>Protocol Buffer 具有向后兼容的特性，更新数据结构以后，老版本依旧可以兼容，这也是 Protocol Buffer 诞生之初被寄予解决的问题。因为编译器对不识别的新增字段会跳过不处理。</li></ol><p>Protocol Buffer 编码原理篇到此结束，下篇来讲讲 Protocol Buffer 反序列化解包性能快的原因。</p><p>Reference：</p><ul><li><p><a href="https://developers.google.com/protocol-buffers/docs/overview">google 官方文档</a></p></li><li><p><a href="https://halfrost.com/protobuf_encode/">原文地址</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 性能优化</title>
    <link href="/2023/02/28/ios/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/02/28/ios/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-Performance-Optimization"><a href="#iOS-Performance-Optimization" class="headerlink" title="iOS-Performance-Optimization"></a>iOS-Performance-Optimization</h1><ul><li><a href="https://github.com/tbfungeek/iOS-Performance-Optimization">原文地址</a></li></ul><p>关于 iOS 性能优化梳理：<br>基本工具、业务优化、内存优化、卡顿优化、电量优化、 安装包瘦身、启动优化、网络优化等</p><h2 id="iOS-官方文档"><a href="#iOS-官方文档" class="headerlink" title="iOS 官方文档"></a>iOS 官方文档</h2><ul><li><a href="https://developer.apple.com/library/content/navigation/#section=Topics&topic=Performance">Performance 专题</a></li></ul><h2 id="iOS-性能优化相关书籍"><a href="#iOS-性能优化相关书籍" class="headerlink" title="iOS 性能优化相关书籍"></a>iOS 性能优化相关书籍</h2><ul><li><a href="http://download.csdn.net/detail/tskyming/9831453">Pro iOS Apps Performance Optimization</a></li><li><a href="http://download.csdn.net/detail/tskyming/9831465">High Performance iOS Apps</a></li></ul><h2 id="Instruments-工具相关"><a href="#Instruments-工具相关" class="headerlink" title="Instruments 工具相关"></a>Instruments 工具相关</h2><ul><li><a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html">Instruments User Guide</a> <a href="http://cdn.cocimg.com/bbs/attachment/Fid_6/6_24457_90eabb4ed5b3863.pdf">中文翻译-PDF</a> </li><li><a href="http://www.cnblogs.com/lxlx1798/p/6933485.html">Instruments之Leaks学习</a> </li><li><a href="http://www.cnblogs.com/lxlx1798/p/6933195.html">Instruments学习之Allocations</a> </li><li><a href="http://www.cnblogs.com/lxlx1798/p/6933604.html">instrument之Time Profiler总结</a></li><li><a href="http://www.cnblogs.com/lxlx1798/p/6933364.html">Instruments学习之Core Animation学习</a> </li><li><a href="http://www.cnblogs.com/lxlx1798/p/6933141.html">Instruments之Activity Monitor使用入门</a> </li><li><a href="http://www.jianshu.com/p/9dbbc91c8059">使用Instrument调试界面卡顿</a></li><li><a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques/blob/master/12-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.md">Core Animation性能调优</a></li></ul><h2 id="综合篇"><a href="#综合篇" class="headerlink" title="综合篇"></a>综合篇</h2><ul><li><a href="https://developer.apple.com/videos/play/wwdc2012/235">WWDC2012-235-iOS APP Performance:Responsiveness</a></li><li><a href="http://wereadteam.github.io/2016/05/03/WeRead-Performance/">微信读书iOS性能优化</a></li><li><a href="http://wereadteam.github.io/2016/12/12/Monitor/">微信读书 iOS 质量保证及性能监控</a></li><li><a href="https://ming1016.github.io/2017/06/20/deeply-ios-performance-optimization/">深入剖析 iOS 性能优化</a></li><li><a href="http://blog.csdn.net/magicwindow/article/details/51423463">魔窗研发副总裁沈哲：移动端SDK的优化之路</a></li><li><a href="http://www.cocoachina.com/design/20160905/17483.html">搜狗输入法 iOS 版开发与优化实践</a><a href="https://github.com/MDCC2016/iOS-Session-Slides/blob/master/%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E6%9D%8E%E8%85%BE%E6%9D%B0.pdf">PPT</a></li><li><a href="http://www.infoq.com/cn/presentations/stability-and-performance-of-mogujie-app">蘑菇街 App 的稳定性与性能实践</a><a href="https://sanwen8.cn/p/6e5c888.html">PPT</a></li><li><a href="http://pstatic.geekbang.org/pdf/593a53d813cef.pdf?e=1497499485&token=eHNJKRTldoRsUX0uCP9M3icEhpbyh3VF9Nrk5UPM:sa-xp_aIeIhtiWbqR-hY4ImMzFc=">⼿淘iOS性能优化探索</a></li><li><a href="https://juejin.im/post/58ca0832a22b9d006418fe43">iOS App 稳定性指标及监测</a></li></ul><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><ul><li><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/ManagingMemory.html#//apple_ref/doc/uid/10000160i">Memory Usage Performance Guidelines</a> </li><li><a href="https://juejin.im/post/5a5e13c45188257327399e19">探索iOS内存分配</a> </li><li><a href="http://wetest.qq.com/lab/view/367.html?from=content_juejin">iOS微信内存监控</a></li></ul><h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&idx=1&mid=207890859&scene=23&sn=e98dd604cdb854e7a5808d2072c29162&srcid=0921FzoCw9j1W7n4uFYKuarC#rd">微信iOS卡顿监控系统</a></li><li><a href="http://www.cnblogs.com/gatsbywang/p/5555200.html">iOS-卡顿检测</a></li><li><a href="http://ios.jobbole.com/93085/">iOS监控：卡顿检测</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5MjEzNzA1MA==&mid=2650264136&idx=1&sn=052c1db8131d4bed8458b98e1ec0d5b0&chksm=f406837dc3710a6b49e76ce3639f671373b553e8a91b544e82bb8747e9adc7985fea1093a394#rd">iOS应用UI线程卡顿监控</a></li><li><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4MzEwOTkyMQ==&mid=2667379069&idx=1&sn=376d9ef2261cf13e930406f1c35d3569&chksm=84f32833b384a1250ef66f76a8d050216fd3b0bd4ea99b55f4a609cf268c8169ac2889746245&mpshare=1&scene=1&srcid=0810MDXnroCGDhecWqlXazwE&key=05d58d453d781a66b453e3d41dd8d420839dd771948b07f8c8afe3482922901ad13e8c8ab46f48d0883e9b55d304f6ce272854ecc200f68557644581408036c8ee0c5154fbf413a007cd7617b0e086f6&ascene=0&uin=MjY1NTg0NzMyMQ==&devicetype=iMac+MacBookPro11,4+OSX+OSX+10.12.5+build(16F73)&version=12020810&nettype=WIFI&fontScale=100&pass_ticket=OB4hdN6ImVq0WXd+DAJVSADk3OsXMiJH5VzZqXk/7meSbJNPMBTUB2z5/ct+uPmN">实现 60fps 的网易云音乐首页</a> </li><li><a href="http://wetest.qq.com/lab/view/354.html">QQ空间掉帧率优化实战</a></li></ul><h2 id="电量优化"><a href="#电量优化" class="headerlink" title="电量优化"></a>电量优化</h2><ul><li><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/index.html#//apple_ref/doc/uid/TP40015243">Guide - Energy Efficiency Guide for iOS Apps</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/238/">WWDC2017 - Writing Energy Efficient Apps</a></li><li><a href="https://github.com/ChenYilong/iOSBlog/issues/10">iOS 常见耗电量检测方案调研</a></li><li><a href="http://www.jianshu.com/p/f0dc653d04ca">教你开发省电的 iOS app（WWDC17 观后）</a></li><li><a href="https://juejin.im/post/5a0c5af051882578da0d6925">浅析移动蜂窝网络的特点及其省电方案</a></li><li><a href="https://mp.weixin.qq.com/s/q39BHIWsbdNeqfH85EOkIQ">iOS电量测试实践</a></li><li><a href="http://www.cocoachina.com/ios/20171204/21413.html">iOS进阶–App功耗优化看这篇就够了</a></li></ul><h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><ul><li><a href="https://developer.apple.com/videos/play/wwdc2016/406">WWDC2016-406-Optimizing App Startup Time</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/413">WWDC2017-413-App Startup Time:Past,Present,and Future</a></li><li><a href="https://www.jianshu.com/p/c14987eee107">如何精准度量iOSAPP启动时间</a></li><li><a href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time">优化 App 的启动时间-杨萧玉</a></li><li><a href="https://techblog.toutiao.com/2017/01/17/iosspeed/#more">iOS客户端启动速度优化-今日头条</a></li><li><a href="https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA">iOS App 启动性能优化-WiFi管家</a></li><li><a href="http://www.cocoachina.com/ios/20160104/14870.html">iOS App如何优化启动时间-Facebook</a></li><li><a href="http://www.infoq.com/cn/presentations/ios-typewriting-start-speed-optimization">iOS 启动速度优化-百度输入法</a></li><li><a href="https://juejin.im/post/5a31190751882559e225a775">一次立竿见影的启动时间优化</a></li><li><a href="https://objccn.io/issue-6-3/">obj中国-Mach-O 可执行文件</a></li></ul><h2 id="体积优化"><a href="#体积优化" class="headerlink" title="体积优化"></a>体积优化</h2><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=207986417&idx=1&sn=77ea7d8e4f8ab7b59111e78c86ccfe66&scene=24&srcid=0921TTAXHGHWKqckEHTvGzoA#rd">iOS微信安装包瘦身</a></li><li><a href="https://techblog.toutiao.com/2016/12/27/iphone/">今日头条IPA安装包的优化</a></li><li><a href="http://www.infoq.com/cn/articles/ios-thinning-delete-unnecessary-mach-o">iOS瘦身之删除FrameWork中无用mach-O文件</a></li><li><a href="http://www.infoq.com/cn/articles/clang-plugin-ios-app-size-reducing">基于clang插件的一种iOS包大小瘦身方案</a></li><li><a href="http://blog.cnbang.net/tech/2544/">iOS可执行文件瘦身方法</a></li><li><a href="http://crespoxiao.github.io/2016/11/12/iOS%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">iOS图片优化方案</a></li><li><a href="https://ming1016.github.io/2017/06/12/gmtc-ios-slimming-practice/">滴滴出行 iOS 端瘦身实践的 Slides</a></li></ul><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><ul><li><a href="http://tech.meituan.com/SharkSDK.html">美团点评移动网络优化实践</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=209805123&idx=1&sn=ced8d67c3e2cc3ca38ef722949fa21f8">开源版HttpDNS方案详解</a></li><li><a href="http://www.infoq.com/cn/articles/how-ctrip-improves-app-networking-performance">携程App的网络性能优化实践</a></li><li><a href="http://www.infoq.com/cn/articles/app-network-service-and-performance-optimization-of-ctrip">2016年携程App网络服务通道治理和性能优化实践</a></li><li><a href="http://www.infoq.com/cn/articles/mogujie-app-chromium-network-layer">蘑菇街App Chromium网络栈实践</a></li><li><a href="http://www.infoq.com/cn/presentations/mogujie-high-concurrent-multi-terminal-wireless-gateway-practice">蘑菇街高并发多终端无线网关实践</a></li><li><a href="http://blog.cnbang.net/tech/3531/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io">移动 APP 网络优化概述</a></li></ul><h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><ul><li><a href="https://github.com/fastred/Optimizing-Swift-Build-Times">Optimizing-Swift-Build-Times</a></li></ul><h2 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h2><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&mid=2651112215&idx=1&sn=9cc5b5fa630542a6d4b7a5626e35217a#rd">网易 - NeteaseAPM iOS SDK技术实现分享</a></li><li><a href="http://www.jianshu.com/p/69ce01e15042">网易乐得 - iOS无埋点数据SDK实践之路</a> </li><li><a href="http://www.infoq.com/cn/presentations/mobile-terminal-apm-product-development-skills">听云 - 移动端 APM 产品研发技能</a> </li><li><a href="http://www.infoq.com/cn/presentations/mobile-app-performance-monitoring-practice?utm_source=presentations_about_mobile&utm_medium=link&utm_campaign=mobile">听云 - 移动 App 性能监测</a></li><li><a href="https://github.com/aozhimin/iOS-Monitor-Platform">iOS 性能监控 SDK —— Wedjat（华狄特）开发过程的调研和整理</a></li><li><a href="https://github.com/iOS-APM/iOS-APM-Secrets">揭秘 APM iOS SDK 的核心技术</a>  </li><li><a href="https://github.com/aozhimin/iOS-Monitor-Resources">iOS-Monitor-Resources</a></li></ul><h2 id="调试-amp-Crash"><a href="#调试-amp-Crash" class="headerlink" title="调试 &amp; Crash"></a>调试 &amp; Crash</h2><ul><li><a href="https://github.com/aozhimin/iOS-Debug-Hacks">iOS 项目开发过程中用到的高级调试技巧，涉及三方库动态调试、静态分析和反编译等领域</a></li><li><a href="https://developer.apple.com/library/content/technotes/tn2151/_index.html">Understanding and Analyzing Application Crash Reports</a></li></ul><h2 id="相关开源库"><a href="#相关开源库" class="headerlink" title="相关开源库"></a>相关开源库</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li><a href="https://github.com/CNSRE/HTTPDNSLib-for-iOS">HTTPDNSLib-for-iOS</a></li><li><a href="https://github.com/CNSRE/HTTPDNSLib">HTTPDNSLib-for-Andorod</a></li><li><a href="https://github.com/coderyi/NetworkEye/blob/master/README_Chinese.md">NetworkEye</a></li></ul><h3 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h3><ul><li><a href="https://github.com/suifengqjn/PerformanceMonitor">PerformanceMonitor-Runloop</a></li><li><a href="https://github.com/featuretower/GYMonitor">GYMonitor-FPS</a></li></ul><h3 id="瘦身"><a href="#瘦身" class="headerlink" title="瘦身"></a>瘦身</h3><ul><li><a href="https://github.com/tinymind/LSUnusedResources">LSUnusedResources</a></li><li><a href="https://github.com/huanxsd/LinkMap">LinkMap</a></li></ul><h2 id="APM-1"><a href="#APM-1" class="headerlink" title="APM"></a>APM</h2><ul><li><a href="https://github.com/iOS-APM/iOS-System-Services">iOS-System-Services</a></li><li><a href="https://github.com/iOS-APM/SystemMonitor">System Monitor</a></li><li><a href="https://github.com/Split82/iOSMemoryBudgetTest">iOS Memory Budget Test</a></li><li><a href="https://github.com/ArmsZhou/PerformanceTestingHelper">PerformanceTestingHelper</a></li><li><a href="https://github.com/Tencent/GT">GT</a></li></ul><h2 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h2><ul><li><a href="https://github.com/tbfungeek/iOS-Performance-Optimization">iOS-Performance-Optimization</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 协议字段位详解</title>
    <link href="/2023/02/27/other/TCP-%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/27/other/TCP-%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-协议字段位详解"><a href="#TCP-协议字段位详解" class="headerlink" title="TCP 协议字段位详解"></a>TCP 协议字段位详解</h1><p>TCP（Transmission Control Protocol）协议是一种面向连接、可靠的传输协议。TCP协议头部有20个字节，其中包括以下字段：</p><ul><li>源端口号（16位）：指发送端口的端口号。</li><li>目的端口号（16位）：指接收端口的端口号。</li><li>序列号（32位）：是一个32位的无符号整数，表示在当前连接中传输的第一个数据字节的序号。</li><li>确认号（32位）：是一个32位的无符号整数，表示期望收到的下一个字节的序号。</li><li>数据偏移（4位）：指的是TCP头部中数据的起始位置。因为TCP头部的长度是可变的，所以需要这个字段来指定数据的起始位置。</li><li>保留（6位）：暂时保留，未使用。</li><li>控制位（6位）：TCP协议头部中最重要的字段，包含了6个控制位，分别为URG、ACK、PSH、RST、SYN和FIN。</li><li>窗口大小（16位）：表示接收端点的缓存大小，用来控制发送端点的发送速度。</li><li>校验和（16位）：用来检测TCP头部和数据的完整性。</li><li>紧急指针（16位）：只有在URG标志被设置时才有意义，表示紧急数据的偏移量。</li><li>选项（可变长度）：TCP头部的选项字段，长度可变。</li></ul><p>下面是TCP协议头部的位图：</p><div class="code-wrapper"><pre><code class="hljs bash"> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          Source Port          |       Destination Port        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                        Sequence Number                        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Acknowledgment Number                      |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  Data |           |U|A|P|R|S|F|                               || Offset| Reserved  |R|C|S|S|Y|I|            Window             ||       |           |G|K|H|T|N|N|                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           Checksum            |         Urgent Pointer        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Options                    |    Padding    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>以上是 TCP 协议字段位的详细解释和协议头部的位图。</p><ol><li><p>三次握手和四次挥手的过程及含义。</p><p> 三次握手是建立连接时使用的过程，四次挥手是断开连接时使用的过程。三次握手的过程为：</p><ul><li>客户端发送 SYN 报文，指明客户端的初始序列号。</li><li>服务器返回 SYN+ACK 报文，指明服务器的初始序列号和确认号。</li><li>客户端返回 ACK 报文，指明客户端的确认号。</li></ul><p> 四次挥手的过程为：</p><ul><li>客户端发送 FIN 报文，请求关闭连接。</li><li>服务器返回 ACK 报文，确认收到了客户端的 FIN 报文。</li><li>服务器发送 FIN 报文，请求关闭连接。</li><li>客户端返回 ACK 报文，确认收到了服务器的 FIN 报文。</li></ul></li><li><p>TCP 的拥塞控制算法有哪些？</p><p> TCP 的拥塞控制算法有四种，分别是：慢启动、拥塞避免、快重传和快恢复。</p><ul><li>慢启动：连接建立后，TCP 发送方先将拥塞窗口 cwnd 初始化为一个较小的值，然后在每个往返时间内将 cwnd 加倍，直到出现丢包或拥塞发生。</li><li>拥塞避免：当 cwnd 达到一个阈值（ssthresh）时，cwnd 的增长就减缓为每个往返时间内只增加一个 MSS。</li><li>快重传：当发送方连续收到 3 个重复的 ACK 报文时，就立即重传对方尚未收到的报文段，以避免超时重传。</li><li>快恢复：当出现拥塞丢包时，发送方将 ssthresh 和 cwnd 更新为当前值的一半，然后继续执行拥塞避免算法。</li></ul></li><li><p>TCP 和 UDP 的区别是什么？</p><p> TCP 和 UDP 都是传输层协议，但是它们有很大的区别。TCP 是面向连接的，可靠的传输协议，而 UDP 则是无连接的、不可靠的传输协议。具体来说，TCP 提供了以下特性：</p><ul><li>可靠性：TCP 使用应答机制来保证数据的可靠传输。</li><li>面向连接：TCP 在通信前需要建立连接，通信结束后需要断开连接。</li><li>流量控制和拥塞控制：TCP 通过滑动窗口和拥塞控制算法来控制数据的传输速率。</li></ul><p> UDP 则不提供以上的特性，它更加简单、轻量级，适合于一些对可靠性要求不高的场景，如在线游戏等。</p></li></ol><p>基于 TCP 协议封装新的应用层协议时，需要注意以下问题：</p><ol><li>大端小端问题：TCP 协议头中的一些字段是多字节的，不同机器对于多字节字段的存储方式有所不同。为了解决这个问题，可以使用网络字节序（也称为大端字节序）来表示多字节字段，即始终将高位字节放在低地址处。</li><li>粘包黏包问题：由于 TCP 协议是面向流的，而应用层协议通常是面向消息的，因此在发送端，需要将一个完整的消息拆分成多个 TCP 报文段发送，同时在接收端，需要将多个 TCP 报文段组装成一个完整的消息。为了解决这个问题，可以采用以下方法：<ul><li>消息长度标记法：在消息的开头加上一个固定长度的字段，表示整个消息的长度，接收端先读取这个字段，然后读取相应长度的数据，即为一个完整的消息。</li><li>分隔符法：在消息的结尾加上一个特定的分隔符，表示一个消息的结束，接收端一直读取数据，直到读到分隔符为止，即为一个完整的消息。</li><li>固定长度法：固定每个消息的长度，接收端先读取固定长度的数据，然后将其解析为一个完整的消息。</li></ul></li></ol><p>除此之外，还需要考虑数据完整性、安全性等问题，比如可以使用消息认证码（MAC）来保证数据完整性和认证，使用加密算法来保证数据的安全性。</p>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket 协议字段位详解</title>
    <link href="/2023/02/27/other/WebSocket%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/27/other/WebSocket%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="WebSocket-协议字段位详解"><a href="#WebSocket-协议字段位详解" class="headerlink" title="WebSocket 协议字段位详解"></a>WebSocket 协议字段位详解</h1><p>WebSocket 协议是一种基于 TCP 协议的应用层协议，它是为了解决 HTTP 协议的一些缺陷而设计的。WebSocket 协议头部有 2 个或 14 个字节，其中包括以下字段：</p><ul><li>FIN（1 位）：表示该数据帧是否为一帧的最后一部分。</li><li>RSV1, RSV2, RSV3（各 1 位）：保留位，目前未使用。</li><li>Opcode（4 位）：表示数据帧的类型，包括文本、二进制、关闭连接等。</li><li>Mask（1 位）：表示是否对数据进行掩码处理，防止数据在传输过程中被篡改。</li><li>Payload Length（7 位或 7 + 16 + 64 位）：表示数据负载的长度，如果长度小于 126，则使用 7 位来表示；如果长度大于等于 126，则使用 7 + 16 位或 7 + 16 + 64 位来表示。</li><li>Masking Key（0 或 4 字节）：掩码密钥，如果 Mask 位为 1，则需要使用掩码密钥对数据进行掩码处理。</li><li>Payload Data（可变长度）：表示数据帧的负载数据。</li></ul><p>下面是 WebSocket 协议头部的位图：</p><div class="code-wrapper"><pre><code class="hljs bash"> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len |    Extended payload length    ||I|S|S|S|  (4)  |A|     (7)     |             (16/64)           ||N|V|V|V|       |S|             |   (<span class="hljs-keyword">if</span> payload len==126/127)   || |1|2|3|       |K|             |                               |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +|     Extended payload length continued, <span class="hljs-keyword">if</span> payload len == 127  |+ - - - - - - - - - - - - - - - +-------------------------------+|                               |Masking-key, <span class="hljs-keyword">if</span> MASK <span class="hljs-built_in">set</span> to 1  |+-------------------------------+-------------------------------+| Masking-key (continued)       |          Payload Data         |+-------------------------------- - - - - - - - - - - - - - - - +:                     Payload Data continued ...                :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +|                     Payload Data continued ...                |+---------------------------------------------------------------+</code></pre></div><p>以上是 WebSocket 协议字段位的详细解释和协议头部的位图。</p>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UDP 协议字段位详解</title>
    <link href="/2023/02/27/other/UDP%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/27/other/UDP%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="UDP-协议字段位详解"><a href="#UDP-协议字段位详解" class="headerlink" title="UDP 协议字段位详解"></a>UDP 协议字段位详解</h1><p>UDP（User Datagram Protocol）是一种无连接的基于 IP 协议的传输层协议，与TCP相比，UDP协议具有传输速度快、实时性强等优点。在UDP协议中，数据被分割成数据报，每个数据报都包含了一些字段。下面是UDP协议每个字段位的详解：</p><ul><li>**源端口(Source Port)**：这个字段占用16个比特位，表示发送端口号。它是在UDP报文中标识发送方应用程序的端口号，用于接收方回复信息时确定回复的是哪个端口。</li><li>**目的端口(Destination Port)**：这个字段占用16个比特位，表示接收端口号。它是在UDP报文中标识接收方应用程序的端口号，用于接收发送方发送的信息。</li><li>**长度(Length)**：这个字段占用16个比特位，表示UDP数据报的长度。它表示整个数据报的长度，包括UDP报头和UDP数据。</li><li>**校验和(Checksum)**：这个字段占用16个比特位，表示UDP数据报的校验和。它用于检验UDP数据报在传输过程中是否发生了错误。</li></ul><p>下面是UDP协议的字段位图：</p><div class="code-wrapper"><pre><code class="hljs bash"> 0      7 8     15 16    23 24    31+--------+--------+--------+--------+|     源端口号     |     目的端口号    |+--------+--------+--------+--------+|           长度             |校验和  |+--------+--------+--------+--------+|              数据           ....   |+--------+--------+--------+--------+</code></pre></div><p>以上是UDP协议每个字段位的详解和协议位图。</p><p>UDP协议是一种无连接的传输层协议。在UDP协议中，数据被分割成数据报，每个数据报都包含了一些字段。UDP协议具有传输速度快、实时性强等优点，但是不保证可靠性和数据的有序性。UDP对传输的数据没有任何担保，只是尽力去传输。当数据丢失或者出现错误时，UDP不会进行重传或者纠错。因此，UDP适用于数据量小、对可靠性要求不高的场景，例如在线游戏、实时视频和音频传输等。</p>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP 协议字段位详解</title>
    <link href="/2023/02/27/other/IP-%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/27/other/IP-%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="IP-协议字段位详解"><a href="#IP-协议字段位详解" class="headerlink" title="IP 协议字段位详解"></a>IP 协议字段位详解</h1><p>IP（Internet Protocol）协议是互联网的核心协议之一，它负责将网络层的数据包从源地址传输到目的地址。在IP数据包中，有许多字段用于描述数据包的内容和传输信息。下面将详细介绍IP协议中每个字段位的含义和作用。</p><h2 id="IP协议位图"><a href="#IP协议位图" class="headerlink" title="IP协议位图"></a>IP协议位图</h2><p>以下是IP协议的位图表示，其中包括了每个字段位的位置和长度：</p><div class="code-wrapper"><pre><code class="hljs bash">0                   1                   2                   30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version|  IHL  |Type of Service|          Total Length         |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|         Identification        |Flags|      Fragment Offset    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  Time to Live |    Protocol   |         Header Checksum       |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                       Source Address                          |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Destination Address                        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Options                    |    Padding    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><h2 id="IP协议字段位详解"><a href="#IP协议字段位详解" class="headerlink" title="IP协议字段位详解"></a>IP协议字段位详解</h2><h3 id="Version（版本）"><a href="#Version（版本）" class="headerlink" title="Version（版本）"></a>Version（版本）</h3><p>该字段占4位，用于指定IP协议版本号。当前IP协议版本为IPv4，其版本号为4。</p><h3 id="IHL（报头长度）"><a href="#IHL（报头长度）" class="headerlink" title="IHL（报头长度）"></a>IHL（报头长度）</h3><p>该字段占4位，用于指定IP数据包报头的长度，以32位字长为单位。因此，IHL字段的值是4的倍数。最小值为5，最大值为15。</p><h3 id="Type-of-Service（服务类型）"><a href="#Type-of-Service（服务类型）" class="headerlink" title="Type of Service（服务类型）"></a>Type of Service（服务类型）</h3><p>该字段占8位，用于指定IP数据包的服务类型。其中，前3位为优先级，后5位为服务类型。该字段已被DSCP所取代。</p><h3 id="Total-Length（总长度）"><a href="#Total-Length（总长度）" class="headerlink" title="Total Length（总长度）"></a>Total Length（总长度）</h3><p>该字段占16位，用于指定IP数据包的总长度，以字节为单位。该长度包括IP数据包的报头和数据负载。</p><h3 id="Identification（标识）"><a href="#Identification（标识）" class="headerlink" title="Identification（标识）"></a>Identification（标识）</h3><p>该字段占16位，用于标识IP数据包的唯一标识符。每个IP数据包都应该有一个唯一的标识符。</p><h3 id="Flags（标志）"><a href="#Flags（标志）" class="headerlink" title="Flags（标志）"></a>Flags（标志）</h3><p>该字段占3位，用于指定IP数据包的分片信息。其中，第1位为Reserved，第2位为Don’t Fragment（DF），第3位为More Fragments（MF）。</p><h3 id="Fragment-Offset（分片偏移）"><a href="#Fragment-Offset（分片偏移）" class="headerlink" title="Fragment Offset（分片偏移）"></a>Fragment Offset（分片偏移）</h3><p>该字段占13位，用于指定IP数据包在分片后的偏移量，以8字节为单位。该字段只在MF标志位被设置时有效。</p><h3 id="Time-to-Live（生存时间）"><a href="#Time-to-Live（生存时间）" class="headerlink" title="Time to Live（生存时间）"></a>Time to Live（生存时间）</h3><p>该字段占8位，用于指定IP数据包在网络中的生存时间。每次经过一个路由器，该字段的值就会减1，当该字段的值为0时，数据包将被丢弃。</p><h3 id="Protocol（协议）"><a href="#Protocol（协议）" class="headerlink" title="Protocol（协议）"></a>Protocol（协议）</h3><p>该字段占8位，用于指定IP数据包中的上层协议类型。常见的协议类型有TCP、UDP和ICMP等。</p><h3 id="Header-Checksum（报头校验和）"><a href="#Header-Checksum（报头校验和）" class="headerlink" title="Header Checksum（报头校验和）"></a>Header Checksum（报头校验和）</h3><p>该字段占16位，用于校验IP数据包报头的正确性。校验和的计算方法是将报头中的每个16位字加起来，再将结果按位取反。</p><h3 id="Source-Address（源地址）"><a href="#Source-Address（源地址）" class="headerlink" title="Source Address（源地址）"></a>Source Address（源地址）</h3><p>该字段占32位，用于指定IP数据包的源地址。</p><h3 id="Destination-Address（目的地址）"><a href="#Destination-Address（目的地址）" class="headerlink" title="Destination Address（目的地址）"></a>Destination Address（目的地址）</h3><p>该字段占32位，用于指定IP数据包的目的地址。</p><h3 id="Options（选项）"><a href="#Options（选项）" class="headerlink" title="Options（选项）"></a>Options（选项）</h3><p>该字段占变长，用于在IP数据包中添加一些可选的信息，如记录路径、时间戳等。如果该字段不存在，则用0填充。</p><h3 id="Padding（填充）"><a href="#Padding（填充）" class="headerlink" title="Padding（填充）"></a>Padding（填充）</h3><p>该字段占变长，用于将Options字段的长度补齐成4的倍数。如果Options字段的长度已经是4的倍数，则Padding字段不存在。</p><p>以上是IP协议中每个字段位的详细解释，了解这些字段的作用可以帮助我们更好地理解IP数据包的结构和传输过程。</p><p>如果我们要发送一个IP数据包，那么我们需要填写这些字段，并将它们放入数据包中。在数据包传输过程中，这些字段会被路由器等网络设备读取和处理，以确定数据包的发送和转发路径。</p><p>需要注意的是，IP数据包在传输过程中可能会被分片。当数据包的长度超过网络设备的MTU（最大传输单元）时，它就会被分成多个小片，以便在网络中传输。分片后的数据包会在每个数据包的头部添加分片偏移和标志等信息，以便在目的地将它们重新组装成原始数据包。因此，在处理和发送IP数据包时，我们需要考虑到数据包的长度和MTU等因素。</p>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/02/26/other/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/26/other/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法是计算机科学中经典的问题之一。它的目的是将一组数据按照指定的顺序进行排列。这里将介绍常见的几种排序算法及其时间复杂度和空间复杂度分析。</p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序是最基本的排序算法之一，它的基本思想是将相邻的元素两两比较，将较大的元素向后移动。时间复杂度为O(n^2)，空间复杂度为O(1)。</p><ul><li>最优情况：输入数组已经按照从小到大的顺序排好了，此时时间复杂度为O(n)。</li><li>最坏情况：输入数组按照从大到小的顺序排列，此时时间复杂度为O(n^2)。</li></ul><p>Swift5示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>]) &#123;    <span class="hljs-keyword">guard</span> array.count <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>array.count &#123;        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>array.count<span class="hljs-operator">-</span>i &#123;            <span class="hljs-keyword">if</span> array[j<span class="hljs-operator">-</span><span class="hljs-number">1</span>] <span class="hljs-operator">&gt;</span> array[j] &#123;                array.swapAt(j<span class="hljs-operator">-</span><span class="hljs-number">1</span>, j)            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序是一种简单直观的排序算法，它的基本思想是每次从未排序的数组中选择最小的元素，然后将其放到已排序的数组的末尾。时间复杂度为O(n^2)，空间复杂度为O(1)。</p><ul><li>最优情况和最坏情况的时间复杂度均为O(n^2)。</li></ul><p>Swift5示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>]) &#123;    <span class="hljs-keyword">guard</span> array.count <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>array.count<span class="hljs-operator">-</span><span class="hljs-number">1</span> &#123;        <span class="hljs-keyword">var</span> minIndex <span class="hljs-operator">=</span> i        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i<span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>array.count &#123;            <span class="hljs-keyword">if</span> array[j] <span class="hljs-operator">&lt;</span> array[minIndex] &#123;                minIndex <span class="hljs-operator">=</span> j            &#125;        &#125;        <span class="hljs-keyword">if</span> i <span class="hljs-operator">!=</span> minIndex &#123;            array.swapAt(i, minIndex)        &#125;    &#125;&#125;</code></pre></div><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>插入排序是一种简单直观的排序算法，它的基本思想是将未排序的元素插入到已排序的数组中。时间复杂度为O(n^2)，空间复杂度为O(1)。</p><ul><li>最优情况：输入数组已经按照从小到大的顺序排好了，此时时间复杂度为O(n)。</li><li>最坏情况：输入数组按照从大到小的顺序排列，此时时间复杂度为O(n^2)。</li></ul><p>Swift5示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>]) &#123;    <span class="hljs-keyword">guard</span> array.count <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>array.count &#123;        <span class="hljs-keyword">var</span> j <span class="hljs-operator">=</span> i        <span class="hljs-keyword">let</span> temp <span class="hljs-operator">=</span> array[j]        <span class="hljs-keyword">while</span> j <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> temp <span class="hljs-operator">&lt;</span> array[j<span class="hljs-operator">-</span><span class="hljs-number">1</span>] &#123;            array[j] <span class="hljs-operator">=</span> array[j<span class="hljs-operator">-</span><span class="hljs-number">1</span>]            j <span class="hljs-operator">-=</span> <span class="hljs-number">1</span>        &#125;        array[j] <span class="hljs-operator">=</span> temp    &#125;&#125;</code></pre></div><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p>快速排序是一种常用的排序算法，它的基本思想是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分记录继续进行排序，直到整个序列有序。时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p><ul><li>最优情况：每次分区的中间元素恰好为数组的中位数，此时时间复杂度为O(n log n)。</li><li>最坏情况：每次分区的中间元素都是最小或最大的元素，此时时间复杂度为O(n^2)。</li></ul><p>Swift5示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">left</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">right</span>: <span class="hljs-type">Int</span>) &#123;    <span class="hljs-keyword">guard</span> left <span class="hljs-operator">&lt;</span> right <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">var</span> i <span class="hljs-operator">=</span> left    <span class="hljs-keyword">var</span> j <span class="hljs-operator">=</span> right    <span class="hljs-keyword">let</span> pivot <span class="hljs-operator">=</span> array[(left<span class="hljs-operator">+</span>right)<span class="hljs-operator">/</span><span class="hljs-number">2</span>]    <span class="hljs-keyword">while</span> i <span class="hljs-operator">&lt;=</span> j &#123;        <span class="hljs-keyword">while</span> array[i] <span class="hljs-operator">&lt;</span> pivot &#123;            i <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">while</span> array[j] <span class="hljs-operator">&gt;</span> pivot &#123;            j <span class="hljs-operator">-=</span> <span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">if</span> i <span class="hljs-operator">&lt;=</span> j &#123;            array.swapAt(i, j)            i <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>            j <span class="hljs-operator">-=</span> <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> left <span class="hljs-operator">&lt;</span> j &#123;        quickSort(<span class="hljs-operator">&amp;</span>array, left, j)    &#125;    <span class="hljs-keyword">if</span> i <span class="hljs-operator">&lt;</span> right &#123;        quickSort(<span class="hljs-operator">&amp;</span>array, i, right)    &#125;&#125;</code></pre></div><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p>归并排序是一种稳定的排序算法，它的基本思想是将待排序的数组分成若干个子序列，每个子序列都是有序的，然后再将子序列合并成一个有序的序列。时间复杂度为O(nlogn)，空间复杂度为O(n)。</p><ul><li>最优情况和最坏情况的时间复杂度均为O(n log n)。</li></ul><p>Swift5示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: [<span class="hljs-type">Int</span>]) -&gt; [<span class="hljs-type">Int</span>] &#123;    <span class="hljs-keyword">guard</span> array.count <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> array    &#125;    <span class="hljs-keyword">let</span> middleIndex <span class="hljs-operator">=</span> array.count <span class="hljs-operator">/</span> <span class="hljs-number">2</span>    <span class="hljs-keyword">let</span> leftArray <span class="hljs-operator">=</span> mergeSort(<span class="hljs-type">Array</span>(array[<span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>middleIndex]))    <span class="hljs-keyword">let</span> rightArray <span class="hljs-operator">=</span> mergeSort(<span class="hljs-type">Array</span>(array[middleIndex<span class="hljs-operator">..&lt;</span>array.count]))    <span class="hljs-keyword">return</span> merge(leftArray, rightArray)&#125;<span class="hljs-keyword">func</span> <span class="hljs-title function_">merge</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">left</span>: [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">right</span>: [<span class="hljs-type">Int</span>]) -&gt; [<span class="hljs-type">Int</span>] &#123;    <span class="hljs-keyword">var</span> leftIndex <span class="hljs-operator">=</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> rightIndex <span class="hljs-operator">=</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> orderedArray <span class="hljs-operator">=</span> [<span class="hljs-type">Int</span>]()    <span class="hljs-keyword">while</span> leftIndex <span class="hljs-operator">&lt;</span> left.count <span class="hljs-operator">&amp;&amp;</span> rightIndex <span class="hljs-operator">&lt;</span> right.count &#123;        <span class="hljs-keyword">if</span> left[leftIndex] <span class="hljs-operator">&lt;</span> right[rightIndex] &#123;            orderedArray.append(left[leftIndex])            leftIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> left[leftIndex] <span class="hljs-operator">&gt;</span> right[rightIndex] &#123;            orderedArray.append(right[rightIndex])            rightIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>        &#125; <span class="hljs-keyword">else</span> &#123;            orderedArray.append(left[leftIndex])            leftIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>            orderedArray.append(right[rightIndex])            rightIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">while</span> leftIndex <span class="hljs-operator">&lt;</span> left.count &#123;        orderedArray.append(left[leftIndex])        leftIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">while</span> rightIndex <span class="hljs-operator">&lt;</span> right.count &#123;        orderedArray.append(right[rightIndex])        rightIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> orderedArray&#125;</code></pre></div><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p>堆排序是一种基于堆结构的排序算法。它的基本思想是在待排序序列中建立一个堆，然后依次从堆中取出最大（最小）元素，将其放置到已排序序列的末尾，直到堆中没有元素。</p><p>堆排序算法的时间复杂度为O(n log n)，它的性能表现比大多数其他排序算法都要好。同时，它的实现也比较简单，只需要一个数组作为数据结构即可。</p><ul><li>最优情况和最坏情况的时间复杂度均为O(n log n)。</li></ul><p>Swift5实现堆排序的代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">heapSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">arr</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>]) &#123;    <span class="hljs-keyword">let</span> n <span class="hljs-operator">=</span> arr.count    <span class="hljs-comment">// 构建大根堆</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span><span class="hljs-operator">...</span>(n<span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-operator">-</span><span class="hljs-number">1</span>)).reversed() &#123;        heapify(<span class="hljs-operator">&amp;</span>arr, n, i)    &#125;    <span class="hljs-comment">// 从堆中取出元素，放置到已排序的序列中</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span><span class="hljs-operator">...</span>(n<span class="hljs-operator">-</span><span class="hljs-number">1</span>)).reversed() &#123;        arr.swapAt(<span class="hljs-number">0</span>, i)        heapify(<span class="hljs-operator">&amp;</span>arr, i, <span class="hljs-number">0</span>)    &#125;&#125;<span class="hljs-comment">// 调整堆</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">arr</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">n</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">i</span>: <span class="hljs-type">Int</span>) &#123;    <span class="hljs-keyword">var</span> largest <span class="hljs-operator">=</span> i    <span class="hljs-keyword">let</span> l <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> r <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> i <span class="hljs-operator">+</span> <span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> l <span class="hljs-operator">&lt;</span> n <span class="hljs-operator">&amp;&amp;</span> arr[l] <span class="hljs-operator">&gt;</span> arr[largest] &#123;        largest <span class="hljs-operator">=</span> l    &#125;    <span class="hljs-keyword">if</span> r <span class="hljs-operator">&lt;</span> n <span class="hljs-operator">&amp;&amp;</span> arr[r] <span class="hljs-operator">&gt;</span> arr[largest] &#123;        largest <span class="hljs-operator">=</span> r    &#125;    <span class="hljs-keyword">if</span> largest <span class="hljs-operator">!=</span> i &#123;        arr.swapAt(i, largest)        heapify(<span class="hljs-operator">&amp;</span>arr, n, largest)    &#125;&#125;</code></pre></div><p>这个函数接受一个整数数组作为参数，将数组进行堆排序。它首先构建一个大根堆，然后从堆中取出元素，放置到已排序的序列中。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>算法</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 常用的开发架构</title>
    <link href="/2023/02/25/ios/iOS-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/02/25/ios/iOS-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-常用的开发架构"><a href="#iOS-常用的开发架构" class="headerlink" title="iOS 常用的开发架构"></a>iOS 常用的开发架构</h1><p>在iOS开发中，常用的开发架构有MVC、MVVM和VIPER。下面将分别对这三种架构进行讲解。</p><h2 id="1-MVC架构"><a href="#1-MVC架构" class="headerlink" title="1. MVC架构"></a>1. MVC架构</h2><p>MVC是Model-View-Controller的缩写，是一种将应用程序分成三个核心部件的设计模式。</p><ul><li>Model：数据模型，封装了应用程序的数据以及操作数据的方法。</li><li>View：用户界面，展示数据以及与用户交互的界面。</li><li>Controller：控制器，协调Model和View之间的通信。</li></ul><h3 id="MVC-Swift-5-示例代码"><a href="#MVC-Swift-5-示例代码" class="headerlink" title="MVC Swift 5 示例代码"></a>MVC Swift 5 示例代码</h3><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// Model</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">age</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name        <span class="hljs-keyword">self</span>.age <span class="hljs-operator">=</span> age    &#125;&#125;<span class="hljs-comment">// View</span><span class="hljs-keyword">import</span> UIKit<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonView</span>: <span class="hljs-title class_">UIView</span> &#123;    <span class="hljs-keyword">let</span> nameLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">let</span> ageLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">frame</span>: <span class="hljs-type">CGRect</span>) &#123;        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(frame: frame)        nameLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        ageLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">60</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        <span class="hljs-keyword">self</span>.addSubview(nameLabel)        <span class="hljs-keyword">self</span>.addSubview(ageLabel)    &#125;    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init?</span>(<span class="hljs-params">coder</span>: <span class="hljs-type">NSCoder</span>) &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;init(coder:) has not been implemented&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">configure</span>(<span class="hljs-params">with</span> <span class="hljs-params">person</span>: <span class="hljs-type">Person</span>) &#123;        nameLabel.text <span class="hljs-operator">=</span> person.name        ageLabel.text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>(person.age)&quot;</span>    &#125;&#125;<span class="hljs-comment">// Controller</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonController</span> &#123;    <span class="hljs-keyword">let</span> person: <span class="hljs-type">Person</span>    <span class="hljs-keyword">let</span> personView: <span class="hljs-type">PersonView</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">person</span>: <span class="hljs-type">Person</span>, <span class="hljs-params">personView</span>: <span class="hljs-type">PersonView</span>) &#123;        <span class="hljs-keyword">self</span>.person <span class="hljs-operator">=</span> person        <span class="hljs-keyword">self</span>.personView <span class="hljs-operator">=</span> personView        <span class="hljs-keyword">self</span>.personView.configure(with: person)    &#125;&#125;</code></pre></div><h2 id="2-MVVM架构"><a href="#2-MVVM架构" class="headerlink" title="2. MVVM架构"></a>2. MVVM架构</h2><p>MVVM是Model-View-ViewModel的缩写，是在MVC架构的基础上发展而来的一种设计模式。</p><ul><li>Model：数据模型，封装了应用程序的数据以及操作数据的方法。</li><li>View：用户界面，展示数据以及与用户交互的界面。</li><li>ViewModel：作为View和Model之间的中间层，负责处理View的展示逻辑，将Model的数据转化为View需要的数据。</li></ul><h3 id="MVVM-Swift-5-示例代码"><a href="#MVVM-Swift-5-示例代码" class="headerlink" title="MVVM Swift 5 示例代码"></a>MVVM Swift 5 示例代码</h3><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// Model</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">age</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name        <span class="hljs-keyword">self</span>.age <span class="hljs-operator">=</span> age    &#125;&#125;<span class="hljs-comment">// ViewModel</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonViewModel</span> &#123;    <span class="hljs-keyword">var</span> person: <span class="hljs-type">Person</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">person</span>: <span class="hljs-type">Person</span>) &#123;        <span class="hljs-keyword">self</span>.person <span class="hljs-operator">=</span> person    &#125;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> person.name    &#125;    <span class="hljs-keyword">var</span> age: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>(person.age)&quot;</span>    &#125;&#125;<span class="hljs-comment">// View</span><span class="hljs-keyword">import</span> UIKit<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonView</span>: <span class="hljs-title class_">UIView</span> &#123;    <span class="hljs-keyword">let</span> nameLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">let</span> ageLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">PersonViewModel</span>? &#123;        <span class="hljs-keyword">didSet</span> &#123;            nameLabel.text <span class="hljs-operator">=</span> viewModel<span class="hljs-operator">?</span>.name            ageLabel.text <span class="hljs-operator">=</span> viewModel<span class="hljs-operator">?</span>.age        &#125;    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">frame</span>: <span class="hljs-type">CGRect</span>) &#123;        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(frame: frame)        nameLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        ageLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">60</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        <span class="hljs-keyword">self</span>.addSubview(nameLabel)        <span class="hljs-keyword">self</span>.addSubview(ageLabel)    &#125;    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init?</span>(<span class="hljs-params">coder</span>: <span class="hljs-type">NSCoder</span>) &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;init(coder:) has not been implemented&quot;</span>)    &#125;&#125;<span class="hljs-comment">// Controller</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonController</span> &#123;    <span class="hljs-keyword">let</span> personView: <span class="hljs-type">PersonView</span>    <span class="hljs-keyword">let</span> personViewModel: <span class="hljs-type">PersonViewModel</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">person</span>: <span class="hljs-type">Person</span>) &#123;        <span class="hljs-keyword">self</span>.personViewModel <span class="hljs-operator">=</span> <span class="hljs-type">PersonViewModel</span>(person: person)        <span class="hljs-keyword">self</span>.personView <span class="hljs-operator">=</span> <span class="hljs-type">PersonView</span>()        <span class="hljs-keyword">self</span>.personView.viewModel <span class="hljs-operator">=</span> personViewModel    &#125;&#125;</code></pre></div><h2 id="3-VIPER架构"><a href="#3-VIPER架构" class="headerlink" title="3. VIPER架构"></a>3. VIPER架构</h2><p>VIPER是View-Interactor-Presenter-Entity-Router的缩写，是一种通过将应用程序的逻辑分解成多个独立的模块来构建清晰、可扩展和易于维护的架构。</p><ul><li>View：用户界面，展示数据以及与用户交互的界面。</li><li>Interactor：业务逻辑层，负责处理业务逻辑。</li><li>Presenter：负责将Interactor返回的数据转化为View需要的数据。</li><li>Entity：数据模型，封装了应用程序的数据以及操作数据的方法。</li><li>Router：负责处理模块之间的跳转逻辑。</li></ul><h3 id="VIPER-Swift-5-示例代码"><a href="#VIPER-Swift-5-示例代码" class="headerlink" title="VIPER Swift 5 示例代码"></a>VIPER Swift 5 示例代码</h3><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// Entity</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">age</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name        <span class="hljs-keyword">self</span>.age <span class="hljs-operator">=</span> age    &#125;&#125;<span class="hljs-comment">// Interactor</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonInteractor</span> &#123;    <span class="hljs-keyword">var</span> person: <span class="hljs-type">Person</span>?    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchPerson</span>() -&gt; <span class="hljs-type">Person</span> &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> person <span class="hljs-operator">=</span> person &#123;            <span class="hljs-keyword">return</span> person        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">let</span> person <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>(name: <span class="hljs-string">&quot;Tom&quot;</span>, age: <span class="hljs-number">18</span>)            <span class="hljs-keyword">self</span>.person <span class="hljs-operator">=</span> person            <span class="hljs-keyword">return</span> person        &#125;    &#125;&#125;<span class="hljs-comment">// Presenter</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonPresenter</span> &#123;    <span class="hljs-keyword">var</span> person: <span class="hljs-type">Person</span>?    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> view: <span class="hljs-type">PersonView</span>?    <span class="hljs-keyword">let</span> interactor <span class="hljs-operator">=</span> <span class="hljs-type">PersonInteractor</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchPerson</span>() &#123;        <span class="hljs-keyword">let</span> person <span class="hljs-operator">=</span> interactor.fetchPerson()        <span class="hljs-keyword">self</span>.person <span class="hljs-operator">=</span> person        view<span class="hljs-operator">?</span>.configure(with: person)    &#125;&#125;<span class="hljs-comment">// View</span><span class="hljs-keyword">import</span> UIKit<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonView</span>: <span class="hljs-title class_">UIView</span> &#123;    <span class="hljs-keyword">let</span> nameLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">let</span> ageLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">var</span> presenter: <span class="hljs-type">PersonPresenter</span>?    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">frame</span>: <span class="hljs-type">CGRect</span>) &#123;        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(frame: frame)        nameLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        ageLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">60</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        <span class="hljs-keyword">self</span>.addSubview(nameLabel)        <span class="hljs-keyword">self</span>.addSubview(ageLabel)    &#125;    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init?</span>(<span class="hljs-params">coder</span>: <span class="hljs-type">NSCoder</span>) &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;init(coder:) has not been implemented&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">configure</span>(<span class="hljs-params">with</span> <span class="hljs-params">person</span>: <span class="hljs-type">Person</span>) &#123;        nameLabel.text <span class="hljs-operator">=</span> person.name        ageLabel.text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>(person.age)&quot;</span>    &#125;&#125;<span class="hljs-comment">// Router</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonRouter</span> &#123;&#125;<span class="hljs-comment">// Controller</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonController</span> &#123;    <span class="hljs-keyword">let</span> personView <span class="hljs-operator">=</span> <span class="hljs-type">PersonView</span>()    <span class="hljs-keyword">let</span> personPresenter <span class="hljs-operator">=</span> <span class="hljs-type">PersonPresenter</span>()    <span class="hljs-keyword">let</span> personRouter <span class="hljs-operator">=</span> <span class="hljs-type">PersonRouter</span>()    <span class="hljs-keyword">init</span>() &#123;        personPresenter.view <span class="hljs-operator">=</span> personView        personView.presenter <span class="hljs-operator">=</span> personPresenter    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>设计模式</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24 种设计模式-1 (Swift 5版)</title>
    <link href="/2023/02/25/other/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-Swift-5%E7%89%88/"/>
    <url>/2023/02/25/other/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-Swift-5%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h2><h3 id="1-简单工厂模式（Simple-Factory-Pattern）"><a href="#1-简单工厂模式（Simple-Factory-Pattern）" class="headerlink" title="1. 简单工厂模式（Simple Factory Pattern）"></a>1. 简单工厂模式（Simple Factory Pattern）</h3><p>简单工厂模式（Simple Factory Pattern）是一种创建型设计模式，它的主要目的是提供一个统一的接口来创建对象，而无需暴露具体的创建逻辑。该模式常用来解决创建对象时客户端代码需要知道所有可能被创建对象类的问题。</p><p>在简单工厂模式中，通常包括一个工厂类和多个产品类。工厂类根据客户端请求的参数来决定创建哪个产品类的对象，并返回给客户端。这样客户端就无需直接调用产品类的构造函数来创建对象了。</p><p>以下是一个使用简单工厂模式的示例代码：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 定义一个接口，所有产品类都要实现这个接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">use</span>()&#125;<span class="hljs-comment">// 具体的产品类实现 Product 接口</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span>: <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">use</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ProductA used&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductB</span>: <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">use</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ProductB used&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 简单工厂类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleFactory</span> &#123;    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ProductType</span> &#123;        <span class="hljs-keyword">case</span> <span class="hljs-type">A</span>, <span class="hljs-type">B</span>    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">createProduct</span>(<span class="hljs-params">type</span>: <span class="hljs-type">ProductType</span>) -&gt; <span class="hljs-type">Product</span> &#123;        <span class="hljs-keyword">switch</span> type &#123;        <span class="hljs-keyword">case</span> .<span class="hljs-type">A</span>:            <span class="hljs-keyword">return</span> <span class="hljs-type">ProductA</span>()        <span class="hljs-keyword">case</span> .<span class="hljs-type">B</span>:            <span class="hljs-keyword">return</span> <span class="hljs-type">ProductB</span>()        &#125;    &#125;&#125;<span class="hljs-comment">// 客户端代码</span><span class="hljs-keyword">let</span> productA <span class="hljs-operator">=</span> <span class="hljs-type">SimpleFactory</span>.createProduct(type: .<span class="hljs-type">A</span>)productA.use() <span class="hljs-comment">// 输出: &quot;ProductA used&quot;</span><span class="hljs-keyword">let</span> productB <span class="hljs-operator">=</span> <span class="hljs-type">SimpleFactory</span>.createProduct(type: .<span class="hljs-type">B</span>)productB.use() <span class="hljs-comment">// 输出: &quot;ProductB used&quot;</span></code></pre></div></li></ul><p>在上面的示例代码中，**<code>Product</code>** 定义了一个使用产品的接口。**<code>ProductA</code>** 和 <strong><code>ProductB</code></strong> 是具体的产品类，它们都实现了 <strong><code>Product</code></strong> 接口。**<code>SimpleFactory</code>** 是简单工厂类，它根据客户端请求的参数来创建不同的产品类的对象，然后返回给客户端。最后，客户端通过调用返回的对象的 <strong><code>use</code></strong> 方法来使用产品。</p><h3 id="2-抽象工厂模式（Abstract-Factory-Pattern）"><a href="#2-抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="2. 抽象工厂模式（Abstract Factory Pattern）"></a>2. 抽象工厂模式（Abstract Factory Pattern）</h3><p>抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一种创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。这种模式属于对象创建型模式，它解决了在不指定对象具体类的情况下创建一系列相关或相互依赖的对象问题。</p><p>抽象工厂模式通常用于以下场景：</p><ul><li>一个系统要独立于它的产品的创建、组合和表示时</li><li>一个系统要由多个产品系列中的一个来配置时</li><li>强调一系列相关的产品对象的设计以便进行联合使用时</li><li>提供一个产品类库，只想显示它的接口而不是实现时</li></ul><p>下面是一个简单的 Swift 5 示例，展示了如何使用抽象工厂模式创建和使用不同系列的产品对象。假设我们需要创建一组不同的计算机，每台计算机包含 CPU 和主板，分为 Intel 和 AMD 两个系列。我们可以定义一个 <strong><code>AbstractFactory</code></strong> 协议，其中包含了创建 CPU 和主板的两个方法，然后定义两个具体的工厂类 <strong><code>IntelFactory</code></strong> 和 <strong><code>AMDFactory</code></strong> 分别实现该协议，以便创建相应系列的产品。最后，我们可以在客户端中使用工厂对象来创建所需的产品。</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 抽象产品协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">CPU</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;&#125;<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Motherboard</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;&#125;<span class="hljs-comment">// 抽象工厂协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AbstractFactory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createCPU</span>() -&gt; <span class="hljs-type">CPU</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createMotherboard</span>() -&gt; <span class="hljs-type">Motherboard</span>&#125;<span class="hljs-comment">// 具体产品</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCPU</span>: <span class="hljs-title class_">CPU</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Intel CPU&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelMotherboard</span>: <span class="hljs-title class_">Motherboard</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Intel Motherboard&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AMDCPU</span>: <span class="hljs-title class_">CPU</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;AMD CPU&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AMDMotherboard</span>: <span class="hljs-title class_">Motherboard</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;AMD Motherboard&quot;</span>    &#125;&#125;<span class="hljs-comment">// 具体工厂</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelFactory</span>: <span class="hljs-title class_">AbstractFactory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createCPU</span>() -&gt; <span class="hljs-type">CPU</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">IntelCPU</span>()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createMotherboard</span>() -&gt; <span class="hljs-type">Motherboard</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">IntelMotherboard</span>()    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AMDFactory</span>: <span class="hljs-title class_">AbstractFactory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createCPU</span>() -&gt; <span class="hljs-type">CPU</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">AMDCPU</span>()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createMotherboard</span>() -&gt; <span class="hljs-type">Motherboard</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">AMDMotherboard</span>()    &#125;&#125;<span class="hljs-comment">// 客户端代码</span><span class="hljs-keyword">let</span> intelFactory <span class="hljs-operator">=</span> <span class="hljs-type">IntelFactory</span>()<span class="hljs-keyword">let</span> amdFactory <span class="hljs-operator">=</span> <span class="hljs-type">AMDFactory</span>()<span class="hljs-keyword">let</span> intelCPU <span class="hljs-operator">=</span> intelFactory.createCPU()<span class="hljs-keyword">let</span> intelMotherboard <span class="hljs-operator">=</span> intelFactory.createMotherboard()<span class="hljs-keyword">let</span> amdCPU <span class="hljs-operator">=</span> amdFactory.createCPU()<span class="hljs-keyword">let</span> amdMotherboard <span class="hljs-operator">=</span> amdFactory.createMotherboard()<span class="hljs-built_in">print</span>(intelCPU.name) <span class="hljs-comment">// 输出: Intel CPU</span><span class="hljs-built_in">print</span>(intelMotherboard.name) <span class="hljs-comment">// 输出: Intel Motherboard</span><span class="hljs-built_in">print</span>(amdCPU.name) <span class="hljs-comment">// 输出: AMD CPU</span><span class="hljs-built_in">print</span>(amdMotherboard.name) <span class="hljs-comment">// 输出: AMD Motherboard</span></code></pre></div></li></ul><h3 id="3-工厂方法模式（Factory-Method-Pattern）"><a href="#3-工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="3. 工厂方法模式（Factory Method Pattern）"></a>3. 工厂方法模式（Factory Method Pattern）</h3><p>工厂方法模式（Factory Method Pattern）是一种常用的创建型设计模式，它定义了一个用于创建对象的接口，但是让子类决定将哪一个类实例化，工厂方法模式让一个类的实例化延迟到其子类。</p><p>工厂方法模式可以很好地解决创建对象的问题，可以避免直接使用 <strong><code>new</code></strong> 这种方式创建对象，而是通过工厂方法来创建对象，这样可以避免代码中的耦合问题，增强代码的可扩展性和可维护性。</p><p>下面是一个使用 Swift 5 实现工厂方法模式的示例代码：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 抽象产品</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;&#125;<span class="hljs-comment">// 具体产品 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span>: <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product A&quot;</span> &#125;&#125;<span class="hljs-comment">// 具体产品 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductB</span>: <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product B&quot;</span> &#125;&#125;<span class="hljs-comment">// 抽象工厂</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Factory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createProduct</span>() -&gt; <span class="hljs-type">Product</span>&#125;<span class="hljs-comment">// 具体工厂 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryA</span>: <span class="hljs-title class_">Factory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createProduct</span>() -&gt; <span class="hljs-type">Product</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">ProductA</span>()    &#125;&#125;<span class="hljs-comment">// 具体工厂 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryB</span>: <span class="hljs-title class_">Factory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createProduct</span>() -&gt; <span class="hljs-type">Product</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">ProductB</span>()    &#125;&#125;<span class="hljs-comment">// 客户端代码</span><span class="hljs-keyword">let</span> factoryA <span class="hljs-operator">=</span> <span class="hljs-type">FactoryA</span>()<span class="hljs-keyword">let</span> factoryB <span class="hljs-operator">=</span> <span class="hljs-type">FactoryB</span>()<span class="hljs-keyword">let</span> productA <span class="hljs-operator">=</span> factoryA.createProduct()<span class="hljs-keyword">let</span> productB <span class="hljs-operator">=</span> factoryB.createProduct()<span class="hljs-built_in">print</span>(productA.name) <span class="hljs-comment">// &quot;Product A&quot;</span><span class="hljs-built_in">print</span>(productB.name) <span class="hljs-comment">// &quot;Product B&quot;</span></code></pre></div></li></ul><p>在这个示例代码中，我们定义了一个 <strong><code>Product</code></strong> 协议，其中包含一个 <strong><code>name</code></strong> 属性，用于表示产品的名称。然后，我们定义了两个具体产品 <strong><code>ProductA</code></strong> 和 **<code>ProductB</code>**，它们分别实现了 <strong><code>Product</code></strong> 协议。</p><p>接着，我们定义了一个 <strong><code>Factory</code></strong> 协议，其中包含一个 <strong><code>createProduct</code></strong> 方法，用于创建产品。然后，我们定义了两个具体工厂 <strong><code>FactoryA</code></strong> 和 **<code>FactoryB</code>**，它们分别实现了 <strong><code>Factory</code></strong> 协议，用于创建不同的产品。</p><p>最后，在客户端代码中，我们实例化了两个具体工厂 <strong><code>factoryA</code></strong> 和 **<code>factoryB</code>**，然后使用它们的 <strong><code>createProduct</code></strong> 方法来创建具体产品 <strong><code>productA</code></strong> 和 **<code>productB</code>**。通过这种方式，我们可以避免在客户端代码中直接使用 <strong><code>new</code></strong> 来创建对象，而是通过工厂方法来创建对象，从而提高了代码的可扩展性和可维护性。</p><h3 id="4-建造者模式（Builder-Pattern）"><a href="#4-建造者模式（Builder-Pattern）" class="headerlink" title="4. 建造者模式（Builder Pattern）"></a>4. 建造者模式（Builder Pattern）</h3><p>建造者模式（Builder Pattern）是一种创建型设计模式，它允许你创建复杂的对象，同时将其构造过程与表示分离。使用建造者模式可以将一个复杂对象的构建过程和表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式适用于以下情况：</p><ul><li>当需要创建的对象具有复杂的内部结构时，可以使用建造者模式将构造方法的调用顺序与属性的设置分离，从而降低代码的复杂度。</li><li>当需要构建不同属性的对象时，可以使用建造者模式来创建不同的属性组合。</li></ul><p>以下是使用 Swift 5 实现建造者模式的示例代码：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// Product</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pizza</span> &#123;    <span class="hljs-keyword">var</span> dough: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">var</span> sauce: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">var</span> toppings: [<span class="hljs-type">String</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">func</span> <span class="hljs-title function_">showPizza</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Pizza with <span class="hljs-subst">\(dough)</span> dough, <span class="hljs-subst">\(sauce)</span> sauce and toppings: <span class="hljs-subst">\(toppings.joined(separator: <span class="hljs-string">&quot;, &quot;</span>))</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// Builder</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">PizzaBuilder</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addDough</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addSauce</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addToppings</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getPizza</span>() -&gt; <span class="hljs-type">Pizza</span>&#125;<span class="hljs-comment">// Concrete Builder</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MargheritaPizzaBuilder</span>: <span class="hljs-title class_">PizzaBuilder</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> pizza <span class="hljs-operator">=</span> <span class="hljs-type">Pizza</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addDough</span>() &#123;        pizza.dough <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Thin crust&quot;</span>    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addSauce</span>() &#123;        pizza.sauce <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Tomato sauce&quot;</span>    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addToppings</span>() &#123;        pizza.toppings <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;Mozzarella cheese&quot;</span>, <span class="hljs-string">&quot;Basil leaves&quot;</span>]    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getPizza</span>() -&gt; <span class="hljs-type">Pizza</span> &#123;        <span class="hljs-keyword">return</span> pizza    &#125;&#125;<span class="hljs-comment">// Director</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PizzaDirector</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> builder: <span class="hljs-type">PizzaBuilder</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">builder</span>: <span class="hljs-type">PizzaBuilder</span>) &#123;        <span class="hljs-keyword">self</span>.builder <span class="hljs-operator">=</span> builder    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makePizza</span>() -&gt; <span class="hljs-type">Pizza</span> &#123;        builder.addDough()        builder.addSauce()        builder.addToppings()        <span class="hljs-keyword">return</span> builder.getPizza()    &#125;&#125;<span class="hljs-comment">// Client code</span><span class="hljs-keyword">let</span> margheritaBuilder <span class="hljs-operator">=</span> <span class="hljs-type">MargheritaPizzaBuilder</span>()<span class="hljs-keyword">let</span> pizzaDirector <span class="hljs-operator">=</span> <span class="hljs-type">PizzaDirector</span>(builder: margheritaBuilder)<span class="hljs-keyword">let</span> margheritaPizza <span class="hljs-operator">=</span> pizzaDirector.makePizza()margheritaPizza.showPizza()</code></pre></div></li></ul><p>在这个示例中，**<code>Pizza</code>** 是我们要创建的复杂对象，而 <strong><code>PizzaBuilder</code></strong> 协议定义了建造者应该具备的方法，包括添加面团、酱料和配料等。 <strong><code>MargheritaPizzaBuilder</code></strong> 是建造者的具体实现，它实现了 <strong><code>PizzaBuilder</code></strong> 协议中的方法，用于构建玛格丽特比萨。**<code>PizzaDirector</code>** 类负责管理建造者的调用顺序，它根据特定的建造者构建产品。最后，客户端代码使用建造者和指挥者来构建产品并将其展示出来。</p><h3 id="5-原型模式（Prototype-Pattern）"><a href="#5-原型模式（Prototype-Pattern）" class="headerlink" title="5. 原型模式（Prototype Pattern）"></a>5. 原型模式（Prototype Pattern）</h3><p>原型模式（Prototype Pattern）是一种创建型设计模式，它允许通过复制现有对象来创建新对象，而不必通过标准构造函数创建。该模式需要实现一个克隆方法，该方法克隆原型对象并返回副本。这使得客户端能够生成新对象，同时保留原始对象的状态。</p><p>原型模式通常用于创建复杂的对象，这些对象的创建过程比简单的构造函数调用要复杂得多。通常，创建这些对象需要许多步骤和复杂的算法，这些算法需要大量的计算和资源。在这种情况下，使用原型模式可以更有效地生成新对象，因为不需要在每次创建对象时重新计算它们。</p><p>下面是一个使用原型模式的简单示例，其中我们将克隆现有汽车对象以创建新对象。首先，我们需要创建一个“Car”协议，并实现克隆方法：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Car</span>: <span class="hljs-title class_">AnyObject</span>, <span class="hljs-title class_">NSCopying</span> &#123;    <span class="hljs-keyword">var</span> model: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;    <span class="hljs-keyword">var</span> color: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;&#125;<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Car</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">with</span> <span class="hljs-params">zone</span>: <span class="hljs-type">NSZone</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>) -&gt; <span class="hljs-keyword">Any</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">CarPrototype</span>(model: model, color: color, price: price)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CarPrototype</span>: <span class="hljs-title class_">Car</span> &#123;    <span class="hljs-keyword">var</span> model: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> color: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">model</span>: <span class="hljs-type">String</span>, <span class="hljs-params">color</span>: <span class="hljs-type">String</span>, <span class="hljs-params">price</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.model <span class="hljs-operator">=</span> model        <span class="hljs-keyword">self</span>.color <span class="hljs-operator">=</span> color        <span class="hljs-keyword">self</span>.price <span class="hljs-operator">=</span> price    &#125;&#125;</code></pre></div><p>在上面的代码中，我们定义了“Car”协议，并使用“CarPrototype”类实现了该协议。我们还使用“NSCopying”协议为该类提供了克隆方法。</p><p>接下来，我们将创建一个“CarFactory”类，该类将提供一些现有汽车对象，供客户端使用克隆方法生成新对象：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarFactory</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> prototypes <span class="hljs-operator">=</span> [<span class="hljs-type">String</span>: <span class="hljs-type">Car</span>]()    <span class="hljs-keyword">init</span>() &#123;        prototypes[<span class="hljs-string">&quot;SUV&quot;</span>] <span class="hljs-operator">=</span> <span class="hljs-type">CarPrototype</span>(model: <span class="hljs-string">&quot;SUV&quot;</span>, color: <span class="hljs-string">&quot;Red&quot;</span>, price: <span class="hljs-number">50000</span>)        prototypes[<span class="hljs-string">&quot;Coupe&quot;</span>] <span class="hljs-operator">=</span> <span class="hljs-type">CarPrototype</span>(model: <span class="hljs-string">&quot;Coupe&quot;</span>, color: <span class="hljs-string">&quot;Blue&quot;</span>, price: <span class="hljs-number">80000</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createCar</span>(<span class="hljs-params">ofType</span> <span class="hljs-params">type</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Car</span>? &#123;        <span class="hljs-keyword">return</span> prototypes[type]<span class="hljs-operator">?</span>.copy() <span class="hljs-keyword">as?</span> <span class="hljs-type">Car</span>    &#125;&#125;</code></pre></div><p>在上面的代码中，我们使用“prototypes”字典来存储现有的汽车对象。客户端可以使用“createCar(ofType:)”方法来获取现有汽车对象的副本，并生成新对象。</p><p>下面是一个示例，演示如何使用“CarFactory”类生成新的汽车对象：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> factory <span class="hljs-operator">=</span> <span class="hljs-type">CarFactory</span>()<span class="hljs-keyword">let</span> suv1 <span class="hljs-operator">=</span> factory.createCar(ofType: <span class="hljs-string">&quot;SUV&quot;</span>)<span class="hljs-keyword">let</span> suv2 <span class="hljs-operator">=</span> factory.createCar(ofType: <span class="hljs-string">&quot;SUV&quot;</span>)suv1<span class="hljs-operator">?</span>.model <span class="hljs-comment">// SUV</span>suv1<span class="hljs-operator">?</span>.color <span class="hljs-comment">// Red</span>suv1<span class="hljs-operator">?</span>.price <span class="hljs-comment">// 50000</span>suv2<span class="hljs-operator">?</span>.model <span class="hljs-comment">// SUV</span>suv2<span class="hljs-operator">?</span>.color <span class="hljs-comment">// Red</span>suv2<span class="hljs-operator">?</span>.price <span class="hljs-comment">// 50000</span></code></pre></div><h3 id="6-单例模式（Singleton-Pattern）"><a href="#6-单例模式（Singleton-Pattern）" class="headerlink" title="6. 单例模式（Singleton Pattern）"></a>6. 单例模式（Singleton Pattern）</h3><p>单例模式（Singleton Pattern）是一种创建型模式，它保证一个类只有一个实例，并提供一个全局访问点。</p><p>单例模式的常见应用场景包括：</p><ul><li>对于某些类，我们只需要有一个实例，比如系统的日志管理器、线程池、数据库连接池等；</li><li>想要跨越多个模块访问某些数据，可以将数据存储在单例对象中，以便于跨模块访问。</li></ul><p>在 Swift 中，可以使用静态变量或全局变量来实现单例模式，也可以使用结构体来实现。</p><p>以下是一个使用静态变量实现单例模式的例子：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">Singleton</span>()    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() &#123;        <span class="hljs-comment">// 私有化初始化方法，避免在外部创建实例</span>    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">someMethod</span>() &#123;        <span class="hljs-comment">// 单例类的其他方法</span>    &#125;&#125;</code></pre></div><p>在上面的例子中，我们使用一个名为 <strong><code>shared</code></strong> 的静态变量来保存唯一的实例。**<code>shared</code>** 变量在第一次访问时会触发 <strong><code>Singleton</code></strong> 类的初始化方法，而由于该方法是私有的，因此无法从外部创建实例。其他的方法则可以通过 <strong><code>Singleton.shared</code></strong> 来访问。由于 Swift 的静态变量是线程安全的，因此该实现方式可以保证单例模式的正确性。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24 种设计模式-2 (Swift 5版)</title>
    <link href="/2023/02/25/other/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-Swift-5%E7%89%88/"/>
    <url>/2023/02/25/other/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-Swift-5%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="结构型模式（Structural-Patterns）"><a href="#结构型模式（Structural-Patterns）" class="headerlink" title="结构型模式（Structural Patterns）"></a>结构型模式（Structural Patterns）</h2><h3 id="1-适配器模式（Adapter-Pattern）"><a href="#1-适配器模式（Adapter-Pattern）" class="headerlink" title="1. 适配器模式（Adapter Pattern）"></a>1. 适配器模式（Adapter Pattern）</h3><p>适配器模式（Adapter Pattern）是一种结构型设计模式，用于将一个类的接口转换成客户端所期望的另一种接口。它允许两个不兼容的接口能够一起工作。</p><p>适配器模式常用来解决以下问题：</p><ol><li>系统需要复用一个已存在的类，但是其接口与系统所需要的接口不兼容。</li><li>不想修改现有的接口，但是需要创建一个新的类能够调用现有类的接口。</li><li>两个不兼容的类需要协同工作，但是不能直接修改它们的接口。</li></ol><p>在适配器模式中，适配器充当中间人角色，它接收来自客户端的请求并将其转换为被适配对象的请求。适配器模式可以分为两种类型：对象适配器和类适配器。对象适配器使用组合的方式连接适配器和被适配对象，类适配器使用继承的方式连接适配器和被适配对象。</p><p>以下是一个使用对象适配器的 Swift 5 代码示例，用于将一个高级音乐播放器的接口适配成一个简单音乐播放器的接口：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 被适配的高级音乐播放器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedMediaPlayer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">playVlc</span>(<span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Playing vlc file. Name: <span class="hljs-subst">\(fileName)</span>&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">playMp4</span>(<span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Playing mp4 file. Name: <span class="hljs-subst">\(fileName)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 简单音乐播放器的接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">MediaPlayer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>(<span class="hljs-params">audioType</span>: <span class="hljs-type">String</span>, <span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>)&#125;<span class="hljs-comment">// 对象适配器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MediaAdapter</span>: <span class="hljs-title class_">MediaPlayer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> advancedMediaPlayer: <span class="hljs-type">AdvancedMediaPlayer</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">advancedMediaPlayer</span>: <span class="hljs-type">AdvancedMediaPlayer</span>) &#123;        <span class="hljs-keyword">self</span>.advancedMediaPlayer <span class="hljs-operator">=</span> advancedMediaPlayer    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>(<span class="hljs-params">audioType</span>: <span class="hljs-type">String</span>, <span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">if</span> audioType <span class="hljs-operator">==</span> <span class="hljs-string">&quot;vlc&quot;</span> &#123;            advancedMediaPlayer.playVlc(fileName: fileName)        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> audioType <span class="hljs-operator">==</span> <span class="hljs-string">&quot;mp4&quot;</span> &#123;            advancedMediaPlayer.playMp4(fileName: fileName)        &#125;    &#125;&#125;<span class="hljs-comment">// 简单音乐播放器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AudioPlayer</span>: <span class="hljs-title class_">MediaPlayer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mediaAdapter: <span class="hljs-type">MediaAdapter</span>?    <span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>(<span class="hljs-params">audioType</span>: <span class="hljs-type">String</span>, <span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">if</span> audioType <span class="hljs-operator">==</span> <span class="hljs-string">&quot;mp3&quot;</span> &#123;            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Playing mp3 file. Name: <span class="hljs-subst">\(fileName)</span>&quot;</span>)        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> audioType <span class="hljs-operator">==</span> <span class="hljs-string">&quot;vlc&quot;</span> <span class="hljs-operator">||</span> audioType <span class="hljs-operator">==</span> <span class="hljs-string">&quot;mp4&quot;</span> &#123;            mediaAdapter <span class="hljs-operator">=</span> <span class="hljs-type">MediaAdapter</span>(advancedMediaPlayer: <span class="hljs-type">AdvancedMediaPlayer</span>())            mediaAdapter<span class="hljs-operator">?</span>.play(audioType: audioType, fileName: fileName)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Invalid media. <span class="hljs-subst">\(audioType)</span> format not supported&quot;</span>)        &#125;    &#125;&#125;</code></pre></div></li></ul><p>在上面的示例中，**<code>AdvancedMediaPlayer</code>** 是被适配的类，它的接口与 <strong><code>MediaPlayer</code></strong> 接口不兼容。**<code>MediaAdapter</code>** 是适配器，它使用组合的方式连接 <strong><code>AdvancedMediaPlayer</code></strong> 和 **<code>MediaPlayer</code>**，并将 <strong><code>AdvancedMediaPlayer</code></strong> </p><h3 id="2-桥接模式（Bridge-Pattern）"><a href="#2-桥接模式（Bridge-Pattern）" class="headerlink" title="2. 桥接模式（Bridge Pattern）"></a>2. 桥接模式（Bridge Pattern）</h3><p>桥接模式（Bridge Pattern）是一种结构型设计模式，用于将抽象部分与实现部分分离，使它们可以独立地变化，从而降低它们之间的耦合度。</p><p>桥接模式常用于需要多个不同平台、不同类型的类之间协同工作的场景，它能够通过将这些类的不同维度分离来实现这个目的，从而使得这些类可以在系统中独立地变化。</p><p>具体实现上，桥接模式通过在抽象层和实现层之间增加一个桥接接口（Bridge），来将抽象层和实现层分离。这个桥接接口通常包含了一些基本操作，而抽象层和实现层分别继承这个桥接接口，从而能够相互协作。</p><p>以下是一个使用桥接模式的 Swift 5 代码示例，其中将一个图形对象的绘制行为和图形类型进行分离：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 实现层</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Drawer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>)&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleDrawer</span>: <span class="hljs-title class_">Drawer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Draw Circle at (<span class="hljs-subst">\(x)</span>, <span class="hljs-subst">\(y)</span>) with radius <span class="hljs-subst">\(radius)</span>&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareDrawer</span>: <span class="hljs-title class_">Drawer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Draw Square at (<span class="hljs-subst">\(x)</span>, <span class="hljs-subst">\(y)</span>) with radius <span class="hljs-subst">\(radius)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 抽象层</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">let</span> x: <span class="hljs-type">Double</span>    <span class="hljs-keyword">let</span> y: <span class="hljs-type">Double</span>    <span class="hljs-keyword">let</span> radius: <span class="hljs-type">Double</span>    <span class="hljs-keyword">let</span> drawer: <span class="hljs-type">Drawer</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">drawer</span>: <span class="hljs-type">Drawer</span>) &#123;        <span class="hljs-keyword">self</span>.x <span class="hljs-operator">=</span> x        <span class="hljs-keyword">self</span>.y <span class="hljs-operator">=</span> y        <span class="hljs-keyword">self</span>.radius <span class="hljs-operator">=</span> radius        <span class="hljs-keyword">self</span>.drawer <span class="hljs-operator">=</span> drawer    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() &#123;        drawer.draw(x: x, y: y, radius: radius)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(x: x, y: y, radius: radius, drawer: <span class="hljs-type">CircleDrawer</span>())    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>: <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(x: x, y: y, radius: radius, drawer: <span class="hljs-type">SquareDrawer</span>())    &#125;&#125;<span class="hljs-keyword">let</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(x: <span class="hljs-number">10</span>, y: <span class="hljs-number">20</span>, radius: <span class="hljs-number">5</span>)<span class="hljs-keyword">let</span> square <span class="hljs-operator">=</span> <span class="hljs-type">Square</span>(x: <span class="hljs-number">30</span>, y: <span class="hljs-number">40</span>, radius: <span class="hljs-number">5</span>)circle.draw()square.draw()</code></pre></div></li></ul><p>在上面的示例中，**<code>Drawer</code>** 接口定义了绘制图形的基本操作，**<code>CircleDrawer</code>** 和 <strong><code>SquareDrawer</code></strong> 则是具体的绘制实现。**<code>Shape</code>** 类则代表图形对象，它包含了一个 <strong><code>Drawer</code></strong> 类型的属性，用于绘制该图形对象。**<code>Circle</code>** 和 <strong><code>Square</code></strong> 类是具体的图形类型，它们继承自 <strong><code>Shape</code></strong> 类，并在初始化时传入不同的绘制实现。</p><p>最后当需要创建多个平行的类层次结构，其中一个是实现平台相关代码，另一个是提供跨平台的通用接口，而且这些类层次结构之间的联系需要在运行时建立时，就可以考虑使用桥接模式。</p><p>桥接模式的核心思想是将抽象部分与其实现部分分离，以便它们可以独立变化。它允许抽象部分与其实现部分独立扩展，从而提高了系统的可扩展性和灵活性。在桥接模式中，抽象部分通常是指一个抽象类或接口，实现部分通常是指一个具体类。</p><p>举个例子，假设我们要设计一个跨平台的绘图软件，支持在不同的操作系统上运行，并且支持不同的绘图形式。我们可以使用桥接模式来设计这个软件，将绘图形式和操作系统分别作为抽象和实现，从而允许在运行时动态地组合不同的抽象和实现。</p><p>以下是一个简单的使用桥接模式的 Swift 5 代码示例：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">DrawingAPI</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drawCircle</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>)&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DrawingAPI1</span>: <span class="hljs-title class_">DrawingAPI</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drawCircle</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;API1.circle at (<span class="hljs-subst">\(x)</span>:<span class="hljs-subst">\(y)</span>) radius <span class="hljs-subst">\(radius)</span>&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DrawingAPI2</span>: <span class="hljs-title class_">DrawingAPI</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drawCircle</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;API2.circle at (<span class="hljs-subst">\(x)</span>:<span class="hljs-subst">\(y)</span>) radius <span class="hljs-subst">\(radius)</span>&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">var</span> drawingAPI: <span class="hljs-type">DrawingAPI</span>?    <span class="hljs-keyword">init</span>(<span class="hljs-params">drawingAPI</span>: <span class="hljs-type">DrawingAPI</span>) &#123;        <span class="hljs-keyword">self</span>.drawingAPI <span class="hljs-operator">=</span> drawingAPI    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() &#123;        <span class="hljs-built_in">preconditionFailure</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleShape</span>: <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Int</span>    <span class="hljs-keyword">var</span> y: <span class="hljs-type">Int</span>    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">drawingAPI</span>: <span class="hljs-type">DrawingAPI</span>) &#123;        <span class="hljs-keyword">self</span>.x <span class="hljs-operator">=</span> x        <span class="hljs-keyword">self</span>.y <span class="hljs-operator">=</span> y        <span class="hljs-keyword">self</span>.radius <span class="hljs-operator">=</span> radius        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(drawingAPI: drawingAPI)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() &#123;        drawingAPI<span class="hljs-operator">?</span>.drawCircle(x: x, y: y, radius: radius)    &#125;&#125;<span class="hljs-keyword">let</span> shapes <span class="hljs-operator">=</span> [    <span class="hljs-type">CircleShape</span>(x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span>, radius: <span class="hljs-number">3</span>, drawingAPI: <span class="hljs-type">DrawingAPI1</span>()),    <span class="hljs-type">CircleShape</span>(x: <span class="hljs-number">5</span>, y: <span class="hljs-number">7</span>, radius: <span class="hljs-number">11</span>, drawingAPI: <span class="hljs-type">DrawingAPI2</span>()),]<span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes &#123;    shape.draw()&#125;</code></pre></div></li></ul><p>在上面的代码中，我们首先定义了一个名为 <strong><code>DrawingAPI</code></strong> 的抽象类或接口，该类包含了一个名为 <strong><code>drawCircle</code></strong> 的抽象方法。然后，我们分别实现了 <strong><code>DrawingAPI1</code></strong> 和 <strong><code>DrawingAPI2</code></strong> 这两个具体类，它们分别表示不同的绘图 API。</p><h3 id="3-组合模式（Composite-Pattern）"><a href="#3-组合模式（Composite-Pattern）" class="headerlink" title="3. 组合模式（Composite Pattern）"></a>3. 组合模式（Composite Pattern）</h3><p>组合模式（Composite Pattern）是一种结构型设计模式，它允许你将对象组合成树形结构，以表示”部分-整体”的层次关系。组合模式可以让客户端统一处理单个对象和组合对象，从而简化代码。</p><p>组合模式通常用于以下场景：</p><ul><li>需要表示对象的层次结构，且每个对象都具有相同的接口。</li><li>需要统一处理单个对象和组合对象，而不需要显式区分它们。</li><li>需要对对象进行递归组合，从而能够处理复杂的树形结构。</li></ul><p>下面是使用 Swift 5 实现组合模式的示例代码：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">depth</span>: <span class="hljs-type">Int</span>)&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span>: <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> _name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> _name    &#125;    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;        _name <span class="hljs-operator">=</span> name    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>) &#123;        <span class="hljs-comment">// Leaf 类型不能添加子节点，因此不需要实现该方法</span>    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>) &#123;        <span class="hljs-comment">// Leaf 类型不能删除子节点，因此不需要实现该方法</span>    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">depth</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(repeating: <span class="hljs-string">&quot;-&quot;</span>, count: depth) <span class="hljs-operator">+</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-operator">+</span> name)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span>: <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> _name: <span class="hljs-type">String</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _children <span class="hljs-operator">=</span> [<span class="hljs-type">Component</span>]()    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> _name    &#125;    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;        _name <span class="hljs-operator">=</span> name    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>) &#123;        _children.append(component)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>) &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> _children.firstIndex(where: &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">===</span> component &#125;) &#123;            _children.remove(at: index)        &#125;    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">depth</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(repeating: <span class="hljs-string">&quot;-&quot;</span>, count: depth) <span class="hljs-operator">+</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-operator">+</span> name)        _children.forEach &#123; <span class="hljs-variable">$0</span>.display(depth: depth <span class="hljs-operator">+</span> <span class="hljs-number">2</span>) &#125;    &#125;&#125;<span class="hljs-comment">// 使用示例</span><span class="hljs-keyword">let</span> root <span class="hljs-operator">=</span> <span class="hljs-type">Composite</span>(name: <span class="hljs-string">&quot;root&quot;</span>)root.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf A&quot;</span>))root.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf B&quot;</span>))<span class="hljs-keyword">let</span> compositeX <span class="hljs-operator">=</span> <span class="hljs-type">Composite</span>(name: <span class="hljs-string">&quot;Composite X&quot;</span>)compositeX.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf XA&quot;</span>))compositeX.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf XB&quot;</span>))root.add(component: compositeX)<span class="hljs-keyword">let</span> compositeY <span class="hljs-operator">=</span> <span class="hljs-type">Composite</span>(name: <span class="hljs-string">&quot;Composite Y&quot;</span>)compositeY.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf YA&quot;</span>))compositeY.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf YB&quot;</span>))compositeX.add(component: compositeY)root.display(depth: <span class="hljs-number">1</span>)</code></pre></div></li></ul><p>在这个示例中，**<code>Component</code>** 是组合模式的抽象基类，包含了所有叶子节点和组合节点都具有的方法和属性。**<code>Leaf</code>** 是叶子节点的具体实现，它不能添加子节点。**<code>Composite</code>** 是组合节点的具体实现，它可以添加和删除子节点，并递归调用子节点的 <strong><code>display</code></strong> 方法。</p><h3 id="4-装饰模式（Decorator-Pattern）"><a href="#4-装饰模式（Decorator-Pattern）" class="headerlink" title="4. 装饰模式（Decorator Pattern）"></a>4. 装饰模式（Decorator Pattern）</h3><p>装饰模式（Decorator Pattern）是一种结构型设计模式，它允许你在不改变对象自身的基础上动态地给对象添加新的行为。它通常被用来解决在不改变现有代码的情况下，动态地给对象添加新的功能或行为。</p><p>装饰模式的核心思想是在运行时通过一系列的装饰器包裹原始对象来实现功能的添加。每个装饰器都与被包裹的对象实现相同的接口，因此可以在不修改原始对象的情况下添加新的行为。</p><p>下面是一个使用 Swift 5 实现装饰模式的例子，假设我们有一个 <strong><code>Beverage</code></strong> 协议表示饮料，我们想要给饮料添加调料的功能，我们可以使用装饰模式来实现：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 饮料协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Beverage</span> &#123;    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;    <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Double</span> &#123; <span class="hljs-keyword">get</span> &#125;&#125;<span class="hljs-comment">// 浓缩咖啡类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Espresso</span>: <span class="hljs-title class_">Beverage</span> &#123;    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Espresso&quot;</span>    &#125;    <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1.99</span>    &#125;&#125;<span class="hljs-comment">// 调料装饰器基类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">CondimentDecorator</span>: <span class="hljs-title class_">Beverage</span> &#123;    <span class="hljs-keyword">let</span> beverage: <span class="hljs-type">Beverage</span>    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> beverage.description    &#125;    <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> beverage.cost    &#125;    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">beverage</span>: <span class="hljs-type">Beverage</span>) &#123;        <span class="hljs-keyword">self</span>.beverage <span class="hljs-operator">=</span> beverage    &#125;&#125;<span class="hljs-comment">// 摩卡调料装饰器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mocha</span>: <span class="hljs-title class_">CondimentDecorator</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">\(beverage.description)</span>, Mocha&quot;</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0.20</span> <span class="hljs-operator">+</span> beverage.cost    &#125;&#125;<span class="hljs-comment">// 奶泡调料装饰器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Whip</span>: <span class="hljs-title class_">CondimentDecorator</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">\(beverage.description)</span>, Whip&quot;</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0.10</span> <span class="hljs-operator">+</span> beverage.cost    &#125;&#125;</code></pre></div></li></ul><p>在上面的例子中，**<code>Beverage</code>** 协议定义了一个饮料的接口，其中包含一个 <strong><code>description</code></strong> 属性表示饮料的描述和一个 <strong><code>cost</code></strong> 属性表示饮料的价格。**<code>Espresso</code>** 类是一种饮料，实现了 <strong><code>Beverage</code></strong> 协议。</p><p><strong><code>CondimentDecorator</code></strong> 类是装饰器的基类，实现了 <strong><code>Beverage</code></strong> 协议，它包含一个指向被装饰的饮料的引用，并且提供了默认的 <strong><code>description</code></strong> 和 <strong><code>cost</code></strong> 实现。**<code>Mocha</code>** 和 <strong><code>Whip</code></strong> 类是具体的装饰器类，它们继承自 <strong><code>CondimentDecorator</code></strong> 并且实现了自己的 <strong><code>description</code></strong> 和 <strong><code>cost</code></strong> 方法来添加新的行为。</p><p>使用装饰模式，我们可以像下面这样使用装饰器来装饰原始的饮料对象：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> beverage: <span class="hljs-type">Beverage</span> <span class="hljs-operator">=</span> <span class="hljs-type">Espresso</span>()<span class="hljs-comment">//现在我们已经创建了一个 Espresso 饮料对象，接下来我们可以使用 Mocha 和 Whip 装饰器来添加新的行为：</span><span class="hljs-keyword">let</span> mocha: <span class="hljs-type">Beverage</span> <span class="hljs-operator">=</span> <span class="hljs-type">Mocha</span>(beverage)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(mocha.description)</span> $<span class="hljs-subst">\(mocha.cost)</span>&quot;</span>)<span class="hljs-keyword">let</span> whip: <span class="hljs-type">Beverage</span> <span class="hljs-operator">=</span> <span class="hljs-type">Whip</span>(mocha)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(whip.description)</span> $<span class="hljs-subst">\(whip.cost)</span>&quot;</span>)</code></pre></div><p>在上面的代码中，我们先用 <strong><code>Mocha</code></strong> 装饰器包裹了原始的 <strong><code>Espresso</code></strong> 对象，然后使用 <strong><code>Whip</code></strong> 装饰器包裹了 <strong><code>Mocha</code></strong> 对象。最终，我们得到了一个包含 <strong><code>Espresso</code><strong>、</strong><code>Mocha</code></strong> 和 <strong><code>Whip</code></strong> 的新的饮料对象，并且可以输出其描述和价格。</p><p>装饰器模式的优点在于它允许你在不改变原始对象的情况下，动态地添加新的行为。这使得代码更加灵活，因为你可以通过组合不同的装饰器来创建各种不同的对象。另外，装饰器模式还遵循开闭原则，因为你可以添加新的装饰器而不必修改现有的代码。</p><p>当然，装饰器模式并不适用于所有情况。如果你需要对对象进行大量的装饰操作，可能会导致代码变得难以维护。此外，在某些情况下，可能更好的解决方案是使用继承来扩展对象的功能，而不是使用装饰器模式。</p><h3 id="5-外观模式（Facade-Pattern）"><a href="#5-外观模式（Facade-Pattern）" class="headerlink" title="5. 外观模式（Facade Pattern）"></a>5. 外观模式（Facade Pattern）</h3><p>外观模式（Facade Pattern）是一种设计模式，它提供了一个简单的接口，用于隐藏复杂系统的复杂性。它的主要目的是为客户端代码提供一个简单的接口，使其可以访问复杂系统的功能，而不需要了解系统的内部实现细节。</p><p>外观模式通常用于以下情况：</p><ul><li>当一个系统的复杂性使得它的实现变得困难时，可以使用外观模式来简化接口。</li><li>当需要将一个复杂系统划分为更小的子系统时，可以使用外观模式来创建更简单的接口。</li></ul><p>以下是一个使用 Swift 5 实现外观模式的示例：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 复杂系统的子系统</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubsystemA</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationA</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Subsystem A operation&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubsystemB</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationB</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Subsystem B operation&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubsystemC</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationC</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Subsystem C operation&quot;</span>    &#125;&#125;<span class="hljs-comment">// 定义外观接口</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> subsystemA <span class="hljs-operator">=</span> <span class="hljs-type">SubsystemA</span>()    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> subsystemB <span class="hljs-operator">=</span> <span class="hljs-type">SubsystemB</span>()    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> subsystemC <span class="hljs-operator">=</span> <span class="hljs-type">SubsystemC</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operation</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">var</span> result <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Facade initializes subsystems:<span class="hljs-subst">\n</span>&quot;</span>        result <span class="hljs-operator">+=</span> subsystemA.operationA()        result <span class="hljs-operator">+=</span> subsystemB.operationB()        result <span class="hljs-operator">+=</span> subsystemC.operationC()        <span class="hljs-keyword">return</span> result    &#125;&#125;<span class="hljs-comment">// 客户端代码使用外观接口</span><span class="hljs-keyword">let</span> facade <span class="hljs-operator">=</span> <span class="hljs-type">Facade</span>()<span class="hljs-built_in">print</span>(facade.operation())</code></pre></div><p>在这个示例中，**<code>SubsystemA</code><strong>、</strong><code>SubsystemB</code>** 和 <strong><code>SubsystemC</code></strong> 是一个复杂系统的三个子系统。**<code>Facade</code>** 提供了一个简单的接口来初始化这些子系统，并在客户端代码中使用。客户端代码只需要使用 <strong><code>Facade</code></strong> 对象的 <strong><code>operation()</code></strong> 方法来调用子系统的操作，而不需要了解每个子系统的内部实现细节。</p><h3 id="6-享元模式（Flyweight-Pattern）"><a href="#6-享元模式（Flyweight-Pattern）" class="headerlink" title="6. 享元模式（Flyweight Pattern）"></a>6. 享元模式（Flyweight Pattern）</h3><p>享元模式（Flyweight Pattern）是一种设计模式，它通过共享相似对象来最小化内存使用和提高性能。这个模式适用于需要创建大量对象的情况，但又不想消耗过多内存的场景。</p><p>具体来说，享元模式的核心思想是将对象分为两部分：内部状态（Intrinsic State）和外部状态（Extrinsic State）。其中，内部状态是可以共享的，外部状态是根据需要变化的。这样，在创建对象时，只需创建一部分对象并将其共享，可以显著减少内存消耗。</p><p>在实际应用中，享元模式经常用于优化大规模数据处理、图形渲染等领域。</p><p>下面是使用 Swift 5 实现享元模式的示例代码：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 定义享元协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Flyweight</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operation</span>(<span class="hljs-params">extrinsicState</span>: <span class="hljs-type">Int</span>)&#125;<span class="hljs-comment">// 具体享元类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFlyweight</span>: <span class="hljs-title class_">Flyweight</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> intrinsicState: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">intrinsicState</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.intrinsicState <span class="hljs-operator">=</span> intrinsicState    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operation</span>(<span class="hljs-params">extrinsicState</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Intrinsic state: <span class="hljs-subst">\(intrinsicState)</span>, Extrinsic state: <span class="hljs-subst">\(extrinsicState)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 享元工厂</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> flyweights <span class="hljs-operator">=</span> [<span class="hljs-type">String</span>: <span class="hljs-type">Flyweight</span>]()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getFlyweight</span>(<span class="hljs-params">intrinsicState</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Flyweight</span> &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> flyweight <span class="hljs-operator">=</span> flyweights[intrinsicState] &#123;            <span class="hljs-keyword">return</span> flyweight        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">let</span> flyweight <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteFlyweight</span>(intrinsicState: intrinsicState)            flyweights[intrinsicState] <span class="hljs-operator">=</span> flyweight            <span class="hljs-keyword">return</span> flyweight        &#125;    &#125;&#125;<span class="hljs-comment">// 使用享元模式</span><span class="hljs-keyword">let</span> factory <span class="hljs-operator">=</span> <span class="hljs-type">FlyweightFactory</span>()<span class="hljs-keyword">let</span> flyweight1 <span class="hljs-operator">=</span> factory.getFlyweight(intrinsicState: <span class="hljs-string">&quot;A&quot;</span>)flyweight1.operation(extrinsicState: <span class="hljs-number">1</span>) <span class="hljs-comment">// Intrinsic state: A, Extrinsic state: 1</span><span class="hljs-keyword">let</span> flyweight2 <span class="hljs-operator">=</span> factory.getFlyweight(intrinsicState: <span class="hljs-string">&quot;B&quot;</span>)flyweight2.operation(extrinsicState: <span class="hljs-number">2</span>) <span class="hljs-comment">// Intrinsic state: B, Extrinsic state: 2</span><span class="hljs-keyword">let</span> flyweight3 <span class="hljs-operator">=</span> factory.getFlyweight(intrinsicState: <span class="hljs-string">&quot;A&quot;</span>)flyweight3.operation(extrinsicState: <span class="hljs-number">3</span>) <span class="hljs-comment">// Intrinsic state: A, Extrinsic state: 3</span></code></pre></div></li></ul><p>在上面的示例中，我们定义了一个 <strong><code>Flyweight</code></strong> 协议，具体享元类 <strong><code>ConcreteFlyweight</code></strong> 实现了这个协议。**<code>FlyweightFactory</code>** 是享元工厂类，用于创建和管理享元对象。在使用时，我们可以通过工厂类获取享元对象，并在其中设置外部状态。由于相同的内部状态只会被创建一次，因此 <strong><code>flyweight1</code></strong> 和 <strong><code>flyweight3</code></strong> 实际上是同一个对象，可以共享使用。</p><h3 id="7-代理模式（Proxy-Pattern）"><a href="#7-代理模式（Proxy-Pattern）" class="headerlink" title="7. 代理模式（Proxy Pattern）"></a>7. 代理模式（Proxy Pattern）</h3><p>代理模式是一种结构型设计模式，它允许你提供一个代理对象来控制对另一个对象的访问。</p><p>代理对象充当原始对象的接口，它可以处理客户端的请求并在必要时将请求传递给原始对象。代理模式常用于以下场景：</p><ul><li>远程代理：允许客户端通过网络访问远程对象，例如远程服务API。</li><li>虚拟代理：在需要时创建开销很大的对象，例如一个大型图片或者视频对象。</li><li>保护代理：控制对敏感对象的访问，例如在用户没有权限的情况下禁止修改数据。</li></ul><p>下面是一个使用 Swift 5 代码实现虚拟代理的示例：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Image</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>()&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">RealImage</span>: <span class="hljs-title class_">Image</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> fileName: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.fileName <span class="hljs-operator">=</span> fileName        loadFromDisk()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Displaying <span class="hljs-subst">\(fileName)</span>&quot;</span>)    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">loadFromDisk</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Loading <span class="hljs-subst">\(fileName)</span> from disk&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageProxy</span>: <span class="hljs-title class_">Image</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> realImage: <span class="hljs-type">RealImage</span>?    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> fileName: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.fileName <span class="hljs-operator">=</span> fileName    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;        <span class="hljs-keyword">if</span> realImage <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;            realImage <span class="hljs-operator">=</span> <span class="hljs-type">RealImage</span>(fileName: fileName)        &#125;        realImage<span class="hljs-operator">?</span>.display()    &#125;&#125;<span class="hljs-comment">// Usage</span><span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> <span class="hljs-type">ImageProxy</span>(fileName: <span class="hljs-string">&quot;test.jpg&quot;</span>)image.display()</code></pre></div></li></ul><p>在这个示例中，**<code>RealImage</code>** 类表示一个真实的图片对象，它负责加载和显示图片。**<code>ImageProxy</code>** 类则是一个代理，它代表了一个 <strong><code>RealImage</code></strong> 对象并控制了对它的访问。当 <strong><code>ImageProxy</code></strong> 对象的 <strong><code>display</code></strong> 方法被调用时，它会先检查 <strong><code>realImage</code></strong> 是否已经存在。如果 <strong><code>realImage</code></strong> 不存在，那么它会创建一个 <strong><code>RealImage</code></strong> 对象并将其存储在 <strong><code>realImage</code></strong> 中，然后调用 <strong><code>display</code></strong> 方法。如果 <strong><code>realImage</code></strong> 已经存在，那么它将直接调用 <strong><code>realImage</code></strong> 的 <strong><code>display</code></strong> 方法。</p><p>这个示例展示了代理模式如何允许你使用代理对象来控制对另一个对象的访问。在这个示例中，**<code>ImageProxy</code>** 充当了 <strong><code>RealImage</code></strong> 的接口，并在必要时创建了一个 <strong><code>RealImage</code></strong> 对象。这使得客户端无需知道 <strong><code>RealImage</code></strong> 的实际细节，从而简化了系统的设计。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24 种设计模式-3 (Swift 5版)</title>
    <link href="/2023/02/25/other/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-Swift-5%E7%89%88/"/>
    <url>/2023/02/25/other/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-Swift-5%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="行为型模式（Behavioral-Patterns）"><a href="#行为型模式（Behavioral-Patterns）" class="headerlink" title="行为型模式（Behavioral Patterns）"></a>行为型模式（Behavioral Patterns）</h2><h3 id="1-模板方法模式（Template-Method-Pattern）"><a href="#1-模板方法模式（Template-Method-Pattern）" class="headerlink" title="1. 模板方法模式（Template Method Pattern）"></a>1. 模板方法模式（Template Method Pattern）</h3><p>模板方法模式是一种行为设计模式，其目的是定义一个算法的骨架，而将一些步骤延迟到子类中实现。在模板方法模式中，一个抽象类公开定义了执行它的方法的方式&#x2F;步骤，但是没有实现这些步骤，这些步骤由子类实现。</p><p>常用来解决的问题是在一个算法中保持不变的部分在父类中实现，而可变的部分在子类中实现，这样可以避免重复的代码，并且方便扩展。</p><p>下面是一个使用 Swift 5 实现模板方法模式的示例：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">prepareRecipe</span>() &#123;        boilWater()        brew()        pourInCup()        addCondiments()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">boilWater</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Boiling water&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pourInCup</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Pouring into cup&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">brew</span>() &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCondiments</span>() &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeWithSugar</span>: <span class="hljs-title class_">Coffee</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">brew</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Brewing coffee&quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCondiments</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Adding sugar&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeWithMilk</span>: <span class="hljs-title class_">Coffee</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">brew</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Brewing coffee&quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCondiments</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Adding milk&quot;</span>)    &#125;&#125;</code></pre></div><p>在上面的示例中，Coffee 是抽象类，定义了 prepareRecipe() 方法的骨架，以及 boilWater() 和 pourInCup() 这两个步骤的具体实现。其中，brew() 和 addCondiments() 方法都是抽象的，需要在子类中实现。</p><p>CoffeeWithSugar 和 CoffeeWithMilk 是两个具体的子类，分别实现了 brew() 和 addCondiments() 方法。这样，通过调用 CoffeeWithSugar 和 CoffeeWithMilk 的 prepareRecipe() 方法，就可以制作出带糖和带牛奶的咖啡了。</p><p>下面是示例代码的运行结果：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> coffeeWithSugar <span class="hljs-operator">=</span> <span class="hljs-type">CoffeeWithSugar</span>()coffeeWithSugar.prepareRecipe()<span class="hljs-keyword">let</span> coffeeWithMilk <span class="hljs-operator">=</span> <span class="hljs-type">CoffeeWithMilk</span>()coffeeWithMilk.prepareRecipe()</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-type">Boiling</span> water<span class="hljs-type">Brewing</span> coffee<span class="hljs-type">Pouring</span> into cup<span class="hljs-type">Adding</span> sugar<span class="hljs-type">Boiling</span> water<span class="hljs-type">Brewing</span> coffee<span class="hljs-type">Pouring</span> into cup<span class="hljs-type">Adding</span> milk</code></pre></div><h3 id="2-策略模式（Strategy-Pattern）"><a href="#2-策略模式（Strategy-Pattern）" class="headerlink" title="2. 策略模式（Strategy Pattern）"></a>2. 策略模式（Strategy Pattern）</h3><p>策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时动态地选择算法或行为，以解决相似问题的多种解决方案。</p><p>通常，当我们需要实现某种算法或行为，但可能有多种实现方式时，策略模式就非常有用了。使用该模式可以在运行时根据需求选择不同的算法或行为，而不必在代码中硬编码。</p><p>下面是一个使用 Swift 5 实现策略模式的示例，假设我们有一个飞行器接口 **<code>Flyable</code>**，我们需要实现不同的飞行策略，包括直升飞机、固定翼飞机和火箭。</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 飞行器接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Flyable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>()&#125;<span class="hljs-comment">// 直升飞机策略</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelicopterStrategy</span>: <span class="hljs-title class_">Flyable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;直升飞机在空中盘旋。&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 固定翼飞机策略</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AirplaneStrategy</span>: <span class="hljs-title class_">Flyable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;固定翼飞机在天空中飞行。&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 火箭策略</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">RocketStrategy</span>: <span class="hljs-title class_">Flyable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;火箭在太空中飞行。&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 飞行器类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Aircraft</span> &#123;    <span class="hljs-keyword">var</span> flyStrategy: <span class="hljs-type">Flyable</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">strategy</span>: <span class="hljs-type">Flyable</span>) &#123;        <span class="hljs-keyword">self</span>.flyStrategy <span class="hljs-operator">=</span> strategy    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;        <span class="hljs-keyword">self</span>.flyStrategy.fly()    &#125;&#125;<span class="hljs-comment">// 使用示例</span><span class="hljs-keyword">let</span> helicopter <span class="hljs-operator">=</span> <span class="hljs-type">Aircraft</span>(strategy: <span class="hljs-type">HelicopterStrategy</span>())helicopter.fly()  <span class="hljs-comment">// 输出: 直升飞机在空中盘旋。</span><span class="hljs-keyword">let</span> airplane <span class="hljs-operator">=</span> <span class="hljs-type">Aircraft</span>(strategy: <span class="hljs-type">AirplaneStrategy</span>())airplane.fly()  <span class="hljs-comment">// 输出: 固定翼飞机在天空中飞行。</span><span class="hljs-keyword">let</span> rocket <span class="hljs-operator">=</span> <span class="hljs-type">Aircraft</span>(strategy: <span class="hljs-type">RocketStrategy</span>())rocket.fly()  <span class="hljs-comment">// 输出: 火箭在太空中飞行。</span></code></pre></div></li></ul><p>在上面的代码中，我们定义了一个 <strong><code>Flyable</code></strong> 接口，表示飞行器的行为。然后，我们创建了三个不同的飞行策略类 <strong><code>HelicopterStrategy</code><strong>、</strong><code>AirplaneStrategy</code></strong> 和 **<code>RocketStrategy</code>**，它们分别实现了 <strong><code>Flyable</code></strong> 接口。</p><p>接着，我们创建了 <strong><code>Aircraft</code></strong> 类，其中包含一个 <strong><code>flyStrategy</code></strong> 属性，该属性用于存储具体的飞行策略对象。**<code>Aircraft</code>** 类的 <strong><code>fly()</code></strong> 方法使用 <strong><code>flyStrategy</code></strong> 属性来调用相应的飞行行为。</p><p>最后，我们创建了三个不同的 <strong><code>Aircraft</code></strong> 实例，并分别传入不同的飞行策略对象，以达到动态选择飞行策略的效果。</p><h3 id="3-观察者模式（Observer-Pattern）"><a href="#3-观察者模式（Observer-Pattern）" class="headerlink" title="3. 观察者模式（Observer Pattern）"></a>3. 观察者模式（Observer Pattern）</h3><p>观察者模式（Observer Pattern）是一种行为型设计模式，它允许一个对象（主题）维护一系列依赖于它的对象（观察者），当主题发生变化时，自动通知观察者进行相应的更新操作。</p><p>通常，当我们需要实现对象之间的松耦合时，观察者模式就非常有用了。使用该模式可以使得主题对象和观察者对象相互独立，只需要定义好接口，就可以在运行时动态地添加或删除观察者。</p><p>下面是一个使用 Swift 5 实现观察者模式的示例，假设我们有一个主题 **<code>Subject</code>**，需要通知多个观察者 **<code>Observer</code>**，以实现一个简单的文本编辑器，当用户输入文本时，通知所有观察者进行相应的更新。</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 主题协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">registerObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">notifyObservers</span>()&#125;<span class="hljs-comment">// 观察者协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>()&#125;<span class="hljs-comment">// 文本编辑器主题</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span>: <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">var</span> text: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">var</span> observers: [<span class="hljs-type">Observer</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">func</span> <span class="hljs-title function_">registerObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>) &#123;        <span class="hljs-keyword">self</span>.observers.append(observer)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>) &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.observers.firstIndex(where: &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">===</span> observer &#125;) &#123;            <span class="hljs-keyword">self</span>.observers.remove(at: index)        &#125;    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">notifyObservers</span>() &#123;        <span class="hljs-keyword">for</span> observer <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.observers &#123;            observer.update()        &#125;    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setText</span>(<span class="hljs-params">text</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.text <span class="hljs-operator">=</span> text        <span class="hljs-keyword">self</span>.notifyObservers()    &#125;&#125;<span class="hljs-comment">// 文本长度观察者</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextLengthObserver</span>: <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">var</span> textEditor: <span class="hljs-type">TextEditor</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">textEditor</span>: <span class="hljs-type">TextEditor</span>) &#123;        <span class="hljs-keyword">self</span>.textEditor <span class="hljs-operator">=</span> textEditor    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文本长度为：<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.textEditor.text.count)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 大写字母观察者</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">UppercaseObserver</span>: <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">var</span> textEditor: <span class="hljs-type">TextEditor</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">textEditor</span>: <span class="hljs-type">TextEditor</span>) &#123;        <span class="hljs-keyword">self</span>.textEditor <span class="hljs-operator">=</span> textEditor    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;大写字母为：<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.textEditor.text.filter &#123; <span class="hljs-variable">$0</span>.isUppercase &#125;)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 使用示例</span><span class="hljs-keyword">let</span> textEditor <span class="hljs-operator">=</span> <span class="hljs-type">TextEditor</span>()<span class="hljs-keyword">let</span> lengthObserver <span class="hljs-operator">=</span> <span class="hljs-type">TextLengthObserver</span>(textEditor: textEditor)<span class="hljs-keyword">let</span> uppercaseObserver <span class="hljs-operator">=</span> <span class="hljs-type">UppercaseObserver</span>(textEditor: textEditor)textEditor.registerObserver(observer: lengthObserver)textEditor.registerObserver(observer: uppercaseObserver)textEditor.setText(text: <span class="hljs-string">&quot;Hello, World!&quot;</span>)<span class="hljs-comment">// 输出：文本长度为：13</span><span class="hljs-comment">//      大写字母为：HW</span>textEditor.removeObserver(observer: uppercaseObserver)textEditor.setText(text: <span class="hljs-string">&quot;Welcome to the world of programming!&quot;</span>)<span class="hljs-comment">// 输出：文本长度为：35</span></code></pre></div></li></ul><p>在上面的代码中，我们定义了一个 <strong><code>Subject</code></strong> 协议，表示主题对象的行为。主题对象可以注册、移除和通知观察者，这些行为在协议中被定义</p><p>我们还定义了一个 <strong><code>Observer</code></strong> 协议，表示观察者对象的行为。观察者需要实现 <strong><code>update()</code></strong> 方法，在被通知时执行相应的更新操作。</p><p>接下来，我们定义了一个文本编辑器主题 **<code>TextEditor</code>**，它实现了 <strong><code>Subject</code></strong> 协议中定义的行为。主题对象维护了一个观察者数组，用于保存所有的观察者，当主题对象状态发生变化时，会遍历观察者数组并调用每个观察者的 <strong><code>update()</code></strong> 方法进行相应的更新操作。</p><p>我们还定义了两个观察者 <strong><code>TextLengthObserver</code></strong> 和 <strong><code>UppercaseObserver</code><strong>，它们都实现了 <strong><code>Observer</code></strong> 协议中定义的行为。</strong><code>TextLengthObserver</code></strong> 用于在主题对象的文本发生变化时打印文本长度，**<code>UppercaseObserver</code>** 用于在主题对象的文本发生变化时打印大写字母。</p><p>在最后的使用示例中，我们创建了一个文本编辑器主题对象 **<code>textEditor</code>**，并创建了两个观察者对象 <strong><code>lengthObserver</code></strong> 和 **<code>uppercaseObserver</code>**，并将它们注册到主题对象中。随后，我们通过 <strong><code>textEditor.setText(text:)</code></strong> 方法改变了主题对象的状态，从而触发了两个观察者的更新操作，最终输出了相应的结果。</p><p>总的来说，观察者模式使得主题对象和观察者对象之间的耦合度更低，主题对象只需要维护一个观察者列表，并通知观察者对象即可。这种方式可以方便地添加、删除或修改观察者对象，而无需修改主题对象的代码。</p><h3 id="4-迭代器模式（Iterator-Pattern）"><a href="#4-迭代器模式（Iterator-Pattern）" class="headerlink" title="4. 迭代器模式（Iterator Pattern）"></a>4. 迭代器模式（Iterator Pattern）</h3><p>迭代器模式是一种行为型设计模式，它允许我们按照特定的顺序遍历集合中的每个元素，而无需暴露集合的内部表示。该模式定义了一种迭代器接口，该接口提供了遍历集合的方法，而不需要了解集合的内部结构。</p><p>迭代器模式的核心在于将集合和遍历分离开来。这样，我们就可以遍历一个聚合对象，而无需了解聚合对象的内部结构。这种分离有助于提高代码的可重用性，并使代码更易于维护。</p><p>在 Swift 中，标准库已经提供了 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 两个协议，用于实现迭代器模式。如果需要遍历自定义类型的对象，我们可以让该类型实现 <strong><code>Sequence</code></strong> 协议，并在该协议中实现 <strong><code>makeIterator()</code></strong> 方法，返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象。</p><p>下面是一个使用 Swift 标准库提供的协议实现迭代器模式的例子：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MySequence</span>: <span class="hljs-title class_">Sequence</span> &#123;    <span class="hljs-keyword">let</span> values: [<span class="hljs-type">Int</span>]    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">IndexingIterator</span>&lt;[<span class="hljs-type">Int</span>]&gt; &#123;        <span class="hljs-keyword">return</span> values.makeIterator()    &#125;&#125;<span class="hljs-keyword">let</span> sequence <span class="hljs-operator">=</span> <span class="hljs-type">MySequence</span>(values: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> sequence &#123;    <span class="hljs-built_in">print</span>(value)&#125;</code></pre></div><p>在上面的代码中，我们定义了一个名为 <strong><code>MySequence</code></strong> 的结构体，实现了 <strong><code>Sequence</code></strong> 协议，并在其中实现了 <strong><code>makeIterator()</code></strong> 方法，返回了一个 <strong><code>IndexingIterator&lt;[Int]&gt;</code></strong> 类型的迭代器对象。</p><p>接着，我们创建了一个 <strong><code>MySequence</code></strong> 对象，并使用 <strong><code>for...in</code></strong> 循环遍历了该对象中的所有元素，并输出了每个元素的值。</p><p>需要注意的是，Swift 标准库中提供的 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议已经实现了很多迭代器模式的细节，因此在实现自定义类型的迭代器时，可以直接使用标准库提供的协议。</p><p>Swift 标准库中实现 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的原理是利用了 Swift 的生成器和闭包特性。</p><p>在 Swift 中，生成器是一种特殊的函数，可以在需要时逐个返回值，而不是一次性返回所有值。生成器函数使用 <strong><code>yield</code></strong> 关键字来返回值，并且每次返回值时，函数的状态会被保存下来，以便下一次调用该函数时可以从上次离开的地方继续执行。</p><p><strong><code>IteratorProtocol</code></strong> 协议定义了一个 <strong><code>next()</code></strong> 方法，用于返回序列中的下一个元素。在 Swift 标准库中，**<code>IteratorProtocol</code>** 协议通常由生成器函数来实现，也就是说，**<code>next()</code>** 方法的实现使用了生成器函数的特性，可以在需要时逐个返回序列中的元素，并且在返回元素时保存状态，以便下一次调用 <strong><code>next()</code></strong> 方法时可以从上次离开的地方继续执行。</p><p><strong><code>Sequence</code></strong> 协议定义了一个 <strong><code>makeIterator()</code></strong> 方法，用于返回符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象。在 Swift 标准库中，**<code>Sequence</code>** 协议通常由数组、字典、集合等数据结构来实现。当一个序列对象调用 <strong><code>makeIterator()</code></strong> 方法时，该方法会返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象，该迭代器对象实际上就是由序列对象中的生成器函数来实现的。</p><p>以下是 Swift 标准库中 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的部分实现代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IteratorProtocol</span> &#123;    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">Element</span>?&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sequence</span> &#123;    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Iterator</span>: <span class="hljs-type">IteratorProtocol</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">Iterator</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexingIterator</span>&lt;<span class="hljs-title class_">C</span>: <span class="hljs-title class_">Collection</span>&gt;: <span class="hljs-title class_">IteratorProtocol</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">C</span>.<span class="hljs-type">Element</span>? &#123;        <span class="hljs-keyword">if</span> _position <span class="hljs-operator">==</span> _elements.endIndex &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>        &#125;        _elements.formIndex(after: <span class="hljs-operator">&amp;</span>_position)        <span class="hljs-keyword">return</span> _elements[_position]    &#125;    <span class="hljs-keyword">var</span> _elements: <span class="hljs-type">C</span>    <span class="hljs-keyword">var</span> _position: <span class="hljs-type">C</span>.<span class="hljs-type">Index</span>&#125;<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Collection</span> &#123;    <span class="hljs-keyword">public</span> __consuming <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">IndexingIterator</span>&lt;<span class="hljs-keyword">Self</span>&gt; &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">IndexingIterator</span>(_elements: <span class="hljs-keyword">self</span>, _position: startIndex)    &#125;&#125;</code></pre></div><p>在上面的代码中，**<code>IteratorProtocol</code>** 协议定义了一个 <strong><code>next()</code></strong> 方法，返回一个关联类型 <strong><code>Element</code><strong>。</strong><code>Sequence</code></strong> 协议定义了一个关联类型 <strong><code>Iterator</code><strong>，并且定义了一个 <strong><code>makeIterator()</code></strong> 方法，返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象。</strong><code>IndexingIterator</code></strong> 结构体实现了 <strong><code>IteratorProtocol</code></strong> 协议，并使用泛型参数 <strong><code>C</code></strong> 限定了 <strong><code>next()</code></strong> 方法返回值的类型。在 <strong><code>IndexingIterator</code></strong> 结构体中，**<code>next()</code>** 方法的实现使用了 Swift 的集合（Collection）特性，可以逐个返回集合中的元素。在 <strong><code>Collection</code></strong> 扩展中，**<code>makeIterator()</code>** 方法的实现返回了一个 <strong><code>IndexingIterator</code></strong> 类型的迭代器对象。</p><p>总的来说，Swift 标准库中实现 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的原理是利用了 Swift 的生成器和闭包特性。生成器函数可以逐个返回序列中的元素，并在返回元素时保存状态，以便下一次调用 <strong><code>next()</code></strong> 方法时可以从上次离开的地方继续执行。序列对象调用 <strong><code>makeIterator()</code></strong> 方法时，该方法会返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象，该迭代器对象实际上就是由序列对象中的生成器函数来实现的。</p><p>由于 Swift 的生成器函数和闭包特性，实现迭代器非常简单，而且非常灵活。开发者可以根据自己的需求来编写生成器函数，实现自定义的迭代器。同时，Swift 标准库中提供了很多符合 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的数据结构，如数组、字典、集合等，可以直接使用这些数据结构提供的迭代器，方便开发者的编程工作。</p><h3 id="5-职责链模式（Chain-of-Responsibility-Pattern）"><a href="#5-职责链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="5. 职责链模式（Chain of Responsibility Pattern）"></a>5. 职责链模式（Chain of Responsibility Pattern）</h3><p>职责链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它将多个对象组成一条链，依次处理某个请求，直到请求被处理完成为止。</p><p>职责链模式常用于处理多个对象之间的协作关系，例如在一个复杂的系统中，需要处理多种请求，每种请求都需要经过多个处理步骤才能最终得到处理结果。这时候，可以将这些处理步骤封装到不同的对象中，组成一条职责链，每个对象只负责处理自己能够处理的请求，并将请求传递给下一个对象，直到请求被处理完成为止。</p><p>下面是一个使用 Swift 5 实现职责链模式的例子。假设有一个购买请求需要经过三个处理步骤才能最终得到处理结果，其中第一个处理步骤可以处理最低价格的购买请求，第二个处理步骤可以处理大于 100 元的购买请求，第三个处理步骤可以处理任意购买请求。</p><p>首先，我们定义一个请求类型 **<code>PurchaseRequest</code>**，用于表示购买请求：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PurchaseRequest</span> &#123;    <span class="hljs-keyword">let</span> amount: <span class="hljs-type">Double</span>&#125;</code></pre></div><p>然后，我们定义一个抽象处理器 **<code>PurchaseHandler</code>**，用于表示购买请求处理器，该处理器包含一个指向下一个处理器的引用，并且提供一个处理请求的方法：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">PurchaseHandler</span> &#123;    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>? &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>)&#125;</code></pre></div><p>接下来，我们实现具体的处理器。首先是第一个处理步骤的处理器，用于处理最低价格的购买请求：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowestPriceHandler</span>: <span class="hljs-title class_">PurchaseHandler</span> &#123;    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>?    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>) &#123;        <span class="hljs-keyword">if</span> request.amount <span class="hljs-operator">&lt;=</span> <span class="hljs-number">10</span> &#123;            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LowestPriceHandler: Purchase request for $<span class="hljs-subst">\(request.amount)</span> approved&quot;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            nextHandler<span class="hljs-operator">?</span>.handle(request: request)        &#125;    &#125;&#125;</code></pre></div><p>然后是第二个处理步骤的处理器，用于处理大于 100 元的购买请求：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighPriceHandler</span>: <span class="hljs-title class_">PurchaseHandler</span> &#123;    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>?    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>) &#123;        <span class="hljs-keyword">if</span> request.amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> &#123;            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;HighPriceHandler: Purchase request for $<span class="hljs-subst">\(request.amount)</span> approved&quot;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            nextHandler<span class="hljs-operator">?</span>.handle(request: request)        &#125;    &#125;&#125;</code></pre></div><p>最后是第三个处理步骤的处理器，用于处理任意购买请求：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneralPriceHandler</span>: <span class="hljs-title class_">PurchaseHandler</span> &#123;    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>?    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;GeneralPriceHandler: Purchase request for $<span class="hljs-subst">\(request.amount)</span> approved&quot;</span>)    &#125;&#125;</code></pre></div><p>现在，我们可以将这三个处理器组成一条职责链：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> lowestPriceHandler <span class="hljs-operator">=</span> <span class="hljs-type">LowestPriceHandler</span>()<span class="hljs-keyword">let</span> highPriceHandler <span class="hljs-operator">=</span> <span class="hljs-type">HighPriceHandler</span>()<span class="hljs-keyword">let</span> generalPriceHandler <span class="hljs-operator">=</span> <span class="hljs-type">GeneralPriceHandler</span>()lowestPriceHandler.nextHandler <span class="hljs-operator">=</span> highPriceHandlerhighPriceHandler.nextHandler <span class="hljs-operator">=</span> generalPriceHandler</code></pre></div><p>这样，当有一个购买请求时，我们只需要将其传递给第一个处理器即可：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> purchaseRequest <span class="hljs-operator">=</span> <span class="hljs-type">PurchaseRequest</span>(amount: <span class="hljs-number">5</span>)lowestPriceHandler.handle(request: purchaseRequest)<span class="hljs-keyword">let</span> purchaseRequest2 <span class="hljs-operator">=</span> <span class="hljs-type">PurchaseRequest</span>(amount: <span class="hljs-number">50</span>)lowestPriceHandler.handle(request: purchaseRequest2)<span class="hljs-keyword">let</span> purchaseRequest3 <span class="hljs-operator">=</span> <span class="hljs-type">PurchaseRequest</span>(amount: <span class="hljs-number">200</span>)lowestPriceHandler.handle(request: purchaseRequest3)</code></pre></div><p>输出结果如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-type">LowestPriceHandler</span>: <span class="hljs-type">Purchase</span> request <span class="hljs-keyword">for</span> <span class="hljs-variable">$5</span>.<span class="hljs-number">0</span> approved<span class="hljs-type">LowestPriceHandler</span>: <span class="hljs-type">Purchase</span> request <span class="hljs-keyword">for</span> <span class="hljs-variable">$50</span>.<span class="hljs-number">0</span> approved<span class="hljs-type">HighPriceHandler</span>: <span class="hljs-type">Purchase</span> request <span class="hljs-keyword">for</span> <span class="hljs-variable">$200</span>.<span class="hljs-number">0</span> approved</code></pre></div><p>可以看到，购买请求被依次传递给了职责链中的处理器，并且最终得到了处理结果。</p><p>在这个例子中，职责链模式将多个处理步骤组合成一条链，使得每个处理步骤只需要关注自己能够处理的请求，而不需要关注整个处理过程，从而提高了代码的可扩展性和可维护性。</p><h3 id="6-命令模式（Command-Pattern）"><a href="#6-命令模式（Command-Pattern）" class="headerlink" title="6. 命令模式（Command Pattern）"></a>6. 命令模式（Command Pattern）</h3><p>命令模式是一种行为设计模式，它将请求和接收者封装在独立的对象中，从而使你能够将请求参数化、将请求放入队列或记录请求日志，以及支持可撤销的操作。</p><p>命令模式常用来解决在软件开发中，需要对一些对象进行一系列复杂的操作，或者需要在不同的时间对对象进行不同的操作。此时，我们可以将这些操作封装成不同的命令对象，使得操作可以灵活组合，易于扩展和维护。</p><p>下面是一个使用 Swift 5 实现命令模式的简单示例，假设有一个家庭影院，我们需要对其进行一系列操作，包括打开灯光、打开投影仪、打开音响、调整音量等等：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 接收者（Receiver）：家庭影院</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeTheater</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOnLights</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Lights are on&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOffLights</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Lights are off&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOnProjector</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Projector is on&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOffProjector</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Projector is off&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOnStereo</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stereo is on&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOffStereo</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stereo is off&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setVolume</span>(<span class="hljs-params">volume</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Volume is set to <span class="hljs-subst">\(volume)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 命令（Command）：抽象类</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>()&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：打开灯光</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOnLightsCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        homeTheater.turnOnLights()    &#125;&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：关闭灯光</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOffLightsCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        homeTheater.turnOffLights()    &#125;&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：打开投影仪</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOnProjectorCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        homeTheater.turnOnProjector()    &#125;&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：关闭投影仪</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOffProjectorCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        homeTheater.turnOffProjector()    &#125;&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：打开音响</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOnStereoCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater&#125;<span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;homeTheater.turnOnStereo()&#125;&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：关闭音响</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOffStereoCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater&#125;<span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;homeTheater.turnOffStereo()&#125;&#125;</code></pre></div></li></ul><p>当我们使用命令模式时，我们通常会实现一个命令接口来封装每个具体的命令，这个命令接口通常至少包括一个 <strong><code>execute()</code></strong> 方法来执行命令。</p><p>下面是一个使用命令模式的示例，假设我们有一个简单的文本编辑器，用户可以执行一些基本的操作，例如打开文件、保存文件、撤销操作、重做操作等。我们可以使用命令模式来实现这些操作：</p><p>首先，我们定义一个 <strong><code>Command</code></strong> 接口，用于封装所有的命令：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>()&#125;</code></pre></div><p>然后，我们定义几个具体的命令，例如 <strong><code>OpenFileCommand</code><strong>、</strong><code>SaveFileCommand</code><strong>、</strong><code>UndoCommand</code></strong> 和 **<code>RedoCommand</code>**：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenFileCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行打开文件操作&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveFileCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行保存文件操作&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">UndoCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行撤销操作&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">RedoCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行重做操作&quot;</span>)    &#125;&#125;</code></pre></div><p>现在我们可以将这些命令封装到一个文本编辑器中：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;    <span class="hljs-keyword">var</span> openFileCommand: <span class="hljs-type">Command</span>    <span class="hljs-keyword">var</span> saveFileCommand: <span class="hljs-type">Command</span>    <span class="hljs-keyword">var</span> undoCommand: <span class="hljs-type">Command</span>    <span class="hljs-keyword">var</span> redoCommand: <span class="hljs-type">Command</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">openFileCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">saveFileCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">undoCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">redoCommand</span>: <span class="hljs-type">Command</span>) &#123;        <span class="hljs-keyword">self</span>.openFileCommand <span class="hljs-operator">=</span> openFileCommand        <span class="hljs-keyword">self</span>.saveFileCommand <span class="hljs-operator">=</span> saveFileCommand        <span class="hljs-keyword">self</span>.undoCommand <span class="hljs-operator">=</span> undoCommand        <span class="hljs-keyword">self</span>.redoCommand <span class="hljs-operator">=</span> redoCommand    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">openFile</span>() &#123;        openFileCommand.execute()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">saveFile</span>() &#123;        saveFileCommand.execute()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>() &#123;        undoCommand.execute()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">redo</span>() &#123;        redoCommand.execute()    &#125;&#125;</code></pre></div><p>现在我们可以使用命令模式来执行这些操作。首先，我们实例化每个具体的命令：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> openFileCommand <span class="hljs-operator">=</span> <span class="hljs-type">OpenFileCommand</span>()<span class="hljs-keyword">let</span> saveFileCommand <span class="hljs-operator">=</span> <span class="hljs-type">SaveFileCommand</span>()<span class="hljs-keyword">let</span> undoCommand <span class="hljs-operator">=</span> <span class="hljs-type">UndoCommand</span>()<span class="hljs-keyword">let</span> redoCommand <span class="hljs-operator">=</span> <span class="hljs-type">RedoCommand</span>()</code></pre></div><p>然后，我们可以将这些命令传递给一个文本编辑器实例：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> textEditor <span class="hljs-operator">=</span> <span class="hljs-type">TextEditor</span>(openFileCommand: openFileCommand, saveFileCommand: saveFileCommand, undoCommand: undoCommand, redoCommand: redoCommand)</code></pre></div><p>现在，我们可以调用文本编辑器的方法来执行这些操作：</p><div class="code-wrapper"><pre><code class="hljs swift">textEditor.openFile()  <span class="hljs-comment">// 输出：执行打开文件操作</span>textEditor.saveFile()  <span class="hljs-comment">// 输出：执行保存文件操作</span>textEditor.undo()      <span class="hljs-comment">// 输出：执行撤销操作</span>textEditor.redo()      <span class="hljs-comment">// 输出：执行重做操作</span></code></pre></div><p>在上面的示例中，我们使用命令模式来封装每个操作，并将它们传递给一个文本编辑器实例。这样，我们可以轻松地添加、修改或删除命令，而不需要修改文本编辑</p><p>当调用 <strong><code>execute()</code></strong> 方法时，会调用 <strong><code>receiver</code></strong> 对象的相应方法完成具体的操作。同时，可以通过 <strong><code>undo()</code></strong> 方法实现撤销操作，即撤销 <strong><code>receiver</code></strong> 对象的相应方法的操作。</p><p>下面是一个简单的示例，使用命令模式来实现一个遥控器控制灯的开关。首先，我们定义一个 <strong><code>Light</code></strong> 类来表示灯，并提供开灯和关灯的方法：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">on</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Light is on&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">off</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Light is off&quot;</span>)    &#125;&#125;</code></pre></div><p>然后，我们定义一个 <strong><code>Command</code></strong> 协议来表示命令：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>()&#125;</code></pre></div><p>接下来，我们实现具体的命令类，这里有开灯命令和关灯命令：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOnCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> light: <span class="hljs-type">Light</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">light</span>: <span class="hljs-type">Light</span>) &#123;        <span class="hljs-keyword">self</span>.light <span class="hljs-operator">=</span> light    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        light.on()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>() &#123;        light.off()    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOffCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> light: <span class="hljs-type">Light</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">light</span>: <span class="hljs-type">Light</span>) &#123;        <span class="hljs-keyword">self</span>.light <span class="hljs-operator">=</span> light    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        light.off()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>() &#123;        light.on()    &#125;&#125;</code></pre></div><p>在这里，**<code>LightOnCommand</code>** 和 <strong><code>LightOffCommand</code></strong> 分别实现了 <strong><code>Command</code></strong> 协议，并在 <strong><code>execute()</code></strong> 和 <strong><code>undo()</code></strong> 方法中分别调用了 <strong><code>Light</code></strong> 对象的开灯和关灯方法。</p><p>接下来，我们定义遥控器类，它有四个插槽，每个插槽都可以存放一个命令：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteControl</span> &#123;    <span class="hljs-keyword">var</span> onCommands: [<span class="hljs-type">Command</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">var</span> offCommands: [<span class="hljs-type">Command</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">init</span>() &#123;        <span class="hljs-keyword">let</span> noCommand <span class="hljs-operator">=</span> <span class="hljs-type">NoCommand</span>()        <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">4</span> &#123;            onCommands.append(noCommand)            offCommands.append(noCommand)        &#125;    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setCommand</span>(<span class="hljs-params">slot</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">onCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">offCommand</span>: <span class="hljs-type">Command</span>) &#123;        onCommands[slot] <span class="hljs-operator">=</span> onCommand        offCommands[slot] <span class="hljs-operator">=</span> offCommand    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pressOnButton</span>(<span class="hljs-params">slot</span>: <span class="hljs-type">Int</span>) &#123;        onCommands[slot].execute()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pressOffButton</span>(<span class="hljs-params">slot</span>: <span class="hljs-type">Int</span>) &#123;        offCommands[slot].execute()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pressUndoButton</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Undo button pressed&quot;</span>)    &#125;&#125;</code></pre></div><p>在这里，我们使用 <strong><code>NoCommand</code></strong> 类来初始化所有插槽。**<code>setCommand()</code>** 方法用于设置插槽中的命令，**<code>pressOnButton()</code>** 和 <strong><code>pressOffButton()</code></strong> 方法分别用于按下开灯和关灯按钮，**<code>pressUndoButton()</code>** 方法用于实现撤销操作，这里先简单地输出一个信息。</p><p>最后，我们可以测试遥控器了：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> remoteControl <span class="hljs-operator">=</span> <span class="hljs-type">RemoteControl</span>()<span class="hljs-keyword">let</span> livingRoomLight <span class="hljs-operator">=</span> <span class="hljs-type">Light</span>()<span class="hljs-keyword">let</span> livingRoomLightOnCommand <span class="hljs-operator">=</span> <span class="hljs-type">LightOnCommand</span>(light: livingRoomLight)<span class="hljs-keyword">let</span> livingRoomLightOffCommand <span class="hljs-operator">=</span> <span class="hljs-type">LightOffCommand</span>(light: livingRoomLight)remoteControl.setCommand(slot: <span class="hljs-number">0</span>, onCommand: livingRoomLightOnCommand, offCommand:livingRoomLightOffCommand)remoteControl.pressOnButton(slot:<span class="hljs-number">0</span>)remoteControl.pressOffButton(slot:<span class="hljs-number">0</span>)</code></pre></div><p>在上面的实现中，我们创建了三个具体命令 <strong><code>LightOnCommand</code><strong>、</strong><code>LightOffCommand</code></strong> 和 **<code>StereoOnWithCDCommand</code>**。每个命令对象都持有了一个接收者对象，并实现了 <strong><code>Command</code></strong> 协议的 <strong><code>execute</code></strong> 方法。这个 <strong><code>execute</code></strong> 方法会调用接收者的相关方法来实现具体的命令操作。</p><p>我们还创建了一个遥控器对象 **<code>RemoteControl</code>**，这个遥控器对象持有了一系列的命令对象。通过 <strong><code>setCommand</code></strong> 方法，我们可以给遥控器设置不同的命令，同时通过 <strong><code>buttonWasPressed</code></strong> 方法，我们可以执行遥控器当前所持有的命令对象。</p><p>这样，在实际的应用场景中，我们可以通过遥控器对象将具体的命令对象和执行命令的对象进行解耦，从而实现更加灵活的命令操作。</p><h3 id="7-备忘录模式（Memento-Pattern）"><a href="#7-备忘录模式（Memento-Pattern）" class="headerlink" title="7. 备忘录模式（Memento Pattern）"></a>7. 备忘录模式（Memento Pattern）</h3><p>备忘录模式（Memento Pattern）是一种行为设计模式，它允许将对象的状态保存到备忘录中，并在需要时将其还原到先前的状态。备忘录模式的核心思想是提供一个快照对象，用于保存一个对象的内部状态，并将该对象恢复到该状态。</p><p>备忘录模式通常用于以下两种情况中：</p><ol><li>当需要保存和恢复对象状态以进行撤销、重做或历史记录时。</li><li>当直接访问对象的成员变量可能违反封装原则时，备忘录模式可以提供一个间接的访问方式。</li></ol><p>下面是使用 Swift 5 实现备忘录模式的一个例子：</p><p>首先，我们定义一个备忘录类，用于保存需要恢复的对象的状态。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;    <span class="hljs-keyword">let</span> state: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">state</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getState</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> state    &#125;&#125;</code></pre></div><p>接下来，我们定义一个原始对象类，该类拥有一个状态变量，并且可以将其状态保存到备忘录中。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">state</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">saveStateToMemento</span>() -&gt; <span class="hljs-type">Memento</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">Memento</span>(state: state)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getStateFromMemento</span>(<span class="hljs-params">memento</span>: <span class="hljs-type">Memento</span>) &#123;        state <span class="hljs-operator">=</span> memento.getState()    &#125;&#125;</code></pre></div><p>最后，我们定义一个管理器类，该类用于保存备忘录列表并提供对它们的访问。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CareTaker</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mementoList: [<span class="hljs-type">Memento</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addMemento</span>(<span class="hljs-params">memento</span>: <span class="hljs-type">Memento</span>) &#123;        mementoList.append(memento)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getMemento</span>(<span class="hljs-params">index</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Memento</span> &#123;        <span class="hljs-keyword">return</span> mementoList[index]    &#125;&#125;</code></pre></div><p>下面是一个简单的使用备忘录模式的示例，其中我们将对象状态保存到备忘录中，并在需要时将其还原。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 创建一个原始对象</span><span class="hljs-keyword">var</span> originator <span class="hljs-operator">=</span> <span class="hljs-type">Originator</span>(state: <span class="hljs-string">&quot;State1&quot;</span>)<span class="hljs-comment">// 创建一个管理器对象</span><span class="hljs-keyword">var</span> careTaker <span class="hljs-operator">=</span> <span class="hljs-type">CareTaker</span>()<span class="hljs-comment">// 将原始对象的状态保存到备忘录中</span>careTaker.addMemento(memento: originator.saveStateToMemento())<span class="hljs-comment">// 修改原始对象的状态</span>originator.setState(state: <span class="hljs-string">&quot;State2&quot;</span>)<span class="hljs-comment">// 从备忘录中恢复原始对象的状态</span>originator.getStateFromMemento(memento: careTaker.getMemento(index: <span class="hljs-number">0</span>))<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Current State: <span class="hljs-subst">\(originator.getState())</span>&quot;</span>) <span class="hljs-comment">// 输出 &quot;Current State: State1&quot;</span></code></pre></div><p>在这个例子中，我们使用备忘录模式将原始对象的状态保存到备忘录中，并在需要时将其还原。这样，我们就可以轻松地实现撤销、重做或历史记录等功能。</p><h3 id="8-状态模式（State-Pattern）"><a href="#8-状态模式（State-Pattern）" class="headerlink" title="8. 状态模式（State Pattern）"></a>8. 状态模式（State Pattern）</h3><p>状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变其行为。该模式主要解决对象状态转换的问题，使得在状态发生改变时，对象可以自动改变行为。</p><p>状态模式包含三个主要角色：上下文（Context）、抽象状态（State）和具体状态（Concrete State）。上下文负责维护状态，并将请求转发给当前状态对象，而抽象状态定义一个接口，用于表示状态，并在状态发生改变时通知上下文，具体状态则实现抽象状态定义的接口，并处理上下文发来的请求。</p><p>使用状态模式可以使代码更加可维护和可扩展，因为状态转换的逻辑被封装在状态类中，而不是分散在上下文中，从而使得状态类可以独立变化而不会影响到上下文。</p><p>下面是一个使用 Swift 5 实现状态模式的示例代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 定义抽象状态</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">State</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>)&#125;<span class="hljs-comment">// 定义具体状态 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateA</span>: <span class="hljs-title class_">State</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前状态是 A&quot;</span>)        context.setState(state: <span class="hljs-type">ConcreteStateB</span>())    &#125;&#125;<span class="hljs-comment">// 定义具体状态 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateB</span>: <span class="hljs-title class_">State</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前状态是 B&quot;</span>)        context.setState(state: <span class="hljs-type">ConcreteStateA</span>())    &#125;&#125;<span class="hljs-comment">// 定义上下文</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">state</span>: <span class="hljs-type">State</span>) &#123;        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>: <span class="hljs-type">State</span>) &#123;        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">request</span>() &#123;        state.handle(context: <span class="hljs-keyword">self</span>)    &#125;&#125;<span class="hljs-comment">// 测试代码</span><span class="hljs-keyword">let</span> context <span class="hljs-operator">=</span> <span class="hljs-type">Context</span>(state: <span class="hljs-type">ConcreteStateA</span>())context.request()context.request()context.request()</code></pre></div><p>在上面的代码中，抽象状态被定义为 <strong><code>State</code></strong> 协议，其中包含一个 <strong><code>handle</code></strong> 方法用于处理请求并改变上下文状态。具体状态 <strong><code>ConcreteStateA</code></strong> 和 <strong><code>ConcreteStateB</code></strong> 实现了 <strong><code>State</code></strong> 协议，并分别处理不同的请求，并将上下文状态设置为另一个具体状态。上下文类 <strong><code>Context</code></strong> 维护当前状态并将请求转发给当前状态来处理。最后，在测试代码中，上下文被初始化为 **<code>ConcreteStateA</code>**，并连续进行了三次请求，每次请求后状态都会发生改变。</p><h3 id="9-访问者模式（Visitor-Pattern）"><a href="#9-访问者模式（Visitor-Pattern）" class="headerlink" title="9. 访问者模式（Visitor Pattern）"></a>9. 访问者模式（Visitor Pattern）</h3><p>访问者模式（Visitor Pattern）是一种行为型设计模式，用于将算法与对象结构分离。该模式将算法定义在访问者中，让访问者能够访问并处理对象结构中的各个元素，而不需要修改这些元素的类定义。因此，该模式可以使得算法与对象结构相互独立，并且可以轻松添加新的算法而不会影响对象结构。</p><p>访问者模式包含四个主要角色：访问者（Visitor）、具体访问者（Concrete Visitor）、元素（Element）和具体元素（Concrete Element）。访问者定义了访问元素的方法，具体访问者实现了访问方法，并包含了针对不同元素的具体算法，元素定义了接受访问者访问的方法，具体元素实现了元素的特定行为，并在接受访问者访问时调用访问者的方法。</p><p>使用访问者模式可以将算法与对象结构分离，从而使得算法可以更容易地扩展和变化，并且可以方便地添加新的算法，而不需要修改对象结构。访问者模式通常用于解决对象结构比较稳定，但是需要频繁变化的算法的问题。</p><p>下面是一个使用 Swift 5 实现访问者模式的示例代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 定义元素接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>: <span class="hljs-type">Visitor</span>)&#125;<span class="hljs-comment">// 定义具体元素 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementA</span>: <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>: <span class="hljs-type">Visitor</span>) &#123;        visitor.visit(element: <span class="hljs-keyword">self</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationA</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteElementA operationA&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 定义具体元素 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementB</span>: <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>: <span class="hljs-type">Visitor</span>) &#123;        visitor.visit(element: <span class="hljs-keyword">self</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationB</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteElementB operationB&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 定义访问者接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Visitor</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementA</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementB</span>)&#125;<span class="hljs-comment">// 定义具体访问者 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitorA</span>: <span class="hljs-title class_">Visitor</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementA</span>) &#123;        element.operationA()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementB</span>) &#123;        element.operationB()    &#125;&#125;<span class="hljs-comment">// 定义具体访问者 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitorB</span>: <span class="hljs-title class_">Visitor</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementA</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteVisitorB visit ConcreteElementA&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementB</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteVisitorB visit ConcreteElementB&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 测试代码</span><span class="hljs-keyword">let</span> elements: [<span class="hljs-type">Element</span>] <span class="hljs-operator">=</span> [<span class="hljs-type">ConcreteElementA</span>(), <span class="hljs-type">ConcreteElementB</span>()]<span class="hljs-keyword">let</span> visitorA <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteVisitorA</span>()<span class="hljs-keyword">let</span> visitorB <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteVisitorB</span>()<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> elements &#123;    element.accept(visitor: visitorA)    element.accept(visitor: visitorB)&#125;</code></pre></div><p>在上面的代码中，元素被定义为 <strong><code>Element</code></strong> 协议，其中包含一个接受访问者访问方法。具体元素 <strong><code>ConcreteElementA</code></strong> 和 <strong><code>ConcreteElementB</code></strong> 实现了 <strong><code>Element</code></strong> 接口，并在接受访问者访问时调用访问者的访问方法。</p><p>访问者被定义为 <strong><code>Visitor</code></strong> 接口，其中包含针对具体元素的访问方法。具体访问者 <strong><code>ConcreteVisitorA</code></strong> 和 <strong><code>ConcreteVisitorB</code></strong> 实现了 <strong><code>Visitor</code></strong> 接口，并分别实现了访问具体元素的具体算法。</p><p>在测试代码中，创建了两个具体访问者 <strong><code>visitorA</code></strong> 和 **<code>visitorB</code>**，以及两个元素 <strong><code>ConcreteElementA</code></strong> 和 **<code>ConcreteElementB</code>**。遍历元素数组，分别调用元素的 <strong><code>accept</code></strong> 方法，接受访问者的访问。在访问过程中，具体元素会调用访问者的访问方法，从而实现了算法与对象结构的分离。</p><p>总的来说，访问者模式可以让算法与对象结构相互独立，并且可以轻松添加新的算法而不会影响对象结构。该模式通常用于解决对象结构比较稳定，但是需要频繁变化的算法的问题。</p><h3 id="10-中介者模式（Mediator-Pattern）"><a href="#10-中介者模式（Mediator-Pattern）" class="headerlink" title="10. 中介者模式（Mediator Pattern）"></a>10. 中介者模式（Mediator Pattern）</h3><p>中介者模式是一种行为型设计模式，它可以通过将对象之间的通信转移给一个中介者对象来降低对象之间的耦合度。中介者模式有时也被称为调停者模式，因为中介者在协调对象之间的交互时，就像一个调停者一样。</p><p>中介者模式通常用于以下场景：</p><ul><li>当一个对象需要与许多其他对象进行通信时，如果这些对象之间的交互非常复杂，那么每个对象都需要了解所有其他对象的细节，这会导致非常复杂和难以维护的代码。使用中介者模式可以将这些交互转移到中介者对象中，从而简化每个对象的职责。</li><li>当多个对象之间的交互会导致复杂的循环依赖关系时，使用中介者模式可以打破这些循环依赖，从而使代码更加可维护和可扩展。</li><li>当一个对象的改变需要通知其他对象时，如果每个对象都需要了解其他对象的细节，那么这种通知机制也会变得非常复杂。使用中介者模式可以将这种通知机制转移到中介者对象中，从而简化代码。</li></ul><p>下面是一个简单的 Swift 5 代码示例，演示了如何使用中介者模式协调多个组件之间的交互。假设我们有一个窗口组件（Window）、一个按钮组件（Button）和一个文本框组件（TextBox），它们都需要与彼此交互。我们可以创建一个中介者对象（Mediator）来协调它们之间的交互，如下所示：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 中介者</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> window: <span class="hljs-type">Window</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> button: <span class="hljs-type">Button</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> textBox: <span class="hljs-type">TextBox</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">window</span>: <span class="hljs-type">Window</span>, <span class="hljs-params">button</span>: <span class="hljs-type">Button</span>, <span class="hljs-params">textBox</span>: <span class="hljs-type">TextBox</span>) &#123;        <span class="hljs-keyword">self</span>.window <span class="hljs-operator">=</span> window        <span class="hljs-keyword">self</span>.button <span class="hljs-operator">=</span> button        <span class="hljs-keyword">self</span>.textBox <span class="hljs-operator">=</span> textBox    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">buttonClicked</span>() &#123;        textBox.setText(<span class="hljs-string">&quot;Button clicked&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">textBoxChanged</span>() &#123;        <span class="hljs-keyword">if</span> textBox.getText() <span class="hljs-operator">==</span> <span class="hljs-string">&quot;open&quot;</span> &#123;            window.open()        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> textBox.getText() <span class="hljs-operator">==</span> <span class="hljs-string">&quot;close&quot;</span> &#123;            window.close()        &#125;    &#125;&#125;<span class="hljs-comment">// 窗口组件</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">open</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Window opened&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">close</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Window closed&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 按钮组件</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mediator: <span class="hljs-type">Mediator</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">mediator</span>: <span class="hljs-type">Mediator</span>) &#123;        <span class="hljs-keyword">self</span>.mediator <span class="hljs-operator">=</span> mediator    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">click</span>() &#123;        mediator.buttonClicked()    &#125;&#125;<span class="hljs-comment">// 文本框组件</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBox</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mediator: <span class="hljs-type">Mediator</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> text: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">mediator</span>: <span class="hljs-type">Mediator</span>) &#123;        <span class="hljs-keyword">self</span>.mediator <span class="hljs-operator">=</span> mediator    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setText</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">text</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.text <span class="hljs-operator">=</span> text        mediator.textBoxChanged()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getText</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> text    &#125;&#125;</code></pre></div><p>在这个例子中，中介者对象包含对窗口、按钮和文本框对象的引用。当按钮被点击时，它会调用中介者对象的 <strong><code>buttonClicked()</code></strong> 方法，中介者对象在收到这个消息后会将文本框的文本设置为“Button clicked”。当文本框的文本改变时，它会调用中介者对象的 <strong><code>textBoxChanged()</code></strong> 方法，中介者对象根据文本框的内容来打开或关闭窗口。</p><p>按钮和文本框对象都包含对中介者对象的引用。当按钮被点击时，它会调用中介者对象的 <strong><code>buttonClicked()</code></strong> 方法，从而触发文本框的文本改变。当文本框的文本改变时，它会调用中介者对象的 <strong><code>textBoxChanged()</code></strong> 方法，从而打开或关闭窗口。</p><p>这个例子演示了如何使用中介者模式来协调多个组件之间的交互，从而降低它们之间的耦合度。中介者模式可以帮助我们编写更加模块化、可维护和可扩展的代码。</p><h3 id="11-解释器模式（Interpreter-Pattern）"><a href="#11-解释器模式（Interpreter-Pattern）" class="headerlink" title="11. 解释器模式（Interpreter Pattern）"></a>11. 解释器模式（Interpreter Pattern）</h3><p>解释器模式是一种行为型设计模式，它定义了一种语言，用于表示特定问题领域的语法规则，并提供了一种方式来解释这种语言中的语句。通过使用解释器模式，我们可以将一个问题转换为一个表达式，然后使用这个表达式来解决问题。</p><p>解释器模式通常用于以下场景：</p><ul><li>当我们需要解决某个特定领域的问题时，比如数学、逻辑、日期等，可以使用解释器模式来定义这个领域的语法规则，并提供一种方式来解释这些规则。</li><li>当我们需要实现一种简单的语言解释器时，可以使用解释器模式来定义这个语言的语法规则，并提供一种方式来解释这些规则。</li><li>当我们需要根据特定的规则生成表达式时，可以使用解释器模式来实现这个功能。</li></ul><p>下面是一个简单的 Swift 5 代码示例，演示了如何使用解释器模式来解释简单的数学表达式。假设我们有一些简单的数学表达式，比如“1 + 2 + 3”，“1 - 2 + 3”等，我们可以定义一个解释器对象（Interpreter），来解释这些表达式，如下所示：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 解释器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Interpreter</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> expression: <span class="hljs-type">Expression</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">expression</span>: <span class="hljs-type">Expression</span>) &#123;        <span class="hljs-keyword">self</span>.expression <span class="hljs-operator">=</span> expression    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;        <span class="hljs-keyword">return</span> expression.interpret()    &#125;&#125;<span class="hljs-comment">// 表达式</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span>&#125;<span class="hljs-comment">// 数字表达式</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberExpression</span>: <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">value</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> value    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;        <span class="hljs-keyword">return</span> value    &#125;&#125;<span class="hljs-comment">// 加法表达式</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddExpression</span>: <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> leftExpression: <span class="hljs-type">Expression</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> rightExpression: <span class="hljs-type">Expression</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">leftExpression</span>: <span class="hljs-type">Expression</span>, <span class="hljs-params">rightExpression</span>: <span class="hljs-type">Expression</span>) &#123;        <span class="hljs-keyword">self</span>.leftExpression <span class="hljs-operator">=</span> leftExpression        <span class="hljs-keyword">self</span>.rightExpression <span class="hljs-operator">=</span> rightExpression    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;        <span class="hljs-keyword">return</span> leftExpression.interpret() <span class="hljs-operator">+</span> rightExpression.interpret()    &#125;&#125;<span class="hljs-comment">// 减法表达式</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubtractExpression</span>: <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> leftExpression: <span class="hljs-type">Expression</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> rightExpression: <span class="hljs-type">Expression</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">leftExpression</span>: <span class="hljs-type">Expression</span>, <span class="hljs-params">rightExpression</span>: <span class="hljs-type">Expression</span>) &#123;        <span class="hljs-keyword">self</span>.leftExpression <span class="hljs-operator">=</span> leftExpression        <span class="hljs-keyword">self</span>.rightExpression <span class="hljs-operator">=</span> rightExpression    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;        <span class="hljs-keyword">return</span> leftExpression.interpret() <span class="hljs-operator">-</span> rightExpression.interpret()    &#125;&#125;</code></pre></div><p>在这个例子中，我们定义了一个解释器对象（Interpreter），它包含一个表达式对象（Expression）。我们还定义了三个不同的表达式类型：数字表达式（NumberExpression）、加法表达式（AddExpression）和减法表达式（SubtractExpression）。</p><p>数字表达式表示一个简单的数字，例如“1”或“2”。加法表达式和减法表达式分别表示加法和减法运算。它们都包含左表达式和右表达式，这些表达式都可以是数字表达式或其他的加法&#x2F;减法表达式。这些表达式实现了一个 <strong><code>interpret()</code></strong> 方法，用于解释表达式，并返回表达式的计算结果。</p><p>现在我们可以使用这些表达式和解释器来解释数学表达式了。例如，我们可以解释一个简单的数学表达式“1 + 2 + 3”，如下所示：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> expression <span class="hljs-operator">=</span> <span class="hljs-type">AddExpression</span>(    leftExpression: <span class="hljs-type">AddExpression</span>(        leftExpression: <span class="hljs-type">NumberExpression</span>(value: <span class="hljs-number">1</span>),        rightExpression: <span class="hljs-type">NumberExpression</span>(value: <span class="hljs-number">2</span>)    ),    rightExpression: <span class="hljs-type">NumberExpression</span>(value: <span class="hljs-number">3</span>))<span class="hljs-keyword">let</span> interpreter <span class="hljs-operator">=</span> <span class="hljs-type">Interpreter</span>(expression: expression)<span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> interpreter.interpret()<span class="hljs-built_in">print</span>(result) <span class="hljs-comment">// Output: 6</span></code></pre></div><p>在这个例子中，我们首先创建了一个加法表达式对象，它由三个数字表达式组成，表示一个简单的加法表达式“1 + 2 + 3”。然后我们创建了一个解释器对象，并传入这个加法表达式对象。最后，我们调用解释器对象的 <strong><code>interpret()</code></strong> 方法，得到这个表达式的计算结果，并将其打印出来。</p><p>解释器模式虽然能够解决一些特定问题领域的语法解析问题，但是在实际开发中使用较少，因为其实现和使用比较复杂。通常情况下，我们可以使用其他的方式来解决类似的问题，比如使用正则表达式或特定的库来解析文本。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用开发原则</title>
    <link href="/2023/02/25/other/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/"/>
    <url>/2023/02/25/other/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="常用开发原则"><a href="#常用开发原则" class="headerlink" title="常用开发原则"></a>常用开发原则</h2><h3 id="1-单一职责原则（Single-Responsibility-Principle，SRP）"><a href="#1-单一职责原则（Single-Responsibility-Principle，SRP）" class="headerlink" title="1. 单一职责原则（Single Responsibility Principle，SRP）"></a>1. 单一职责原则（Single Responsibility Principle，SRP）</h3><p>单一职责原则（Single Responsibility Principle，SRP）是面向对象设计中的一项基本原则，它指出一个类或模块应该只有一个职责或责任，即一个类或模块应该只负责一种功能或行为。</p><p>单一职责原则的目的是将复杂的系统分解为多个简单的组件，每个组件都只关注一个特定的功能或职责，从而使系统更加灵活、可扩展和易于维护。当一个类或模块承担了多种职责时，它就变得复杂、难以维护和扩展，因为修改其中一个职责可能会影响到其他职责。</p><p>单一职责原则常用来解决以下问题：</p><ul><li>类或模块过于庞大，难以维护和理解；</li><li>类或模块承担了过多的职责，难以扩展和重用；</li><li>修改一个职责会影响到其他职责，导致系统出现不稳定的行为。</li></ul><p>下面是一个使用 Swift 5 实现单一职责原则的示例。我们有一个 <strong><code>Order</code></strong> 类，用于表示客户订单，其中包含了订单的详细信息以及订单的处理方法。我们可以将 <strong><code>Order</code></strong> 类拆分成两个类，一个用于表示订单信息，另一个用于处理订单，从而使其符合单一职责原则。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 订单信息类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderInfo</span> &#123;    <span class="hljs-keyword">let</span> orderId: <span class="hljs-type">String</span>    <span class="hljs-keyword">let</span> customerName: <span class="hljs-type">String</span>    <span class="hljs-keyword">let</span> orderDate: <span class="hljs-type">Date</span>    <span class="hljs-keyword">let</span> orderItems: [<span class="hljs-type">OrderItem</span>]    <span class="hljs-keyword">init</span>(<span class="hljs-params">orderId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">customerName</span>: <span class="hljs-type">String</span>, <span class="hljs-params">orderDate</span>: <span class="hljs-type">Date</span>, <span class="hljs-params">orderItems</span>: [<span class="hljs-type">OrderItem</span>]) &#123;        <span class="hljs-keyword">self</span>.orderId <span class="hljs-operator">=</span> orderId        <span class="hljs-keyword">self</span>.customerName <span class="hljs-operator">=</span> customerName        <span class="hljs-keyword">self</span>.orderDate <span class="hljs-operator">=</span> orderDate        <span class="hljs-keyword">self</span>.orderItems <span class="hljs-operator">=</span> orderItems    &#125;&#125;<span class="hljs-comment">// 订单处理类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">order</span>: <span class="hljs-type">OrderInfo</span>) &#123;        <span class="hljs-comment">// 处理订单逻辑</span>    &#125;&#125;</code></pre></div><p>在上面的示例中，我们将 <strong><code>Order</code></strong> 类拆分成了 <strong><code>OrderInfo</code></strong> 和 <strong><code>OrderProcessor</code></strong> 两个类。**<code>OrderInfo</code>** 类用于表示订单的详细信息，包括订单编号、客户名称、下单日期和订单项；**<code>OrderProcessor</code>** 类用于处理订单，包括处理订单的逻辑和实现。</p><p>通过将 <strong><code>Order</code></strong> 类拆分成多个类，我们遵守了单一职责原则，使每个类只关注一种特定的功能或职责。这样，如果我们需要修改订单处理逻辑，就不会影响到订单信息的表示和存储，从而使系统更加稳定和易于维护。</p><h3 id="2-开放封闭原则（Open-x2F-Closed-Principle，OCP）"><a href="#2-开放封闭原则（Open-x2F-Closed-Principle，OCP）" class="headerlink" title="2. 开放封闭原则（Open&#x2F;Closed Principle，OCP）"></a>2. 开放封闭原则（Open&#x2F;Closed Principle，OCP）</h3><p>开放封闭原则（Open&#x2F;Closed Principle，OCP）是面向对象设计中的一项基本原则，它指出一个软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着在不修改原有代码的情况下，可以通过扩展代码的行为来实现新的功能。</p><p>开放封闭原则的目的是保持系统的稳定性和可维护性。当系统需要修改现有代码来添加新的功能时，可能会导致系统出现不稳定的行为和意外的副作用。通过遵守开放封闭原则，我们可以避免这些问题，同时使系统更加灵活和易于扩展。</p><p>开放封闭原则常用来解决以下问题：</p><ul><li>当需要添加新的功能时，不希望修改现有的代码；</li><li>当需要修改现有的代码时，不希望影响到系统的稳定性和可维护性。</li></ul><p>下面是一个使用 Swift 5 实现开放封闭原则的示例。我们有一个 <strong><code>OrderProcessor</code></strong> 类，用于处理客户订单，其中包含了订单的详细信息以及订单的处理方法。我们希望能够通过添加新的支付方式来扩展订单处理逻辑，同时不影响现有的代码。为了实现这个目标，我们可以将支付逻辑封装到一个单独的类中，从而使其可以独立扩展和修改。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 订单信息类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderInfo</span> &#123;    <span class="hljs-keyword">let</span> orderId: <span class="hljs-type">String</span>    <span class="hljs-keyword">let</span> customerName: <span class="hljs-type">String</span>    <span class="hljs-keyword">let</span> orderDate: <span class="hljs-type">Date</span>    <span class="hljs-keyword">let</span> orderItems: [<span class="hljs-type">OrderItem</span>]    <span class="hljs-keyword">init</span>(<span class="hljs-params">orderId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">customerName</span>: <span class="hljs-type">String</span>, <span class="hljs-params">orderDate</span>: <span class="hljs-type">Date</span>, <span class="hljs-params">orderItems</span>: [<span class="hljs-type">OrderItem</span>]) &#123;        <span class="hljs-keyword">self</span>.orderId <span class="hljs-operator">=</span> orderId        <span class="hljs-keyword">self</span>.customerName <span class="hljs-operator">=</span> customerName        <span class="hljs-keyword">self</span>.orderDate <span class="hljs-operator">=</span> orderDate        <span class="hljs-keyword">self</span>.orderItems <span class="hljs-operator">=</span> orderItems    &#125;&#125;<span class="hljs-comment">// 支付接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Payment</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>)&#125;<span class="hljs-comment">// 现金支付类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">CashPayment</span>: <span class="hljs-title class_">Payment</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-comment">// 现金支付逻辑</span>    &#125;&#125;<span class="hljs-comment">// 支付宝支付类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayPayment</span>: <span class="hljs-title class_">Payment</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-comment">// 支付宝支付逻辑</span>    &#125;&#125;<span class="hljs-comment">// 订单处理类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> payment: <span class="hljs-type">Payment</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">payment</span>: <span class="hljs-type">Payment</span>) &#123;        <span class="hljs-keyword">self</span>.payment <span class="hljs-operator">=</span> payment    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">order</span>: <span class="hljs-type">OrderInfo</span>) &#123;        <span class="hljs-comment">// 处理订单逻辑</span>        <span class="hljs-comment">// 支付订单</span>        payment.pay(amount: order.totalAmount)    &#125;&#125;</code></pre></div><p>在上面的示例中，我们将支付逻辑封装到了 <strong><code>Payment</code></strong> 接口中，并实现了两个具体的支付类 <strong><code>CashPayment</code></strong> 和 **<code>AlipayPayment</code>**。我们还将支付逻辑注入到了 <strong><code>OrderProcessor</code></strong> 类中，通过传递不同的支付类实现订单处理的扩展和修改。</p><p>通过将支付逻辑封装到一个单独的类中，我们可以在不影响现有代码的情况下，添加新的支付方式和修改支付逻辑，从而实现了开放封闭原则。当需要添加新的支付方式时，我们只需要实现一个新的支付类并注入到 <strong><code>OrderProcessor</code></strong> 中即可，不需要修改现有的代码。</p><p>下面是一个示例代码，用于创建一个现金支付订单：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> order <span class="hljs-operator">=</span> <span class="hljs-type">OrderInfo</span>(orderId: <span class="hljs-string">&quot;123456&quot;</span>, customerName: <span class="hljs-string">&quot;张三&quot;</span>, orderDate: <span class="hljs-type">Date</span>(), orderItems: [item1, item2])<span class="hljs-keyword">let</span> cashPayment <span class="hljs-operator">=</span> <span class="hljs-type">CashPayment</span>()<span class="hljs-keyword">let</span> orderProcessor <span class="hljs-operator">=</span> <span class="hljs-type">OrderProcessor</span>(payment: cashPayment)orderProcessor.process(order: order)</code></pre></div><p>我们还可以创建一个支付宝支付订单：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> order <span class="hljs-operator">=</span> <span class="hljs-type">OrderInfo</span>(orderId: <span class="hljs-string">&quot;123456&quot;</span>, customerName: <span class="hljs-string">&quot;张三&quot;</span>, orderDate: <span class="hljs-type">Date</span>(), orderItems: [item1, item2])<span class="hljs-keyword">let</span> alipayPayment <span class="hljs-operator">=</span> <span class="hljs-type">AlipayPayment</span>()<span class="hljs-keyword">let</span> orderProcessor <span class="hljs-operator">=</span> <span class="hljs-type">OrderProcessor</span>(payment: alipayPayment)orderProcessor.process(order: order)</code></pre></div><p>通过实现开放封闭原则，我们使系统更加灵活和易于扩展，同时保持了系统的稳定性和可维护性。</p><h3 id="3-里式替换原则（Liskov-Substitution-Principle，LSP）"><a href="#3-里式替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="3. 里式替换原则（Liskov Substitution Principle，LSP）"></a>3. 里式替换原则（Liskov Substitution Principle，LSP）</h3><p>里式替换原则（Liskov Substitution Principle，LSP）是面向对象设计中的一个重要原则，它指出：子类对象应该能够替换掉父类对象并且仍能保持程序的正确性。</p><p>这个原则的核心思想是：子类不应该破坏父类的封装和抽象，即子类中新增的方法和属性不应该影响到父类的行为。LSP可以帮助我们确保代码的正确性和可扩展性，同时也可以避免出现一些难以调试的问题。</p><p>下面，我们以一个简单的 Swift 示例来说明 LSP 的应用。假设我们有一个图形库，其中包含 <strong><code>Shape</code></strong> 基类和两个子类 <strong><code>Rectangle</code></strong> 和 <strong><code>Circle</code><strong>。</strong><code>Shape</code></strong> 类有一个计算面积的方法 <strong><code>calculateArea()</code><strong>，</strong><code>Rectangle</code></strong> 和 <strong><code>Circle</code></strong> 分别实现了这个方法。我们可以使用这些类来创建不同的图形，并计算它们的面积。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">var</span> width: <span class="hljs-type">Double</span>    <span class="hljs-keyword">var</span> height: <span class="hljs-type">Double</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">width</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">height</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.width <span class="hljs-operator">=</span> width        <span class="hljs-keyword">self</span>.height <span class="hljs-operator">=</span> height    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> width <span class="hljs-operator">*</span> height    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Double</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.radius <span class="hljs-operator">=</span> radius    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>.pi <span class="hljs-operator">*</span> radius <span class="hljs-operator">*</span> radius    &#125;&#125;</code></pre></div><p>现在，我们希望在图形库中添加一个新的图形类 **<code>Square</code>**，它是 <strong><code>Rectangle</code></strong> 的一个特例，即它的宽和高相等。按照 LSP 的原则，我们应该可以将 <strong><code>Square</code></strong> 对象替换为 <strong><code>Rectangle</code></strong> 对象而不会影响程序的正确性。</p><p>我们可以创建一个 <strong><code>Square</code></strong> 类继承自 **<code>Rectangle</code>**，并重写父类的初始化方法，确保 <strong><code>width</code></strong> 和 <strong><code>height</code></strong> 始终相等：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>: <span class="hljs-title class_">Rectangle</span> &#123;    <span class="hljs-keyword">init</span>(<span class="hljs-params">side</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(width: side, height: side)    &#125;&#125;</code></pre></div><p>现在，我们可以在创建图形时使用 <strong><code>Square</code></strong> 替换 <strong><code>Rectangle</code></strong> 对象，并调用 <strong><code>calculateArea()</code></strong> 方法计算面积：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> rectangle <span class="hljs-operator">=</span> <span class="hljs-type">Rectangle</span>(width: <span class="hljs-number">4</span>, height: <span class="hljs-number">5</span>)<span class="hljs-keyword">let</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(radius: <span class="hljs-number">3</span>)<span class="hljs-keyword">let</span> square <span class="hljs-operator">=</span> <span class="hljs-type">Square</span>(side: <span class="hljs-number">4</span>)<span class="hljs-keyword">let</span> shapes: [<span class="hljs-type">Shape</span>] <span class="hljs-operator">=</span> [rectangle, circle, square]<span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes &#123;    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Area of <span class="hljs-subst">\(<span class="hljs-built_in">type</span>(of: shape))</span> is <span class="hljs-subst">\(shape.calculateArea())</span>&quot;</span>)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">输出结果如下：</code></pre></div><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-type">Area</span> of <span class="hljs-type">Rectangle</span> <span class="hljs-keyword">is</span> <span class="hljs-number">20.0</span><span class="hljs-type">Area</span> of <span class="hljs-type">Circle</span> <span class="hljs-keyword">is</span> <span class="hljs-number">28.274333882308138</span><span class="hljs-type">Area</span> of <span class="hljs-type">Square</span> <span class="hljs-keyword">is</span> <span class="hljs-number">16.0</span></code></pre></div><p>由于 <strong><code>Square</code></strong> 对象是 <strong><code>Rectangle</code></strong> 的特例，我们可以使用 <strong><code>Square</code></strong> 对象替换 <strong><code>Rectangle</code></strong> 对象而不影响程序的正确性。这就是 LSP 的应用途，通过使用 LSP，我们可以创建更加灵活的代码，可以轻松地添加新的子类，并在不破坏现有代码的情况下进行修改和扩展。</p><p>在实际开发中，为了遵循 LSP 原则，我们需要遵循以下几个准则：</p><ul><li>子类必须实现父类的所有方法，并且方法的输入输出参数类型与父类一致或者更加宽松。</li><li>子类新增的方法和属性不应该影响到父类的行为。</li><li>子类的前置条件（输入参数）不能强于父类的前置条件。</li><li>子类的后置条件（输出参数）不能弱于父类的后置条件。</li></ul><p>下面，我们再以一个 Swift 示例来说明 LSP 的应用。假设我们有一个计算器应用，其中包含一个 <strong><code>Calculator</code></strong> 基类和两个子类 <strong><code>SimpleCalculator</code></strong> 和 <strong><code>ScientificCalculator</code><strong>。</strong><code>Calculator</code></strong> 类有一个计算方法 <strong><code>calculate(_:)</code><strong>，</strong><code>SimpleCalculator</code></strong> 和 <strong><code>ScientificCalculator</code></strong> 分别实现了这个方法。我们可以使用这些类来进行简单的数学计算。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-comment">// 简单计算逻辑</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ScientificCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-comment">// 科学计算逻辑</span>    &#125;&#125;</code></pre></div><p>现在，我们希望添加一个新的子类 **<code>GraphingCalculator</code>**，它可以将计算结果以图表的形式展示出来。按照 LSP 的原则，我们应该可以将 <strong><code>GraphingCalculator</code></strong> 对象替换为 <strong><code>SimpleCalculator</code></strong> 或 <strong><code>ScientificCalculator</code></strong> 对象而不会影响程序的正确性。</p><p>我们可以创建一个 <strong><code>GraphingCalculator</code></strong> 类，它继承自 **<code>Calculator</code>**，并实现 <strong><code>calculate(_:)</code></strong> 方法：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphingCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">super</span>.calculate(expression)        <span class="hljs-comment">// 将计算结果以图表的形式展示出来</span>        <span class="hljs-keyword">return</span> result    &#125;&#125;</code></pre></div><p>现在，我们可以使用 <strong><code>GraphingCalculator</code></strong> 对象来进行数学计算，并将计算结果以图表的形式展示出来：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> simpleCalculator <span class="hljs-operator">=</span> <span class="hljs-type">SimpleCalculator</span>()<span class="hljs-keyword">let</span> scientificCalculator <span class="hljs-operator">=</span> <span class="hljs-type">ScientificCalculator</span>()<span class="hljs-keyword">let</span> graphingCalculator <span class="hljs-operator">=</span> <span class="hljs-type">GraphingCalculator</span>()<span class="hljs-keyword">let</span> expressions <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;2 + 2&quot;</span>, <span class="hljs-string">&quot;sin(45)&quot;</span>, <span class="hljs-string">&quot;log(10)&quot;</span>]<span class="hljs-keyword">for</span> expression <span class="hljs-keyword">in</span> expressions &#123;    <span class="hljs-keyword">let</span> simpleResult <span class="hljs-operator">=</span> simpleCalculator.calculate(expression)    <span class="hljs-keyword">let</span> scientificResult <span class="hljs-operator">=</span> scientificCalculator.calculate(expression)    <span class="hljs-keyword">let</span> graphingResult <span class="hljs-operator">=</span> graphingCalculator.calculate(expression)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Simple: <span class="hljs-subst">\(simpleResult)</span>, Scientific: <span class="hljs-subst">\(scientificResult)</span>, Graphing: <span class="hljs-subst">\(graphingResult)</span>&quot;</span>)&#125;</code></pre></div><p>输出结果如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-type">Simple</span>: <span class="hljs-number">4.0</span>, <span class="hljs-type">Scientific</span>: <span class="hljs-number">0.8509035245341184</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">4.0</span><span class="hljs-type">Simple</span>: <span class="hljs-number">0.8509035245341184</span>,<span class="hljs-type">Scientific</span>: <span class="hljs-number">0.8509035245341184</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">0.8509035245341184</span><span class="hljs-type">Simple</span>: <span class="hljs-number">2.302585092994046</span>, <span class="hljs-type">Scientific</span>: <span class="hljs-number">2.302585092994046</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">2.302585092994046</span></code></pre></div><p>可以看到，我们成功地将 <code>GraphingCalculator</code> 对象替换为 <code>SimpleCalculator</code> 和 <code>ScientificCalculator</code> 对象，而不会影响程序的正确性。这就是 LSP 的优势。</p><p>总之，LSP 是一个非常重要的面向对象编程原则，它可以帮助我们创建灵活、可扩展、易于维护的代码。为了遵循 LSP，我们需要在设计类的时候遵循一些基本的规则，并保证子类可以完全替换父类，而不会影响程序的正确性。</p><h3 id="4-接口隔离原则（Interface-Segregation-Principle，ISP）"><a href="#4-接口隔离原则（Interface-Segregation-Principle，ISP）" class="headerlink" title="4. 接口隔离原则（Interface Segregation Principle，ISP）"></a>4. 接口隔离原则（Interface Segregation Principle，ISP）</h3><p>接口隔离原则（Interface Segregation Principle，ISP）是面向对象编程中的一条原则，它指出“客户端不应该被迫依赖于它不使用的方法”。换句话说，如果一个接口的方法过于冗杂，一个类可能不得不实现一些它并不需要的方法。这不仅浪费了时间和资源，而且会导致代码的复杂性和脆弱性。</p><p>ISP 的主要目的是分离接口，将大型、复杂的接口分解为更小、更简单的接口，以便客户端只需知道与其相关的方法。这样，客户端就不必担心不需要的方法，而只需要专注于与其相关的方法。</p><p>为了遵循 ISP，我们需要在设计接口时考虑到客户端的需要，并将其分解为更小、更简单的接口。这样，客户端只需要依赖它们需要的接口，而不必依赖于整个接口。</p><p>下面是一个使用 ISP 的例子。假设我们正在设计一个图形编辑器，其中有多种形状（如矩形、圆形、三角形等）。每个形状都可以绘制、移动、调整大小等。我们可以将这些操作定义在一个大型的 <strong><code>Shape</code></strong> 接口中，如下所示：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">to</span> <span class="hljs-params">point</span>: <span class="hljs-type">CGPoint</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">resize</span>(<span class="hljs-params">to</span> <span class="hljs-params">size</span>: <span class="hljs-type">CGSize</span>)&#125;</code></pre></div><p>然而，如果我们这样设计，那么所有的形状都必须实现所有的方法，即使它们并不需要某些方法。这显然不符合 ISP。为了解决这个问题，我们可以将这个大型接口拆分为多个更小、更专业的接口，如下所示：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Drawable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>()&#125;<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Movable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">to</span> <span class="hljs-params">point</span>: <span class="hljs-type">CGPoint</span>)&#125;<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Resizable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">resize</span>(<span class="hljs-params">to</span> <span class="hljs-params">size</span>: <span class="hljs-type">CGSize</span>)&#125;<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Shape</span>: <span class="hljs-title class_">Drawable</span>, <span class="hljs-title class_">Movable</span>, <span class="hljs-title class_">Resizable</span> &#123;&#125;</code></pre></div><p>现在，我们的每个形状只需要实现与其相关的方法。例如，圆形只需要实现 <strong><code>Drawable</code></strong> 和 <strong><code>Resizable</code></strong> 接口，而不需要实现 <strong><code>Movable</code></strong> 接口。这样，我们的代码就更加灵活，易于扩展和维护了。</p><p>总之，ISP 是一个非常重要的面向对象编程原则，它可以帮助我们创建灵活、可扩展、易于维护的代码。为了遵循 ISP，我们需要在设计接口时考虑客户端的需要，并将其拆分为更小、更简单的接口。</p><h3 id="5-迪米特法则（Law-of-Demeter，LoD）"><a href="#5-迪米特法则（Law-of-Demeter，LoD）" class="headerlink" title="5. 迪米特法则（Law of Demeter，LoD）"></a>5. 迪米特法则（Law of Demeter，LoD）</h3><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Principle of Least Knowledge），是面向对象编程中的一条设计原则，它强调一个对象应该尽可能少地了解其他对象，并且只和它们的直接朋友（成员变量、方法参数等）通信，而不与非直接朋友进行通信。</p><p>迪米特法则的目的是减少类之间的耦合度，提高系统的稳定性、可维护性和可扩展性。当一个类依赖的其他类太多时，如果这些依赖的类发生了改变，就会对该类产生较大的影响，从而导致代码的复杂度增加。因此，遵循迪米特法则可以使得类之间的耦合度降低，从而使得代码更加模块化、易于维护和重构。</p><p>下面以 Swift 5 代码举例，展示如何使用迪米特法则来减少类之间的耦合度。假设我们有一个订单类，它需要依赖客户类和商品类来进行处理：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;    <span class="hljs-keyword">var</span> customerId: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> productId: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> quantity: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">productId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">quantity</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.customerId <span class="hljs-operator">=</span> customerId        <span class="hljs-keyword">self</span>.productId <span class="hljs-operator">=</span> productId        <span class="hljs-keyword">self</span>.quantity <span class="hljs-operator">=</span> quantity    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateTotal</span>() -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">let</span> customer <span class="hljs-operator">=</span> <span class="hljs-type">Customer</span>.getCustomerById(customerId: customerId)        <span class="hljs-keyword">let</span> product <span class="hljs-operator">=</span> <span class="hljs-type">Product</span>.getProductById(productId: productId)        <span class="hljs-keyword">let</span> totalPrice <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(quantity) <span class="hljs-operator">*</span> product.price        <span class="hljs-keyword">return</span> totalPrice    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span> &#123;        <span class="hljs-comment">// 模拟获取客户对象的过程</span>        <span class="hljs-keyword">return</span> <span class="hljs-type">Customer</span>(id: customerId, name: <span class="hljs-string">&quot;&quot;</span>)    &#125;    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span> &#123;        <span class="hljs-comment">// 模拟获取商品对象的过程</span>        <span class="hljs-keyword">return</span> <span class="hljs-type">Product</span>(id: productId, name: <span class="hljs-string">&quot;&quot;</span>, price: <span class="hljs-number">0.0</span>)    &#125;    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">price</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name        <span class="hljs-keyword">self</span>.price <span class="hljs-operator">=</span> price    &#125;&#125;</code></pre></div><p>在上述代码中，订单类依赖了客户类和商品类的静态方法，通过这些静态方法获取了客户对象和商品对象。这种方式违反了迪米特法则，因为订单类不仅需要了解客户类和商品类的接口，还需要了解它们的具体实现细节。</p><p>为了遵循迪米特法则，我们可以通过依赖注入的方式，来减少订单类对客户类和商品类的依赖。下面是修改后的代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">CustomerProtocol</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerService</span>: <span class="hljs-title class_">CustomerProtocol</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span> &#123;        <span class="hljs-comment">// 模拟获取客户对象的过程</span>        <span class="hljs-keyword">return</span> <span class="hljs-type">Customer</span>(id: customerId, name: <span class="hljs-string">&quot;&quot;</span>)    &#125;&#125;<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">ProductProtocol</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductService</span>: <span class="hljs-title class_">ProductProtocol</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span> &#123;        <span class="hljs-comment">// 模拟获取商品对象的过程</span>        <span class="hljs-keyword">return</span> <span class="hljs-type">Product</span>(id: productId, name: <span class="hljs-string">&quot;&quot;</span>, price: <span class="hljs-number">0.0</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;    <span class="hljs-keyword">var</span> customerId: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> productId: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> quantity: <span class="hljs-type">Int</span>    <span class="hljs-keyword">var</span> customerService: <span class="hljs-type">CustomerProtocol</span>    <span class="hljs-keyword">var</span> productService: <span class="hljs-type">ProductProtocol</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">productId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">quantity</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">customerService</span>: <span class="hljs-type">CustomerProtocol</span>, <span class="hljs-params">productService</span>: <span class="hljs-type">ProductProtocol</span>) &#123;        <span class="hljs-keyword">self</span>.customerId <span class="hljs-operator">=</span> customerId        <span class="hljs-keyword">self</span>.productId <span class="hljs-operator">=</span> productId        <span class="hljs-keyword">self</span>.quantity <span class="hljs-operator">=</span> quantity        <span class="hljs-keyword">self</span>.customerService <span class="hljs-operator">=</span> customerService        <span class="hljs-keyword">self</span>.productService <span class="hljs-operator">=</span> productService    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateTotal</span>() -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">let</span> customer <span class="hljs-operator">=</span> customerService.getCustomerById(customerId: customerId)        <span class="hljs-keyword">let</span> product <span class="hljs-operator">=</span> productService.getProductById(productId: productId)        <span class="hljs-keyword">let</span> totalPrice <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(quantity) <span class="hljs-operator">*</span> product.price        <span class="hljs-keyword">return</span> totalPrice    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">price</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name        <span class="hljs-keyword">self</span>.price <span class="hljs-operator">=</span> price    &#125;&#125;</code></pre></div><p>在上述代码中，我们使用协议和依赖注入的方式来降低订单类对客户类和商品类的耦合度。具体来说，我们定义了两个协议 <code>CustomerProtocol</code> 和 <code>ProductProtocol</code>，分别包含了获取客户对象和商品对象的方法。然后我们实现了两个具体的服务类 <code>CustomerService</code> 和 <code>ProductService</code>，它们分别实现了上述协议中定义的方法，用于提供客户对象和商品对象的获取功能。</p><p>接下来，我们修改了订单类的构造函数，将客户服务对象和商品服务对象作为参数传入。在 calculateTotal 方法中，我们不再直接调用客户类和商品类的静态方法，而是通过客户服务对象和商品服务对象来获取客户对象和商品对象。这样一来，订单类只依赖了客户服务类和商品服务类的接口，而不再依赖它们的具体实现细节，这就遵循了迪米特法则。</p><p>总之，迪米特法则是一条重要的设计原则，它可以帮助我们减少类之间的耦合度，提高系统的稳定性、可维护性和可扩展性。在编写代码时，我们应该尽可能地遵循这个原则，尽量减少类之间的交互，使得每个类的职责更加清晰，代码结构更加简单易懂，从而使得代码更加健壮和可维护。</p><p>需要注意的是，在实际开发中，迪米特法则并不是一个银弹，它并不能解决所有的问题，也不能被简单地应用到所有的场景中。在某些情况下，迪米特法则可能会导致类之间的通信变得复杂，从而降低系统的效率和性能。因此，在应用迪米特法则时，我们需要根据具体的情况来灵活运用，综合考虑各种因素，找到最合适的设计方案。</p><p>“银弹”是一个编程界中的术语，指的是一种能够解决所有问题的神奇解决方案。因此，“迪米特法则并不是一个银弹”意味着迪米特法则并不能解决所有问题，我们需要根据具体情况进行灵活应用和综合考虑。</p><h3 id="6-依赖倒置原则（Dependency-Inversion-Principle，DIP）"><a href="#6-依赖倒置原则（Dependency-Inversion-Principle，DIP）" class="headerlink" title="6. 依赖倒置原则（Dependency Inversion Principle，DIP）"></a>6. 依赖倒置原则（Dependency Inversion Principle，DIP）</h3><p>依赖倒置原则（Dependency Inversion Principle，DIP）是面向对象设计中的一个重要原则，它强调高层模块不应该依赖低层模块，它们都应该依赖于抽象；而抽象不应该依赖于细节，细节应该依赖于抽象。简单来说，就是要面向接口编程，而不是面向实现编程。</p><p>依赖倒置原则的作用是降低模块之间的耦合度，提高代码的灵活性、可扩展性和可维护性。它可以避免在修改一个模块时，对其他模块造成影响，同时也能够方便地进行单元测试和模块重用。</p><p>下面是使用 Swift 5 实现依赖倒置原则的一个示例：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 定义一个协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Animal</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>()&#125;<span class="hljs-comment">// 实现两个类，它们都遵循了 Animal 协议</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>: <span class="hljs-title class_">Animal</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Meow&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <span class="hljs-title class_">Animal</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Woof&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 定义一个高层模块，它依赖于 Animal 协议</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalShelter</span> &#123;    <span class="hljs-keyword">var</span> animals: [<span class="hljs-type">Animal</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addAnimal</span>(<span class="hljs-params">animal</span>: <span class="hljs-type">Animal</span>) &#123;        animals.append(animal)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeAllAnimalsSound</span>() &#123;        <span class="hljs-keyword">for</span> animal <span class="hljs-keyword">in</span> animals &#123;            animal.makeSound()        &#125;    &#125;&#125;<span class="hljs-comment">// 在客户端代码中，可以通过向 AnimalShelter 添加不同的 Animal 来实现不同的行为</span><span class="hljs-keyword">let</span> animalShelter <span class="hljs-operator">=</span> <span class="hljs-type">AnimalShelter</span>()animalShelter.addAnimal(animal: <span class="hljs-type">Cat</span>())animalShelter.addAnimal(animal: <span class="hljs-type">Dog</span>())animalShelter.makeAllAnimalsSound()</code></pre></div><p>在上面的示例中，Animal 是一个抽象的概念，Cat 和 Dog 是具体的实现类。AnimalShelter 是一个高层模块，它不依赖于具体的实现类，而是依赖于 Animal 协议。在客户端代码中，可以通过向 AnimalShelter 添加不同的 Animal 来实现不同的行为，而不需要修改 AnimalShelter 类的代码。</p><p>这就是依赖倒置原则的一个实现，它通过引入抽象的概念，降低了 AnimalShelter 和具体实现类之间的耦合度，提高了代码的可扩展性和可维护性。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/2023/02/25/other/hello-world/"/>
    <url>/2023/02/25/other/hello-world/</url>
    
    <content type="html"><![CDATA[<p>自从认识 notion 以来，一直都只使用 notion 写东西就再也没玩博客也了。notion 虽然也能分享页面链接，但用作于博客还是不太方便。今天有时间空下来，专门研究了一下 github.io 如何搭建个人博客网站，发现 Hexo &amp; Fluid 原来是这么的方便、这么的好用。<br>写 blog 只需简单的执行几句命令行：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一篇博客文章</span>hexo new <span class="hljs-string">&quot;title&quot;</span><span class="hljs-comment"># 清理缓存 -&gt; 本地测试（就可以直接预览）</span>hexo clean &amp; hexo s<span class="hljs-comment"># 清理缓存 -&gt; 生存静态页 -&gt; 部署到github (等 10 分钟就可发布成功，因为github缓存)</span>hexo clean &amp; hexo g &amp; hexo d</code></pre></div><p>只需要上面的几句命令，就可以发布一篇 blog，简直爱❤️了。</p><p>hexo 同样也支持 markdown 格式，这样就可以把 notion 里的文章，搬到 github.io 上来当 blog 页使用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
